<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java面向对象基础二</title>
      <link href="/2025/06/10/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E4%BA%8C/"/>
      <url>/2025/06/10/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="类变量和类方法"><a href="#类变量和类方法" class="headerlink" title="类变量和类方法"></a>类变量和类方法</h1><h2 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol><li>类变量也叫静态变量&#x2F;静态属性，是该类的所有对象共享的变量，任何一个该类的对象去访问它时，取到的都是相同的值</li><li>同样任何一个该类的对象去修改它时，修改的也是同一个变量</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChildGame</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个变量 count, 统计有多少小孩加入了游戏</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Child</span> <span class="variable">child1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;白骨精&quot;</span>);</span><br><span class="line">        child1.join();</span><br><span class="line">        <span class="comment">//count++;</span></span><br><span class="line">        child1.count++;</span><br><span class="line"></span><br><span class="line">        <span class="type">Child</span> <span class="variable">child2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;狐狸精&quot;</span>);</span><br><span class="line">        child2.join();</span><br><span class="line">        <span class="comment">//count++;</span></span><br><span class="line">        child2.count++;</span><br><span class="line"></span><br><span class="line">        <span class="type">Child</span> <span class="variable">child3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;老鼠精&quot;</span>);</span><br><span class="line">        child3.join();</span><br><span class="line">        <span class="comment">//count++;</span></span><br><span class="line">        child3.count++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//===========</span></span><br><span class="line">        <span class="comment">//类变量，可以通过类名来访问</span></span><br><span class="line">        System.out.println(<span class="string">&quot;共有&quot;</span> + Child.count  + <span class="string">&quot; 小孩加入了游戏...&quot;</span>);</span><br><span class="line">        <span class="comment">//下面的代码输出什么?</span></span><br><span class="line">        System.out.println(<span class="string">&quot;child1.count=&quot;</span> + child1.count);<span class="comment">//3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;child2.count=&quot;</span> + child2.count);<span class="comment">//3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;child3.count=&quot;</span> + child3.count);<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> &#123; <span class="comment">//类</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//定义一个变量 count ,是一个类变量(静态变量) static 静态</span></span><br><span class="line">    <span class="comment">//该变量最大的特点就是会被Child 类的所有的对象实例共享</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Child</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; 加入了游戏..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义类变量"><a href="#定义类变量" class="headerlink" title="定义类变量"></a>定义类变量</h3><p><strong>定义：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">访问修饰符 <span class="keyword">static</span> 数据类型 变量名；</span><br></pre></td></tr></table></figure><p><strong>访问：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类名.类变量名</span><br><span class="line">或</span><br><span class="line">对象名.类变量名</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>静态变量的访问修饰符的访问权限和范围和普通属性是一样的</li><li>类变量是随着类的加载而创建，所以即使没有创建对象实例也可以访问</li><li>从 JDK8.0 开始，static 修饰的成员变量的元数据位于元空间（方法区的一种实现方式）中，但真正的值位于堆内存中（JDK7.0 开始）</li></ol><p><strong>说明 :</strong> 当类加载器将含有 static 修饰的成员变量的类加载到方法区时，会根据反射机制生成一个字节码文件对象，即 Class 对象。Class 对象在堆空间中，保存了对应类的静态变量的值。如下图所示 : （<strong>即所有对象访问的某个类变量，其实就是那一份</strong>）</p><p><img src="https://img.dexbug.com/i/2025/06/09/2cu80l.png" alt="img"></p><h3 id="类变量使用细节"><a href="#类变量使用细节" class="headerlink" title="类变量使用细节"></a>类变量使用细节</h3><ol><li>什么时候需要用类变量<ol><li>当需要让某给类的使用对象都共享一个变量时，就可以考虑使用类变量，比如：定义学生类，统计所有学生共交多少钱</li></ol></li><li>类变量与实例变量（普通属性）的区别<ol><li>类变量是该类使用对象共享的，而实例变量是每个对象独享的</li></ol></li><li>加上 static 称为类变量或静态变量，否则称为实例变量&#x2F;普通变量&#x2F;非静态变量</li><li>类变量既可以通过“类名。”的形式来调用，也可以通过“对象。”的形式来调用，优先使用“类名。”的形式来访问类变量（在访问类变量时，也要遵循访问权限修饰符的规则）</li><li>非静态变量不能通过“类名。”的形式来访问，只能通过“对象。”的形式来访问</li><li>类变量在类加载时就要初始化，也就是说，即使没有创建对象，只要类加载了，就可以使用类变量了</li><li>类变量的生命周期是随类的加载开始，随着类消亡而销毁</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticDetail</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        <span class="comment">//System.out.println(B.n1);</span></span><br><span class="line">        System.out.println(B.n2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//静态变量是类加载的时候，就创建了,所以我们没有创建对象实例</span></span><br><span class="line">        <span class="comment">//也可以通过类名.类变量名来访问</span></span><br><span class="line">        System.out.println(C.address);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> <span class="string">&quot;北京&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VisitStatic</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//类名.类变量名</span></span><br><span class="line">        <span class="comment">//说明：类变量是随着类的加载而创建，所以即使没有创建对象实例也可以访问</span></span><br><span class="line">        System.out.println(A.name);</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="comment">//通过对象名.类变量名</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a.name=&quot;</span> + a.name);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">//类变量</span></span><br><span class="line">    <span class="comment">//类变量的访问，必须遵守 相关的访问权限.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;韩顺平教育&quot;</span>;</span><br><span class="line">    <span class="comment">//普通属性/普通成员变量/非静态属性/非静态成员变量/实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>类方法也叫静态方法</p><p><strong>定义形式：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">访问修饰符 <span class="keyword">static</span> 数据返回类型 方法名 () &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>调用：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类名.方法名</span><br><span class="line">对象名.方法名</span><br></pre></td></tr></table></figure><p><strong>案例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建2个学生对象，叫学费</span></span><br><span class="line">        <span class="type">Stu</span> <span class="variable">tom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        <span class="comment">//tom.payFee(100);</span></span><br><span class="line">        Stu.payFee(<span class="number">100</span>);<span class="comment">//对不对?对</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Stu</span> <span class="variable">mary</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>(<span class="string">&quot;mary&quot;</span>);</span><br><span class="line">        <span class="comment">//mary.payFee(200);</span></span><br><span class="line">        Stu.payFee(<span class="number">200</span>);<span class="comment">//对</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出当前收到的总学费</span></span><br><span class="line">        Stu.showFee();<span class="comment">//300</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果我们希望不创建实例，也可以调用某个方法(即当做工具来使用)</span></span><br><span class="line">        <span class="comment">//这时，把方法做成静态方法时非常合适</span></span><br><span class="line">        System.out.println(<span class="string">&quot;9开平方的结果是=&quot;</span> + Math.sqrt(<span class="number">9</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(MyTools.calSum(<span class="number">10</span>, <span class="number">30</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//开发自己的工具类时，可以将方法做成静态的，方便调用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTools</span>  &#123;</span><br><span class="line">    <span class="comment">//求出两个数的和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">calSum</span><span class="params">(<span class="type">double</span> n1, <span class="type">double</span> n2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>  n1 + n2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可以写出很多这样的工具方法...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//普通成员</span></span><br><span class="line">    <span class="comment">//定义一个静态变量，来累积学生的学费</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="variable">fee</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Stu</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说明</span></span><br><span class="line">    <span class="comment">//1. 当方法使用了static修饰后，该方法就是静态方法</span></span><br><span class="line">    <span class="comment">//2. 静态方法就可以访问静态属性/变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">payFee</span><span class="params">(<span class="type">double</span> fee)</span> &#123;</span><br><span class="line">        Stu.fee += fee;<span class="comment">//累积到</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showFee</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;总学费有:&quot;</span> + Stu.fee);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类方法使用细节"><a href="#类方法使用细节" class="headerlink" title="类方法使用细节"></a>类方法使用细节</h3><ol><li>类方法的使用场景<ol><li>只需要访问静态成员，且不涉及到任何和对象相关的成员，所需参数均可由形参列表显式提供，这时候我们就可以定义静态方法</li></ol></li><li>类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区<ol><li>类方法中无 this 的参数</li><li>普通方法中隐含着 this 的参数</li></ol></li><li>类方法可以通过类名调用，也可以通过对象名调用</li><li>普通方法和对象有关，需要对象名调用，不能通过类名调用</li><li>类方法中不允许使用和对象有关的关键字，比如 this 和 super</li><li>类方法（静态方法）中，只能访问静态变量或静态方法</li><li>普通成员方法，既可以访问非静态成员，也可以访问静态成员</li></ol><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticMethodDetail</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line"></span><br><span class="line">        D.<span class="title function_">hi</span>();<span class="comment">//ok</span></span><br><span class="line">        <span class="comment">//非静态方法，不能通过类名调用</span></span><br><span class="line">        <span class="comment">//D.say();, 错误，需要先创建对象，再调用</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title function_">D</span>().<span class="title function_">say</span>();<span class="comment">//可以</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> int n1 = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  int n2 = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">say</span>(<span class="params"></span>) &#123;<span class="comment">//非静态方法,普通方法</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="built_in">void</span> <span class="title function_">hi</span>(<span class="params"></span>) &#123;<span class="comment">//静态方法,类方法</span></span><br><span class="line">        <span class="comment">//类方法中不允许使用和对象有关的关键字，</span></span><br><span class="line">        <span class="comment">//比如this和super。普通方法(成员方法)可以。</span></span><br><span class="line">        <span class="comment">//System.out.println(this.n1);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类方法(静态方法)中 只能访问 静态变量 或静态方法</span></span><br><span class="line">    <span class="comment">//口诀:静态方法只能访问静态成员.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">hello</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(n2);</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(D.<span class="property">n2</span>);</span><br><span class="line">        <span class="comment">//System.out.println(this.n2);不能使用</span></span><br><span class="line">        <span class="title function_">hi</span>();<span class="comment">//OK</span></span><br><span class="line">        <span class="comment">//say();//错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//普通成员方法，既可以访问  非静态成员，也可以访问静态成员</span></span><br><span class="line">    <span class="comment">//小结: 非静态方法可以访问 静态成员和非静态成员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">ok</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//非静态成员</span></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(n1);</span><br><span class="line">        <span class="title function_">say</span>();</span><br><span class="line">        <span class="comment">//静态成员</span></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(n2);</span><br><span class="line">        <span class="title function_">hello</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="理解-main-方法"><a href="#理解-main-方法" class="headerlink" title="理解 main 方法"></a>理解 main 方法</h1><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line">            <span class="comment">//方法体（代码）</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li><strong>main</strong> <strong>函数是所有程序的唯一入口，由</strong> <strong>jvm</strong> <strong>来调用</strong></li><li>Java 虚拟机需要调用类的 main（）方法，所以该方法的访问权限必须是 public</li><li>Java 虚拟机在执行 main（）方法时不必创建对象，所以该方法必须是 static</li><li>该方法接收 String 类型的数组参数，该数组中保存执行 Java 命令是传递给所有运行的类的参数</li><li>Java 执行的程序 参数 1 参数 2 参数 3</li><li>在 main（）方法中，我们可以直接调用 main 方法所在类的静态方法或静态属性</li><li>但是不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员</li></ol><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的变量/属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="title class_">String</span> name = <span class="string">&quot;韩顺平教育&quot;</span>;</span><br><span class="line">    <span class="comment">//非静态的变量/属性</span></span><br><span class="line">    <span class="keyword">private</span> int n1 = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="built_in">void</span> <span class="title function_">hi</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;Main01的 hi方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">cry</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;Main01的 cry方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//可以直接使用 name</span></span><br><span class="line">        <span class="comment">//1. 静态方法main 可以访问本类的静态成员</span></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;name=&quot;</span> + name);</span><br><span class="line">        <span class="title function_">hi</span>();</span><br><span class="line">        <span class="comment">//2. 静态方法main 不可以访问本类的非静态成员</span></span><br><span class="line">        <span class="comment">//System.out.println(&quot;n1=&quot; + n1);//错误</span></span><br><span class="line">        <span class="comment">//cry();</span></span><br><span class="line">        <span class="comment">//3. 静态方法main 要访问本类的非静态成员，需要先创建对象 , 再调用即可</span></span><br><span class="line">        <span class="title class_">Main01</span> main01 = <span class="keyword">new</span> <span class="title class_">Main01</span>();</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(main01.<span class="property">n1</span>);<span class="comment">//ok</span></span><br><span class="line">        main01.<span class="title function_">cry</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> ( int i = <span class="number">0</span>; i &lt; args.<span class="property">length</span>; i++ ) &#123;</span><br><span class="line">            <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;args[&quot;</span> + i + <span class="string">&quot;] = &quot;</span> + args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>代码块，也称为初始化块，属于类中的成员（即和属性，方法一样，是类的一部分），类似于方法，将逻辑语句封装在方法体中，通过{}包围起来</p><p>但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显式调用，而是加载类时或创建对象时隐式调用</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法体语句。（代码）</span></span><br><span class="line"></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ol><li>修饰符可选，修饰符只能写 static</li><li>代码块分为两类，使用 static 修饰的叫静态代码块，没有 static 修饰的叫普通代码块&#x2F;非静态代码块</li><li>逻辑语句可以为任何逻辑语句（输入，输出，方法调用，循环，判断等）</li><li>; 可写可不写</li></ol><h2 id="代码块的使用细节"><a href="#代码块的使用细节" class="headerlink" title="代码块的使用细节"></a>代码块的使用细节</h2><ol><li>static 代码块也叫静态代码块，作用就是对类进行初始化，<strong>而且它随着类的加载而执行，并且只会执行一次</strong></li><li>类什么时候被加载<ol><li>创建对象实例时（new）</li><li>创建子类对象实例，父类也会被加载</li><li>使用类的静态成员时（静态属性，静态方法）</li></ol></li><li>普通的代码块，在创建对象实例时，会被隐式的调用<ol><li><strong>被创建一次，就会调用一次</strong></li><li>如果只是使用类的静态成员时，普通代码块并不会执行</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeBlockDetail01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//类被加载的情况举例</span></span><br><span class="line">        <span class="comment">//1. 创建对象实例时(new)</span></span><br><span class="line">        <span class="comment">// AA aa = new AA();</span></span><br><span class="line">        <span class="comment">//2. 创建子类对象实例，父类也会被加载, 而且，父类先被加载，子类后被加载</span></span><br><span class="line">        <span class="comment">// AA aa2 = new AA();</span></span><br><span class="line">        <span class="comment">//3. 使用类的静态成员时(静态属性，静态方法)</span></span><br><span class="line">        <span class="comment">// System.out.println(Cat.n1);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//static代码块，是在类加载时，执行的，而且只会执行一次.</span></span><br><span class="line"><span class="comment">//        DD dd = new DD();</span></span><br><span class="line"><span class="comment">//        DD dd1 = new DD();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//普通的代码块，在创建对象实例时，会被隐式的调用。</span></span><br><span class="line">        <span class="comment">// 被创建一次，就会调用一次。</span></span><br><span class="line">        <span class="comment">// 如果只是使用类的静态成员时，普通代码块并不会执行</span></span><br><span class="line"></span><br><span class="line">        System.out.println(DD.n1);<span class="comment">//8888, 静态模块块一定会执行</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DD</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">8888</span>;<span class="comment">//静态属性</span></span><br><span class="line">    <span class="comment">//静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DD 的静态代码1被执行...&quot;</span>);<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//普通代码块, 在new 对象时，被调用，而且是每创建一个对象，就调用一次</span></span><br><span class="line">    <span class="comment">//可以这样简单的，理解 普通代码块是构造器的补充</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DD 的普通代码块...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">//静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal 的静态代码1被执行...&quot;</span>);<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">999</span>;<span class="comment">//静态属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat 的静态代码1被执行...&quot;</span>);<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span> &#123;</span><br><span class="line">    <span class="comment">//静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BB 的静态代码1被执行...&quot;</span>);<span class="comment">//1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span> <span class="keyword">extends</span> <span class="title class_">BB</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AA 的静态代码1被执行...&quot;</span>);<span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>创建一个对象时，在一个类调用顺序<ol><li>调用静态代码块和静态属性初始化（静态代码块和静态属性初始化调用的优先级一样，按照定义的顺序调用）</li><li>调用普通代码块和普通属性的初始化（普通代码块和普通属性初始话调用的优先级一样，按定义顺序调用）</li><li>调用构造方法</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeBlockDetail02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();<span class="comment">// (1) A 静态代码块01 (2) getN1被调用...(3)A 普通代码块01(4)getN2被调用...(5)A() 构造器被调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    &#123; <span class="comment">//普通代码块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;A 普通代码块01&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> getN2();<span class="comment">//普通属性的初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123; <span class="comment">//静态代码块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;A 静态代码块01&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态属性的初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> getN1();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getN1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;getN1被调用...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getN2</span><span class="params">()</span> &#123; <span class="comment">//普通方法/非静态方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;getN2被调用...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//无参构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A() 构造器被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>构造器的前面隐含了 super（）和调用普通代码块，静态相关的代码块，属性初始化，在类加载时，就执行完毕，因此优先于构造器和普通代码块</li></ol><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeBlockDetail03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title function_">BBB</span>();<span class="comment">//(1)AAA的普通代码块(2)AAA() 构造器被调用(3)BBB的普通代码块(4)BBB() 构造器被调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AAA</span> &#123; <span class="comment">//父类Object</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;AAA的普通代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AAA</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//(1)super()</span></span><br><span class="line">        <span class="comment">//(2)调用本类的普通代码块</span></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;AAA() 构造器被调用....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BBB</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AAA</span>  &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;BBB的普通代码块...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BBB</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//(1)super()</span></span><br><span class="line">        <span class="comment">//(2)调用本类的普通代码块</span></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;BBB() 构造器被调用....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>创建一个子类对象时（继承关系），它的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序<ol><li>父类的静态代码块和静态属性（优先级一样，按定义顺序执行）</li><li>子类的静态代码块和静态属性（优先级一样，按定义顺序执行）</li><li>父类的晋通代码块和普通属性初始化（优先级一样，按定义顺序执行）</li><li>父类的构造方法</li><li>子类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）</li><li>子类的构造方法 &#x2F;&#x2F;面试题</li></ol></li><li>静态代码块只能直接调用静态成员，普通代码块可以调用任意成员</li></ol><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeBlockDetail04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="comment">//(1) 进行类的加载</span></span><br><span class="line">        <span class="comment">//1.1 先加载 父类 A02 1.2 再加载 B02</span></span><br><span class="line">        <span class="comment">//(2) 创建对象</span></span><br><span class="line">        <span class="comment">//2.1 从子类的构造器开始</span></span><br><span class="line">        <span class="comment">//new B02();//对象</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title function_">C02</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A02</span> &#123; <span class="comment">//父类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> int n1 = <span class="title function_">getVal01</span>();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;A02的一个静态代码块..&quot;</span>);<span class="comment">//(2)</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;A02的第一个普通代码块..&quot;</span>);<span class="comment">//(5)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> int n3 = <span class="title function_">getVal02</span>();<span class="comment">//普通属性的初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> int <span class="title function_">getVal01</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;getVal01&quot;</span>);<span class="comment">//(1)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> int <span class="title function_">getVal02</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;getVal02&quot;</span>);<span class="comment">//(6)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A02</span>(<span class="params"></span>) &#123;<span class="comment">//构造器</span></span><br><span class="line">        <span class="comment">//隐藏</span></span><br><span class="line">        <span class="comment">//super()</span></span><br><span class="line">        <span class="comment">//普通代码和普通属性的初始化......</span></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;A02的构造器&quot;</span>);<span class="comment">//(7)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C02</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> int n1 = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  int n2 = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">void</span> <span class="title function_">m1</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">m2</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//静态代码块，只能调用静态成员</span></span><br><span class="line">        <span class="comment">//System.out.println(n1);错误</span></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(n2);<span class="comment">//ok</span></span><br><span class="line">        <span class="comment">//m1();//错误</span></span><br><span class="line">        <span class="title function_">m2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//普通代码块，可以使用任意成员</span></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(n1);</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(n2);<span class="comment">//ok</span></span><br><span class="line">        <span class="title function_">m1</span>();</span><br><span class="line">        <span class="title function_">m2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B02</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A02</span> &#123; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> int n3 = <span class="title function_">getVal03</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;B02的一个静态代码块..&quot;</span>);<span class="comment">//(4)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> int n5 = <span class="title function_">getVal04</span>();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;B02的第一个普通代码块..&quot;</span>);<span class="comment">//(9)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> int <span class="title function_">getVal03</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;getVal03&quot;</span>);<span class="comment">//(3)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> int <span class="title function_">getVal04</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;getVal04&quot;</span>);<span class="comment">//(8)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一定要慢慢的去品..</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B02</span>(<span class="params"></span>) &#123;<span class="comment">//构造器</span></span><br><span class="line">        <span class="comment">//隐藏了</span></span><br><span class="line">        <span class="comment">//super()</span></span><br><span class="line">        <span class="comment">//普通代码块和普通属性的初始化...</span></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;B02的构造器&quot;</span>);<span class="comment">//(10)</span></span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><ol><li>所谓类的单例设计模式，就是采取一定的方法保证在整个软件系统中，对某给类只能存在一个对象实例，并且该类只能提供一个取得其对象实例的方法</li><li>单例模式有两种方式（饿汉式，懒汉式）</li></ol><h2 id="单例模式应用实例"><a href="#单例模式应用实例" class="headerlink" title="单例模式应用实例"></a>单例模式应用实例</h2><p>饿汉式和懒汉式单例模式的实现</p><ol><li>构造器私有化&#x3D;》防止直接 new</li><li>类的内部创建对象</li><li>向外暴露一个静态的公共方法。 getlnstance</li></ol><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleTon01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line"><span class="comment">//        GirlFriend xh = new GirlFriend(&quot;小红&quot;);</span></span><br><span class="line"><span class="comment">//        GirlFriend xb = new GirlFriend(&quot;小白&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过方法可以获取对象</span></span><br><span class="line">        <span class="title class_">GirlFriend</span> instance = <span class="title class_">GirlFriend</span>.<span class="title function_">getInstance</span>();</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(instance);</span><br><span class="line"></span><br><span class="line">        <span class="title class_">GirlFriend</span> instance2 = <span class="title class_">GirlFriend</span>.<span class="title function_">getInstance</span>();</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(instance2);</span><br><span class="line"></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(instance == instance2);<span class="comment">//T</span></span><br><span class="line">        <span class="comment">//System.out.println(GirlFriend.n1);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有一个类， GirlFriend</span></span><br><span class="line"><span class="comment">//只能有一个女朋友</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GirlFriend</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">String</span> name;</span><br><span class="line">    <span class="comment">//public static  int n1 = 100;</span></span><br><span class="line">    <span class="comment">//为了能够在静态方法中，返回 gf对象，需要将其修饰为static</span></span><br><span class="line">    <span class="comment">//對象，通常是重量級的對象, 餓漢式可能造成創建了對象，但是沒有使用.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="title class_">GirlFriend</span> gf = <span class="keyword">new</span> <span class="title class_">GirlFriend</span>(<span class="string">&quot;小红红&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如何保障我们只能创建一个 GirlFriend 对象</span></span><br><span class="line">    <span class="comment">//步骤[单例模式-饿汉式]</span></span><br><span class="line">    <span class="comment">//1. 将构造器私有化</span></span><br><span class="line">    <span class="comment">//2. 在类的内部直接创建对象(该对象是static)</span></span><br><span class="line">    <span class="comment">//3. 提供一个公共的static方法，返回 gf对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">GirlFriend</span>(<span class="title class_">String</span> name) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;構造器被調用.&quot;</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="title class_">GirlFriend</span> <span class="title function_">getInstance</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> gf;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;GirlFriend&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示懶漢式的單例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleTon02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="comment">//new Cat(&quot;大黃&quot;);</span></span><br><span class="line">        <span class="comment">//System.out.println(Cat.n1);</span></span><br><span class="line">        <span class="title class_">Cat</span> instance = <span class="title class_">Cat</span>.<span class="title function_">getInstance</span>();</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(instance);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再次調用getInstance</span></span><br><span class="line">        <span class="title class_">Cat</span> instance2 = <span class="title class_">Cat</span>.<span class="title function_">getInstance</span>();</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(instance2);</span><br><span class="line"></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(instance == instance2);<span class="comment">//T</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//希望在程序運行過程中，只能創建一個Cat對象</span></span><br><span class="line"><span class="comment">//使用單例模式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">String</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  int n1 = <span class="number">999</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="title class_">Cat</span> cat ; <span class="comment">//默認是null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//步驟</span></span><br><span class="line">    <span class="comment">//1.仍然構造器私有化</span></span><br><span class="line">    <span class="comment">//2.定義一個static靜態屬性對象</span></span><br><span class="line">    <span class="comment">//3.提供一個public的static方法，可以返回一個Cat對象</span></span><br><span class="line">    <span class="comment">//4.懶漢式，只有當用戶使用getInstance時，才返回cat對象, 後面再次調用時，會返回上次創建的cat對象</span></span><br><span class="line">    <span class="comment">//  從而保證了單例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">Cat</span>(<span class="title class_">String</span> name) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;構造器調用...&quot;</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="title class_">Cat</span> <span class="title function_">getInstance</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cat == <span class="literal">null</span>) &#123;<span class="comment">//如果還沒有創建cat對象</span></span><br><span class="line">            cat = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;小可愛&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Cat&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="饿汉式-VS-懒汉式"><a href="#饿汉式-VS-懒汉式" class="headerlink" title="饿汉式 VS 懒汉式"></a>饿汉式 VS 懒汉式</h2><ol><li>二者最主要的区别在于创建对象的时机不同：饿汉式是在类加载就创建了对象实例，而懒汉式是在使用时才创建</li><li>饿汊式不存在线程安全问题，懒汉式存在线程安全问题</li><li>饿汉式存在浪费资源的可能。因为如果程序员一个对象实例都没有使用，那么饿汉式创建的对象就浪费了，懒汉式是使用时才创建，就不存在这个问题</li><li>在我们 javaSE 标准类中， java.Iang.Runtime 就是经典的单例模式</li></ol><h1 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h1><h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h2><p>Final 可以修饰类，属性，方法和局部变量</p><ol><li>当不希望类被继承时可以使用 final 修饰</li><li>当不希望父类的某个方法被子类重写时，可以使用 final 修饰</li><li>当不希望类的某个属性的值被修改，可以使用 final 修饰</li><li>当不希望某个局部变量被修改，可以使用 final 修饰</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Final01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">E</span>();</span><br><span class="line">        <span class="comment">//e.TAX_RATE = 0.09;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果我们要求A类不能被其他类继承</span></span><br><span class="line"><span class="comment">//可以使用final修饰 A类</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class B extends A &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="comment">//如果我们要求hi不能被子类重写</span></span><br><span class="line">    <span class="comment">//可以使用final修饰 hi方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public void hi() &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;重写了C类的hi方法..&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当不希望类的的某个属性的值被修改,可以用final修饰</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">TAX_RATE</span> <span class="operator">=</span> <span class="number">0.08</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当不希望某个局部变量被修改，可以使用final修饰</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">F</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//这时，NUM 也称为 局部常量</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">double</span> <span class="variable">NUM</span> <span class="operator">=</span> <span class="number">0.01</span>;</span><br><span class="line">        <span class="comment">//NUM = 0.9;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;NUM=&quot;</span> + NUM);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="final-使用细节"><a href="#final-使用细节" class="headerlink" title="final 使用细节"></a>final 使用细节</h2><ol><li>final 修饰的属性有叫常量，一般用 XXX_XX 命名</li><li>final 修饰的属性在定义时，必须赋初始值，并于以后不能进行修改，赋值可以在以下位置之一<ol><li>定义时 比如：public final double TAX_RATE &#x3D; 0.08；</li><li>在构造器中</li><li>在代码块中</li></ol></li><li><strong>如果 final 修饰的属性是静态的，则初始化的位置只能是定义时，或在静态代码块 不能在构造器中赋值</strong></li><li>final 类不能被继承，但是可以实例化对象</li><li>如果类本身 final 类，但是含有 final 方法，则该方法虽然不能重写，但是可以被继承（一般如果一个类已经是 final 类了，就没有必要在将方法修饰成 final 方法）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalDetail01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CC</span> <span class="variable">cc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CC</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">EE</span>().cal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 定义时：如 public final double TAX_RATE=0.08;</span></span><br><span class="line"><span class="comment">    2. 在构造器中</span></span><br><span class="line"><span class="comment">    3. 在代码块中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">TAX_RATE</span> <span class="operator">=</span> <span class="number">0.08</span>;<span class="comment">//1.定义时赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">double</span> TAX_RATE2 ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">double</span> TAX_RATE3 ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AA</span><span class="params">()</span> &#123;<span class="comment">//构造器中赋值</span></span><br><span class="line">        TAX_RATE2 = <span class="number">1.1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;<span class="comment">//在代码块赋值</span></span><br><span class="line">        TAX_RATE3 = <span class="number">8.8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果final修饰的属性是静态的，则初始化的位置只能是</span></span><br><span class="line"><span class="comment">    1 定义时  2 在静态代码块 不能在构造器中赋值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">TAX_RATE</span> <span class="operator">=</span> <span class="number">99.9</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> TAX_RATE2 ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        TAX_RATE2 = <span class="number">3.3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//final类不能继承，但是可以实例化对象</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CC</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承</span></span><br><span class="line"><span class="comment">//即，仍然遵守继承的机制.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DD</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">cal</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cal()方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EE</span> <span class="keyword">extends</span> <span class="title class_">DD</span> &#123; &#125;</span><br></pre></td></tr></table></figure><ol><li>final 不能修饰构造方法</li><li>final 和 static 往往搭配使用，效率更高，不会导致类加载，底层编译器做了优化处理</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalDetail02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(BBB.num);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//包装类,String 是final类，不能被继承</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//final 和 static 往往搭配使用，效率更高，不会导致类加载.底层编译器做了优化处理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BBB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span>  <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BBB 静态代码块被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">AAA</span>&#123;</span><br><span class="line">    <span class="comment">//一般来说，如果一个类已经是final类了，就没有必要再将方法修饰成final方法</span></span><br><span class="line">    <span class="comment">//public final void cry() &#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><h2 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h2><p>父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了（因为子类对象会调用自己重写的方法）。换句话说，父类可能知道子类应该有哪个功能，但是功能具体怎么实现父类是不清楚的（由子类自己决定），父类只需要提供一个没有方法体的定义即可，具体实现交给子类自己去实现。<strong>我们把没有方法体的方法称为抽象方法。Java 语法规定，包含抽象方法的类就是抽象类</strong></p><ul><li><strong>抽象方法</strong> ： 没有方法体的方法</li><li><strong>抽象类</strong>：包含抽象方法的类</li></ul><h2 id="抽象类介绍"><a href="#抽象类介绍" class="headerlink" title="抽象类介绍"></a>抽象类介绍</h2><ol><li>用 abstract 关键字来修饰一个类时，这个类就叫抽象类</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">访问权限修饰符  <span class="keyword">abstract</span>  class  类名&#123; <span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><ol><li>用 abstract 关键字修饰一个方法时，这个方法就是抽象方法</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">访问权限修饰符  <span class="keyword">abstract</span>  返回值类型  方法名(形参列表);</span><br></pre></td></tr></table></figure><ol><li>抽象类的价值更多作用是在于设计，是设计着设计好后，让子类继承并实现抽象类（）</li></ol><h2 id="抽象类的使用细节"><a href="#抽象类的使用细节" class="headerlink" title="抽象类的使用细节"></a>抽象类的使用细节</h2><ol><li>抽象类不能被实例化</li><li>抽象类不一定要包含 abstract 方法，也就是说抽象类可以没有 abstract 方法</li><li>一旦类包含了 abstract 方法，则这个类必须声明为 abstract</li><li>abstract 只能修饰类和方法，不能修饰属性和其他的</li></ol><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractDetail01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="comment">//抽象类，不能被实例化</span></span><br><span class="line">        <span class="comment">//new A();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象类不一定要包含abstract方法。也就是说,抽象类可以没有abstract方法</span></span><br><span class="line"><span class="comment">//，还可以有实现的方法。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">hi</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一旦类包含了abstract方法,则这个类必须声明为abstract</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">void</span> <span class="title function_">hi</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//abstract 只能修饰类和方法，不能修饰属性和其它的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">   <span class="comment">// public abstract int n1 = 1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>抽象类可以有任意成员（抽象类本质还是类）</li><li>抽象方法不能有方法体{}</li><li>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为 abstract 类</li><li>抽象方法不能使用 private，final 和 static 来修饰，因为这些关键字都是和重写相违背的</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractDetail02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象方法不能使用private、final 和 static来修饰，因为这些关键字都是和重写相违背的</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">H</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>   <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">F</span> <span class="keyword">extends</span> <span class="title class_">E</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">G</span> <span class="keyword">extends</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123; <span class="comment">//这里相等于G子类实现了父类E的抽象方法，所谓实现方法，就是有方法体</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象类的本质还是类，所以可以有类的各种成员</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">D</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;韩顺平教育&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">ok</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>编写一 个 Employee 类，声明为抽象类，包含如下三个属性： name， id， salaryo 提供必要的构造器和抽象方法： work（） 。对于 Manager 类来说，他既是员工，还具有奖金（ bonus ）的属性。请使用继承的思想，设计 CommonEmpIoyee 类和 Manager 类，要求类中提供必要的方法进行属性访问，实现 work（） ，提示”经嘢普通员工名字工作中····’’ 00P 的继承+抽象类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name, <span class="type">int</span> id, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将work做成一个抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonEmployee</span> <span class="keyword">extends</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CommonEmployee</span><span class="params">(String name, <span class="type">int</span> id, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, id, salary);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通员工 &quot;</span> + getName() + <span class="string">&quot; 工作中...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> bonus;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">(String name, <span class="type">int</span> id, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, id, salary);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBonus</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bonus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBonus</span><span class="params">(<span class="type">double</span> bonus)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bonus = bonus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;经理 &quot;</span> + getName() + <span class="string">&quot; 工作中...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractExercise01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        <span class="type">Manager</span> <span class="variable">jack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>(<span class="string">&quot;jack&quot;</span>, <span class="number">999</span>, <span class="number">50000</span>);</span><br><span class="line">        jack.setBonus(<span class="number">8000</span>);</span><br><span class="line">        jack.work();</span><br><span class="line"></span><br><span class="line">        <span class="type">CommonEmployee</span> <span class="variable">tom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommonEmployee</span>(<span class="string">&quot;tom&quot;</span>, <span class="number">888</span>, <span class="number">20000</span>);</span><br><span class="line">        tom.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h2><p>接口（Interface） 是一种抽象类型，用于定义对象的行为规范。接口包含一组抽象方法（从Java 8开始可以包含默认方法和静态方法），但不提供具体实现。类通过实现接口来遵守这些行为规范</p><h2 id="接口的基本语法"><a href="#接口的基本语法" class="headerlink" title="接口的基本语法"></a>接口的基本语法</h2><ol><li><strong>使用</strong>**<code>interface</code>**<strong>关键字定义接口：</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>; <span class="comment">// 抽象方法，默认是 public 和 abstract</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>类通过</strong>**<code>implements</code>**<strong>关键字实现接口，并提供接口中所有抽象方法的具体实现</strong></li></ol><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">fly</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;Bird is flying.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="title class_">Flyable</span> bird = <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">        bird.<span class="title function_">fly</span>(); <span class="comment">// 输出: Bird is flying.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口的特点"><a href="#接口的特点" class="headerlink" title="接口的特点"></a>接口的特点</h2><ol><li><strong>只包含抽象方法（Java 8之前）：</strong><ol><li>接口中定义的方法默认是<code>public</code>和<code>abstract</code>，不需要显式声明</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>; <span class="comment">// 等价于 public abstract void fly();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>不能包含实例变量：</strong><ol><li>接口中只能包含常量（<code>public static final</code>修饰的变量）</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">MAX_HEIGHT</span> <span class="operator">=</span> <span class="number">1000</span>; <span class="comment">// 等价于 public static final int MAX_HEIGHT = 1000;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>支持多继承：</strong><ol><li>类可以实现多个接口，从而实现多重继承的效果</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Swimmable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Duck</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span>, Swimmable &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Duck is flying.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Duck is swimming.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><strong>从Java 8开始支持默认方法和静态方法：</strong></p><ol><li><p>默认方法：提供了方法的默认实现，子类可以选择重写</p></li><li><pre><code class="Java">public interface Flyable &#123;    default void land() &#123;        System.out.println(&quot;Landing...&quot;);    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. 静态方法：可以直接通过接口名调用</span><br><span class="line"></span><br><span class="line">4. ```Java</span><br><span class="line">   public interface Flyable &#123;</span><br><span class="line">       static void takeOff() &#123;</span><br><span class="line">           System.out.println(&quot;Taking off...&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ol></li><li><p><strong>从Java 9开始支持私有方法：</strong></p><ol><li><p>私有方法用于封装默认方法或静态方法中的公共逻辑。</p></li><li><p>java</p></li><li><p>深色版本</p></li><li><pre><code class="Java">public interface Flyable &#123;    default void land() &#123;        commonLogic();        System.out.println(&quot;Landing...&quot;);    &#125;    private void commonLogic() &#123;        System.out.println(&quot;Common logic for landing.&quot;);    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 接口与抽象类的区别</span><br><span class="line"></span><br><span class="line">| 特性     | 接口                                  | 抽象类                       |</span><br><span class="line">| :------- | :------------------------------------ | :--------------------------- |</span><br><span class="line">| 关键字   | `interface`                           | `abstract class`             |</span><br><span class="line">| 方法实现 | 只能包含抽象方法、默认方法和静态方法  | 可以包含抽象方法和非抽象方法 |</span><br><span class="line">| 成员变量 | 只能包含常量（`public static final`） | 可以包含普通成员变量         |</span><br><span class="line">| 继承方式 | 支持多实现                            | 只支持单继承                 |</span><br><span class="line">| 构造方法 | 不能有构造方法                        | 可以有构造方法               |</span><br><span class="line">| 使用场景 | 定义行为规范                          | 提供通用功能和部分实现       |</span><br><span class="line"></span><br><span class="line">## 接口的使用场景</span><br><span class="line"></span><br><span class="line">1. **定义行为规范：**</span><br><span class="line">   1. 当需要定义一组行为规范时，接口是非常合适的选择</span><br><span class="line"></span><br><span class="line">```Java</span><br><span class="line">public interface Drawable &#123;</span><br><span class="line">    void draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ol></li><li><p>解耦代码：</p><ol><li>接口可以将实现细节与业务逻辑分离，提高代码的灵活性和可维护性</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PaymentGateway</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">processPayment</span><span class="params">(<span class="type">double</span> amount)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayPalGateway</span> <span class="keyword">implements</span> <span class="title class_">PaymentGateway</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processPayment</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Processing payment via PayPal: $&quot;</span> + amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>支持多态：</strong><ol><li>接口可以通过多态的方式调用不同实现类的方法</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">PaymentGateway</span> <span class="variable">gateway</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PayPalGateway</span>();</span><br><span class="line">gateway.processPayment(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><ol><li>框架设计：<ol><li>在Spring、Hibernate等框架中，接口被广泛用于定义服务层、DAO层等</li></ol></li></ol><h2 id="接口的实际应用"><a href="#接口的实际应用" class="headerlink" title="接口的实际应用"></a>接口的实际应用</h2><p>以下是一个完整的示例，展示如何使用接口实现多态和代码解耦：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Car started.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Car stopped.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bike</span> <span class="keyword">implements</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bike started.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bike stopped.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">bike</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bike</span>();</span><br><span class="line"></span><br><span class="line">        car.start(); <span class="comment">// 输出: Car started.</span></span><br><span class="line">        car.stop();  <span class="comment">// 输出: Car stopped.</span></span><br><span class="line"></span><br><span class="line">        bike.start(); <span class="comment">// 输出: Bike started.</span></span><br><span class="line">        bike.stop();  <span class="comment">// 输出: Bike stopped.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li><strong>接口中的方法默认是<code>public</code>：</strong><ol><li>如果在接口中定义方法时没有指定访问修饰符，默认就是<code>public</code></li></ol></li><li>接口不能直接实例化：<ol><li>接口本身不能通过<code>new</code>关键字创建对象，只能通过实现类实例化</li></ol></li><li><strong>接口冲突问题：</strong><ol><li>如果一个类实现了多个接口，而这些接口中有相同签名的默认方法，则必须重写该方法以解决冲突</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello from A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello from B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">implements</span> <span class="title class_">A</span>, B &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        A.<span class="built_in">super</span>.sayHello(); <span class="comment">// 调用A接口的默认方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h2 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h2><p>Java内部类（Inner Class） 是一种定义在一个外部类（Outer Class）内部的类，<strong>内部类最大的特点就是可以直接访问私有属性，并且可以体现出类与类之间的包含关系</strong></p><p>内部类是类的第五大成员，其他四个分别是属性，方法，构造器，代码块</p><p>暂时无法在飞书文档外展示此内容</p><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>成员内部类是最常见的内部类形式，它作为外部类的一个非静态成员存在</p><p><strong>特点：</strong></p><ul><li>可以访问外部类的所有成员（包括私有成员）</li><li>每个成员内部类的对象都隐式持有一个对外部类对象的引用</li><li>可以用<code>private</code>、<code>protected</code>、<code>public</code>等修饰符修饰</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">outerField</span> <span class="operator">=</span> <span class="string">&quot;Outer Field&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Accessing outer field: &quot;</span> + outerField);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建外部类对象</span></span><br><span class="line">        <span class="type">OuterClass</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">        <span class="comment">// 创建内部类对象</span></span><br><span class="line">        OuterClass.<span class="type">InnerClass</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">        inner.display(); <span class="comment">// 输出：Accessing outer field: Outer Field</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>静态内部类是一个用<code>static</code>修饰的内部类，它是外部类的一个静态成员</p><p><strong>特点：</strong></p><ul><li>静态内部类可以直接访问外部类的所有静态成员，包含私有成员。但不能访问非静态成员</li><li>静态内部类本身可以添加任意访问修饰符，因为它本身属于外部类的一个成员，地位同成员变量，成员方法等相当</li><li>作用域——在整个外部类中均可以使用</li><li></li><li>可以用<code>private</code>、<code>protected</code>、<code>public</code>等修饰符修饰</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">staticField</span> <span class="operator">=</span> <span class="string">&quot;Static Field&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态嵌套类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticNestedClass</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Accessing static field: &quot;</span> + staticField);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 直接创建静态嵌套类对象</span></span><br><span class="line">        OuterClass.<span class="type">StaticNestedClass</span> <span class="variable">nested</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>.StaticNestedClass();</span><br><span class="line">        nested.display(); <span class="comment">// 输出：Accessing static field: Static Field</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>局部内部类是在方法或代码块中定义的类，作用域仅限于该方法或代码块，局部内部类的本质仍然是一个类</p><p><strong>特点：</strong></p><ol><li>局部内部类可以直接访问外部类的所有成员，包含私有成员</li><li>不能使用访问修饰符（如<code>public、private</code>）</li><li>可以访问所在方法的<code>final</code>变量（从Java 8开始，也可以访问“实际上不可变”的局部变量）</li><li>外部其他类不能访问局部内部类</li><li>如果想在局部内部类中访问其外部类的重名成员，则可以使用**”外部类名.this.成员”** 的形式去访问</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;fruit&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">juice</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;美汁汁儿~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Grape</span> &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;grape&quot;</span>;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">relationship</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; belongs to &quot;</span> + Fruit.<span class="built_in">this</span>.name);</span><br><span class="line">                juice();    <span class="comment">//invoke directly</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Grape</span>().relationship();</span><br><span class="line">       <span class="comment">/* class SunshineRose extends Grape &#123;</span></span><br><span class="line"><span class="comment">            //Grape类被final关键字修饰，因此不能被继承。</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fruit</span>();</span><br><span class="line">        fruit.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名内部类-重要"><a href="#匿名内部类-重要" class="headerlink" title="匿名内部类(重要)"></a>匿名内部类(重要)</h2><p>匿名内部类是一种没有显式定义名称的内部类。它通常用于简化代码，尤其是在需要实现接口或继承类时。匿名内部类的主要特点是一次性使用，适合快速创建一个类的实例</p><p><strong>特点：</strong></p><ol><li>没有名字：匿名内部类没有显式的类名</li><li>只能使用一次：匿名内部类通常用于创建一个类的单个实例</li><li>必须继承父类或实现接口：匿名内部类要么继承一个父类，要么实现一个接口</li><li>不能有构造器：因为没有名字，所以无法定义构造器，但可以通过实例初始化块完成一些初始化操作</li><li>作用域有限：匿名内部类的作用域仅限于定义它的位置</li><li>匿名内部类可以直接访问外部类的所有成员，包含私有成员</li><li>外部其他类不能访问匿名内部类</li><li>如果想在匿名内部类中访问其外部类的重名成员，则可以使用”外部类名.this.成员” 的形式去访问</li><li>匿名内部类从里面看，它的本质也是一个类，我们可以在类体中定义它自己的成员；但是从外面看，匿名内部类的本质是一个对象，因为底层在创建匿名内部类后直接new出了一个对象，因此实际上你可以直接把它当作一个对象来使用</li></ol><h3 id="匿名内部类的语法"><a href="#匿名内部类的语法" class="headerlink" title="匿名内部类的语法"></a>匿名内部类的语法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类/接口() &#123;</span><br><span class="line">    <span class="comment">// 类体（可以覆盖方法、添加新方法等）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="匿名内部类的使用"><a href="#匿名内部类的使用" class="headerlink" title="匿名内部类的使用"></a>匿名内部类的使用</h3><h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>匿名内部类常用于实现接口。例如，假设有一个接口<code>Greeting</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> knowledge.oop.inner.anonymous;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Usb</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke_usb</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Usb</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Usb</span>() &#123;    This an anonymous class.</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Phone connected the USB interface successfully.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;  <span class="comment">//Don&#x27;s forget the last semicolon.</span></span><br><span class="line"> </span><br><span class="line">        phone.connect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        solution.invoke_usb();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，对于phone引用来讲，它的编译类型是Usb型，也就是Usb接口，而它的<strong>运行类型是****匿名内部类</strong>。该匿名内部类此时的默认类名是“外部类类名 + $1”</p><p><strong>.class文件：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution$1</span> <span class="keyword">implements</span> <span class="title class_">Usb</span> &#123;   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Phone connected the USB interface successfully.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承类"><a href="#继承类" class="headerlink" title="继承类"></a>继承类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Some generic sound&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用匿名内部类继承Animal类</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Bark!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        dog.makeSound(); <span class="comment">// 输出：Bark!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带参数的匿名内部类"><a href="#带参数的匿名内部类" class="headerlink" title="带参数的匿名内部类"></a>带参数的匿名内部类</h3><p>如果父类或接口的构造器需要参数，可以在创建匿名内部类时传递参数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">introduce</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;My name is &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用匿名内部类继承Person类并传递参数</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">introduce</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hi, I&#x27;m &quot;</span> + name + <span class="string">&quot; (from anonymous class)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        person.introduce(); <span class="comment">// 输出：Hi, I&#x27;m Alice (from anonymous class)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问外部变量"><a href="#访问外部变量" class="headerlink" title="访问外部变量"></a>访问外部变量</h3><p>匿名内部类可以访问外部方法中的局部变量，但这些变量必须是<code>final</code> 或者是实际上不可变的（从Java 8开始）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;The number is: &quot;</span> + number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        task.run(); <span class="comment">// 输出：The number is: 42</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><h2 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h2><p>枚举（Enum） 是一种特殊的类，用于定义一组固定的常量。枚举类型非常适合表示一组固定的值，例如星期几、颜色、状态等</p><h2 id="枚举使用"><a href="#枚举使用" class="headerlink" title="枚举使用"></a>枚举使用</h2><ol><li>将构造器私有化，使其不能被随随便便地new出对象</li><li>取消类中提供的setXxx方法，仅保留getXxx方法</li><li>在定义类时，使用enum关键字替换掉class关键字。enum关键字用于声明枚举类</li><li><strong>常量名（<strong><strong>形参</strong></strong>列表）</strong></li><li>如果有多个常量对象，使用逗号’,’间隔即可</li><li>如果使用enum来实现枚举，语法规定常量必须写在类的最前面，否则报错</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Week</span> &#123;</span><br><span class="line">    <span class="comment">//定义Week的枚举对象</span></span><br><span class="line">    MONDAY(<span class="string">&quot;星期一&quot;</span>), TUESDAY(<span class="string">&quot;星期二&quot;</span>), WEDNESDAY(<span class="string">&quot;星期三&quot;</span>), THURSDAY(<span class="string">&quot;星期四&quot;</span>),</span><br><span class="line">    FRIDAY(<span class="string">&quot;星期五&quot;</span>), SATURDAY(<span class="string">&quot;星期六&quot;</span>), SUNDAY(<span class="string">&quot;星期日&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Week</span><span class="params">(String name)</span> &#123;<span class="comment">//构造器</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumExercise02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取到所有的枚举对象， 即数组</span></span><br><span class="line">        Week[] weeks = Week.values();</span><br><span class="line">        <span class="comment">//遍历，使用增强for</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===所有星期的信息如下===&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Week week : weeks) &#123;</span><br><span class="line">            System.out.println(week);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">===所有星期的信息如下===</span><br><span class="line">星期一</span><br><span class="line">星期二</span><br><span class="line">星期三</span><br><span class="line">星期四</span><br><span class="line">星期五</span><br><span class="line">星期六</span><br><span class="line">星期日</span><br></pre></td></tr></table></figure><h2 id="枚举类常用方法"><a href="#枚举类常用方法" class="headerlink" title="枚举类常用方法"></a><strong>枚举类常用方法</strong></h2><p>使用了enum关键字来声明枚举类，则声明的枚举类默认继承了Enum类，并且底层默认是一个final类</p><table><thead><tr><th align="left">方法名</th><th align="left"></th></tr></thead><tbody><tr><td align="left"><code>values()</code></td><td align="left">返回枚举的所有实例数组</td></tr><tr><td align="left"><code>valueOf(String)</code></td><td align="left">根据名称返回对应的枚举实例</td></tr><tr><td align="left"><code>name()</code></td><td align="left">返回枚举常量的名称</td></tr><tr><td align="left"><code>ordinal()</code></td><td align="left">返回枚举常量的序号（从0开始）</td></tr><tr><td align="left"><code>toString()</code></td><td align="left">返回枚举常量的字符串表示，默认为名称</td></tr><tr><td align="left"><code>equals(Object)</code></td><td align="left">比较两个枚举是否相等</td></tr><tr><td align="left"><code>compareTo(E)</code></td><td align="left">比较两个枚举的顺序（基于<code>ordinal</code>）</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//使用Season2 枚举类，来演示各种方法</span></span><br><span class="line">        <span class="type">Season2</span> <span class="variable">autumn</span> <span class="operator">=</span> Season2.AUTUMN;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出枚举对象的名字</span></span><br><span class="line">        System.out.println(autumn.name());</span><br><span class="line">        <span class="comment">//ordinal() 输出的是该枚举对象的次序/编号，从0开始编号</span></span><br><span class="line">        <span class="comment">//AUTUMN 枚举对象是第三个，因此输出 2</span></span><br><span class="line">        System.out.println(autumn.ordinal());</span><br><span class="line">        <span class="comment">//从反编译可以看出 values方法，返回 Season2[]</span></span><br><span class="line">        <span class="comment">//含有定义的所有枚举对象</span></span><br><span class="line">        Season2[] values = Season2.values();</span><br><span class="line">        System.out.println(<span class="string">&quot;===遍历取出枚举对象(增强for)====&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Season2 season : values) &#123;<span class="comment">//增强for循环</span></span><br><span class="line">            System.out.println(season);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//valueOf：将字符串转换成枚举对象，要求字符串必须为已有的常量名，否则报异常</span></span><br><span class="line">        <span class="comment">//执行流程</span></span><br><span class="line">        <span class="comment">//1. 根据你输入的 &quot;AUTUMN&quot; 到 Season2的枚举对象去查找</span></span><br><span class="line">        <span class="comment">//2. 如果找到了，就返回，如果没有找到，就报错</span></span><br><span class="line">        <span class="type">Season2</span> <span class="variable">autumn1</span> <span class="operator">=</span> Season2.valueOf(<span class="string">&quot;AUTUMN&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;autumn1=&quot;</span> + autumn1);</span><br><span class="line">        System.out.println(autumn == autumn1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//compareTo：比较两个枚举常量，比较的就是编号</span></span><br><span class="line">        <span class="comment">//老韩解读</span></span><br><span class="line">        <span class="comment">//1. 就是把 Season2.AUTUMN 枚举对象的编号 和 Season2.SUMMER枚举对象的编号比较</span></span><br><span class="line">        <span class="comment">//2. 看看结果</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        public final int compareTo(E o) &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            return self.ordinal - other.ordinal;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        Season2.AUTUMN的编号[2] - Season2.SUMMER的编号[3]</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(Season2.AUTUMN.compareTo(Season2.SUMMER));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season2</span> &#123;<span class="comment">//类</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;温暖&quot;</span>), WINTER(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;寒冷&quot;</span>), AUTUMN(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;凉爽&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;炎热&quot;</span>)<span class="comment">/*, What()*/</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc;<span class="comment">//描述</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season2</span><span class="params">()</span> &#123;<span class="comment">//无参构造器</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season2</span><span class="params">(String name, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, desc=&#x27;&quot;</span> + desc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">AUTUMN</span><br><span class="line"><span class="number">2</span></span><br><span class="line">===遍历取出枚举对象(增强<span class="keyword">for</span>)====</span><br><span class="line">Season&#123;name=<span class="string">&#x27;春天&#x27;</span>, desc=<span class="string">&#x27;温暖&#x27;</span>&#125;</span><br><span class="line">Season&#123;name=<span class="string">&#x27;冬天&#x27;</span>, desc=<span class="string">&#x27;寒冷&#x27;</span>&#125;</span><br><span class="line">Season&#123;name=<span class="string">&#x27;秋天&#x27;</span>, desc=<span class="string">&#x27;凉爽&#x27;</span>&#125;</span><br><span class="line">Season&#123;name=<span class="string">&#x27;夏天&#x27;</span>, desc=<span class="string">&#x27;炎热&#x27;</span>&#125;</span><br><span class="line">autumn1=Season&#123;name=<span class="string">&#x27;秋天&#x27;</span>, desc=<span class="string">&#x27;凉爽&#x27;</span>&#125;</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="枚举实现接口"><a href="#枚举实现接口" class="headerlink" title="枚举实现接口"></a>枚举实现接口</h2><ol><li>使用enum关键字声明枚举类之后，该枚举类不可以再去继承其他类。这是因为，我们之前通过javap命令反编译枚举类后，可以看到枚举类在底层隐式继承了Enum类。而Java是单继承机制，不支持多继承。所以在枚举类后使用extends关键字，IDEA会报错</li><li>num关键字声明的枚举类虽然不能再去继承其他类了，但是可以实现接口</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Action</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">perform</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Command</span> <span class="keyword">implements</span> <span class="title class_">Action</span> &#123;</span><br><span class="line">    START &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">perform</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Starting...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    STOP &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">perform</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Stopping...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">perform</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Command.START.perform(); <span class="comment">// 输出: Starting...</span></span><br><span class="line">        Command.STOP.perform();  <span class="comment">// 输出: Stopping...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举与switch语句"><a href="#枚举与switch语句" class="headerlink" title="枚举与switch语句"></a>枚举与<code>switch</code>语句</h2><p>枚举可以直接用于<code>switch</code>语句中，简化代码逻辑</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    ADD, SUBTRACT, MULTIPLY, DIVIDE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Operation</span> <span class="variable">operation</span> <span class="operator">=</span> Operation.ADD;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (operation) &#123;</span><br><span class="line">            <span class="keyword">case</span> ADD:</span><br><span class="line">                System.out.println(<span class="string">&quot;Performing addition.&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SUBTRACT:</span><br><span class="line">                System.out.println(<span class="string">&quot;Performing subtraction.&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MULTIPLY:</span><br><span class="line">                System.out.println(<span class="string">&quot;Performing multiplication.&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DIVIDE:</span><br><span class="line">                System.out.println(<span class="string">&quot;Performing division.&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Unknown operation.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举的注意事项"><a href="#枚举的注意事项" class="headerlink" title="枚举的注意事项"></a>枚举的注意事项</h2><ol><li>枚举不能被继承：<ol><li>枚举类型隐式地继承了<code>java.lang.Enum</code>，因此不能再显式继承其他类。</li></ol></li><li>枚举不能被实例化：<ol><li>枚举的实例由Java编译器自动生成，无法通过<code>new</code>关键字创建。</li></ol></li><li>枚举值是常量：<ol><li>枚举值一旦定义后不可更改。</li></ol></li><li>枚举的性能开销较小：<ol><li>枚举的实例数量是固定的，因此内存占用较小</li></ol></li></ol><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h2><p>Java注解是一种元数据类型，它为代码提供额外的信息，但不会直接影响程序的逻辑，注解可以被编译器，开发工具或运行时环境使用，可用于修饰或者解释包、类、方法、属性、构造器，局部变量等数据信息</p><h2 id="常见的内置注解"><a href="#常见的内置注解" class="headerlink" title="常见的内置注解"></a>常见的内置注解</h2><p>使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成一个修饰符使用。用于修饰它支持的程序元素</p><ol><li><strong><code>@Override</code>：</strong><ol><li>表示一个方法重写了父类的方法。</li><li>如果方法签名不匹配，编译器会报错</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Overridden method&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong><code>@Deprecated</code>：</strong><ol><li>标记某个方法或类已过时，不推荐使用</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">oldMethod</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong><code>@SuppressWarnings</code>：</strong><ol><li>抑制编译器警告</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">oldMethod</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong><code>@FunctionalInterface</code>（从Java 8开始）</strong><ol><li>标记一个接口是函数式接口（只有一个抽象方法）</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyFunctionalInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>元注解用于描述其他注解的行为和范围</p><ol><li><strong><code>@Retention</code>：</strong><ol><li>指定注解的保留策略</li><li>常见的值：<ul><li><code>RetentionPolicy.SOURCE</code>：注解仅保留在源码中，编译后丢弃</li><li><code>RetentionPolicy.CLASS</code>：注解保留在<code>.class</code>文件中，但运行时不可用。</li><li><code>RetentionPolicy.RUNTIME</code>：注解保留在运行时，可通过反射访问</li></ul></li></ol></li><li><strong><code>@Target</code>：</strong><ol><li>指定注解可以使用的范围。</li><li>常见的值：<ul><li><code>ElementType.TYPE</code>：类、接口或枚举</li><li><code>ElementType.FIELD</code>：字段</li><li><code>ElementType.METHOD</code>：方法</li><li><code>ElementType.PARAMETER</code>：方法参数</li><li><code>ElementType.CONSTRUCTOR</code>：构造方法</li></ul></li></ol></li><li><strong><code>@Documented</code>：</strong><ol><li>表示注解应包含在Javadoc中</li></ol></li><li><strong><code>@Inherited</code>：</strong><ol><li>表示注解可以被子类继承</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象基础一</title>
      <link href="/2025/06/09/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E4%B8%80/"/>
      <url>/2025/06/09/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><h2 id="类和对象的理解"><a href="#类和对象的理解" class="headerlink" title="类和对象的理解"></a><strong>类和对象的理解</strong></h2><p><strong>类：</strong></p><ol><li>类是对现实生活中一类具有共同属性和行为的事务的抽象</li><li>类是对象的数据类型，类是具有相同属性和行为的一组对象的集合</li><li>类就是对现实事物的一种描述</li><li>类的组成<ol><li>属性：指事物的特征，例如：手机事物（品牌，价格，尺寸）</li><li>行为：指事物能执行的操作，例如：手机事物（打电话，发短信）</li></ol></li></ol><p><strong>类和对象的关系：</strong></p><ol><li>类：类是对现实生活中一类具有共同属性和行为的事物的抽象</li><li>对象：是能够看得到摸的着的真实存在的实体</li><li>简单理解：<strong>类是对事物的一种描述，对象则为具体存在的事物</strong></li></ol><h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><p>类的组成是由属性和行为两部分组成</p><ul><li>属性：在类中通过成员变量来体现（类中方法外的变量）</li><li>行为：在类中通过成员方法来体现（和前面的方法相比去掉static关键字即可）</li></ul><p>类的定义步骤：</p><p>①定义类</p><p>②编写类的成员变量</p><p>③编写类的成员方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 &#123;</span><br><span class="line">        <span class="comment">// 成员变量</span></span><br><span class="line">        变量<span class="number">1</span>的数据类型 变量<span class="number">1</span>；</span><br><span class="line">        变量<span class="number">2</span>的数据类型 变量<span class="number">2</span>;</span><br><span class="line">        …</span><br><span class="line">        <span class="comment">// 成员方法</span></span><br><span class="line">        方法<span class="number">1</span>;</span><br><span class="line">        方法<span class="number">2</span>;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    String brand;</span><br><span class="line">    <span class="type">int</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成员方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>创建对象的格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类名 对象名 = <span class="keyword">new</span> 类名();</span><br></pre></td></tr></table></figure><ol><li>new是Java中用于创建对象的关键字</li><li>“对象名”即是一个指向堆空间中真正对象的引用变量</li><li>“类名()” 即真正的对象，在堆空间中</li><li>创建某一个类的对象，也称为“实例化该类”，在实例化类之前，会先将要实例化的类的字节码文件加载到方法区（仅1次）</li></ol><p>调用成员的格式：</p><ul><li>对象名.成员变量</li><li>对象名.成员方法();</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建对象</span></span><br><span class="line"><span class="comment">        格式：类名 对象名 = new 类名();</span></span><br><span class="line"><span class="comment">        范例：Phone p = new Phone();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    使用对象</span></span><br><span class="line"><span class="comment">        1：使用成员变量</span></span><br><span class="line"><span class="comment">            格式：对象名.变量名</span></span><br><span class="line"><span class="comment">            范例：p.brand</span></span><br><span class="line"><span class="comment">        2：使用成员方法</span></span><br><span class="line"><span class="comment">            格式：对象名.方法名()</span></span><br><span class="line"><span class="comment">            范例：p.call()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhoneDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">Phone</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用成员变量</span></span><br><span class="line">        System.out.println(p.brand);</span><br><span class="line">        System.out.println(p.price);</span><br><span class="line"></span><br><span class="line">        p.brand = <span class="string">&quot;小米&quot;</span>;</span><br><span class="line">        p.price = <span class="number">2999</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(p.brand);</span><br><span class="line">        System.out.println(p.price);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用成员方法</span></span><br><span class="line">        p.call();</span><br><span class="line">        p.sendMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-创建对象内存图"><a href="#Java-创建对象内存图" class="headerlink" title="Java 创建对象内存图"></a>Java 创建对象内存图</h2><p><strong>Java内存分配的三大主要空间分别是 : ①栈空间，②堆空间，③方法区</strong></p><p><img src="https://ncnp0tw8a19k.feishu.cn/space/api/box/stream/download/asynccode/?code=MTc0NzQ5NjJhMWQxY2I5NThkZTFmYjJlNDk2NGFhNjlfTTVpanlSc3RLbE5iVEgxZ1BTTG1QM09UWFpHdTZJeWNfVG9rZW46UnYxY2JXYmF5b004OVd4N3hjZmNMeWJ6bjFjXzE3NDk0MDU4MzU6MTc0OTQwOTQzNV9WNA" alt="img"></p><ul><li>new关键字会<strong>在堆内存开辟空间给新的Phone类对象</strong></li><li>将phone类对象的堆内存地址赋给变量P</li><li>Phone类的成员方法部分其实是成员方法在方法区中的地址值，将来如果对象调用成员方法，可以通过这个地址值找到方法区中的成员方法</li></ul><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="方法概述"><a href="#方法概述" class="headerlink" title="方法概述"></a>方法概述</h2><p>方法（method）是程序中最小的执行单元</p><p><strong>注意：</strong></p><ul><li>方法必须先创建才可以使用，该过程成为方法定义</li><li>方法创建后并不是直接可以运行的，需要手动使用后，才执行，该过程成为方法调用</li></ul><h2 id="无参数方法定义和调用"><a href="#无参数方法定义和调用" class="headerlink" title="无参数方法定义和调用"></a><strong>无参数方法定义和调用</strong></h2><p><strong>定义：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">void</span> 方法名 (   ) &#123;</span><br><span class="line">        <span class="comment">// 方法体;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法名();</span><br></pre></td></tr></table></figure><p><strong>案例：</strong></p><ul><li>需求：设计一个方法用于打印两个数中的较大数 </li><li>思路：<ul><li>①定义一个方法，用于打印两个数字中的较大数，例如 getMax（） </li><li>②方法中定义两个变量，用于保存两个数字 </li><li>③使用分支语句分两种情况对两个数字的大小关系进行处理 </li><li>④在 main（）方法中调用定义好的方法</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//在main()方法中调用定义好的方法</span></span><br><span class="line">        getMax();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法，用于打印两个数字中的较大数，例如getMax()</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">getMax</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//方法中定义两个变量，用于保存两个数字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用分支语句分两种情况对两个数字的大小关系进行处理</span></span><br><span class="line">        <span class="keyword">if</span>(a &gt; b) &#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="带参数方法定义和调用"><a href="#带参数方法定义和调用" class="headerlink" title="带参数方法定义和调用"></a><strong>带参数方法定义和调用</strong></h2><p><strong>定义：</strong></p><p>参数：由数据类型和变量名组成 -  数据类型 变量名</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">void</span> 方法名 (参数<span class="number">1</span>) &#123;</span><br><span class="line">        方法体;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> 方法名 (参数<span class="number">1</span>, 参数<span class="number">2</span>, 参数<span class="number">3.</span>..) &#123;</span><br><span class="line">        方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>方法定义时，参数中的数据类型与变量名都不能缺少，缺少任意一个程序将报错</li><li>方法定义时，多个参数之间使用逗号（ ，）分隔</li></ol><p><strong>调用：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法名(参数)；</span><br><span class="line"></span><br><span class="line">方法名(参数<span class="number">1</span>,参数<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>方法调用时，参数的数量与类型必须与方法定义中的设置相匹配，否则程序将报错 </p><ol><li><strong>形参和实参</strong><ol><li>形参：方法定义中的参数       </li><li>实参：方法调用中的参数</li></ol></li></ol><p><strong>案例：</strong></p><ul><li>需求：设计一个方法用于打印两个数中的较大数，数据来自于方法参数 }</li><li>思路：<ul><li>①定义一个方法，用于打印两个数字中的较大数，例如 getMax（） </li><li>②为方法定义两个参数，用于接收两个数字 </li><li>③使用分支语句分两种情况对两个数字的大小关系进行处理 </li><li>④在 main（）方法中调用定义好的方法（使用常量）</li><li>⑤在 main（）方法中调用定义好的方法（使用变量）</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//在main()方法中调用定义好的方法（使用常量）</span></span><br><span class="line">        getMax(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">        <span class="comment">//调用方法的时候，人家要几个，你就给几个，人家要什么类型的，你就给什么类型的</span></span><br><span class="line">        <span class="comment">//getMax(30);</span></span><br><span class="line">        <span class="comment">//getMax(10.0,20.0);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//在main()方法中调用定义好的方法（使用变量）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        getMax(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法，用于打印两个数字中的较大数，例如getMax()</span></span><br><span class="line">    <span class="comment">//为方法定义两个参数，用于接收两个数字</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="comment">//使用分支语句分两种情况对两个数字的大小关系进行处理</span></span><br><span class="line">        <span class="keyword">if</span>(a &gt; b) &#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="带返回值方法的定义和调用"><a href="#带返回值方法的定义和调用" class="headerlink" title="带返回值方法的定义和调用"></a>带返回值方法的定义和调用</h2><p><strong>定义：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  返回数据类型 方法名 ( 参数 ) &#123; </span><br><span class="line">        <span class="keyword">return</span> 数据 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>方法定义时 return 后面的返回值与方法定义上的数据类型要匹配，否则程序将报错</li></ul><p><strong>调用：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法名 ( 参数 ) ;</span><br><span class="line">数据类型 变量名 = 方法名 ( 参数 ) ;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>方法的返回值通常会使用变量接收，否则该返回值将无意义</li></ul><p><strong>案例：</strong></p><ul><li>需求：设计一个方法可以获取两个数的较大值，数据来自于参数</li><li>思路：<ul><li>①定义一个方法，用于获取两个数字中的较大数 </li><li>②使用分支语句分两种情况对两个数字的大小关系进行处理 </li><li>③根据题设分别设置两种情况下对应的返回结果 </li><li>④在 main（）方法中调用定义好的方法并使用变量保存 </li><li>⑤在 main（）方法中调用定义好的方法并直接打印结果</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//在main()方法中调用定义好的方法并使用变量保存</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> getMax(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在main()方法中调用定义好的方法并直接打印结果</span></span><br><span class="line">        System.out.println(getMax(<span class="number">10</span>,<span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法，用于获取两个数字中的较大数</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="comment">//使用分支语句分两种情况对两个数字的大小关系进行处理</span></span><br><span class="line">        <span class="comment">//根据题设分别设置两种情况下对应的返回结果</span></span><br><span class="line">        <span class="keyword">if</span>(a &gt; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法调用机制（内存）"><a href="#方法调用机制（内存）" class="headerlink" title="方法调用机制（内存）"></a>方法调用机制（内存）</h2><p><img src="https://ncnp0tw8a19k.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTVkMTBmYjVjNjUxMDNlMzI5MDdhYmUxYTM3MDNmMTlfQVl6VkV3ZUpzMERVdE9PM2tiZmtXdU5jQzhWV3dxWDVfVG9rZW46S3lNWWJuTldjb3BQM2J4RVNPUWNCRTBPbmxmXzE3NDk0MDU4MzU6MTc0OTQwOTQzNV9WNA" alt="img"></p><ol><li>当程序执行到方法时，就会开辟一个独立的空间（栈空间）</li><li>当方法执行完毕或者执行到 return 语句时就会返回</li><li>返回到调用方法的地方（方法栈也会被销毁）</li><li>返回后，继续执行方法后面的代码</li><li>当 main 方法（栈）执行完毕，整个程序退出</li></ol><blockquote><p><strong>栈中调用成员方法时，会根据创建的对象的地址，找到堆中成员方法的地址，继而找到方法区中的成员方法，接着，成员方法进栈</strong>   </p><p><strong>栈中调用字符串常量等常量时，会根据创建的对象的地址，找到堆中成员变量的地址，继而找到方法区里面常量池中常量的地址</strong></p></blockquote><h2 id="方法的注意事项"><a href="#方法的注意事项" class="headerlink" title="方法的注意事项"></a>方法的注意事项</h2><ol><li><strong>访问修饰符 （作用是控制 方法使用的范围）</strong><ol><li>如果不写默认访问，[有四种： public， protected， 默认， private]</li></ol></li><li><strong>返回数据类型</strong><ol><li>一个方法最多有一个返回值 [返回多个结果可以返回数组 ]</li><li>返回类型可以为任意类型，包含基本类型或引用类型（数组，对象）</li><li>如果方法要求有返回数据类型，则方法体中最后的执行语句必须为 return 值； 而且要求返回值类型必须和 return 的值类型一致或兼容</li><li>如果方法是 void，则方法体中可以没有 return 语句，或者 只写 return ；</li></ol></li><li><strong>方法名</strong><ol><li>遵循驼峰命名法，最好见名知义，表达出该功能的意思即可</li></ol></li><li><strong>形参列表</strong><ol><li>参数类型可以为任意类型，包含基本数据类型和引用类型</li><li>调用带参数的方法时，一定对应着参数列表传入相同类型或兼容类型的参数</li></ol></li></ol><h2 id="方法的传参机制"><a href="#方法的传参机制" class="headerlink" title="方法的传参机制"></a>方法的传参机制</h2><ol><li><strong>基本数据类型的传参机制</strong><ol><li>基本数据类型，传递的是值（值拷贝），形参的任何变化不影响实参</li></ol></li><li><strong>引用数据类型的传参机制</strong><ol><li>引用类型传递的是地址（传递也是值，但是值是地址），可以通过形参影响实参！</li></ol></li></ol><h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a><strong>方法重载</strong></h2><p>方法重载是指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载</p><ol><li>多个方法在同一个类中</li><li>多个方法具有相同的方法名</li><li>多个方法的参数不相同，类型不同或者数量不同</li></ol><p><strong>注意：</strong></p><ul><li>重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式</li><li>重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，换句话说不能通过返回值来判定两个方法是否相互构成重载</li></ul><p><strong>范例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">fn</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">            <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>  <span class="type">int</span> <span class="title function_">fn</span><span class="params">(<span class="type">double</span> a)</span> &#123;</span><br><span class="line">            <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="type">float</span> <span class="title function_">fn</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">            <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fn</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b)</span> &#123;</span><br><span class="line">            <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例：</strong></p><ul><li>需求：使用方法重载的思想，设计比较两个整数是否相同的方法，兼容全整数类型（byte，short，int，long） </li><li>思路：<ul><li>①定义比较两个数字的是否相同的方法 compare（）方法，参数选择两个 int 型参数</li><li>②定义对应的重载方法，变更对应的参数类型，参数变更为两个 long 型参数</li><li>③定义所有的重载方法，两个 byte 类型与两个 short 类型参数 </li><li>④完成方法的调用，测试运行结果</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        System.out.println(compare(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">        System.out.println(compare((<span class="type">byte</span>) <span class="number">10</span>, (<span class="type">byte</span>) <span class="number">20</span>));</span><br><span class="line">        System.out.println(compare((<span class="type">short</span>) <span class="number">10</span>, (<span class="type">short</span>) <span class="number">20</span>));</span><br><span class="line">        System.out.println(compare(<span class="number">10L</span>, <span class="number">20L</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;int&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a == b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//byte</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">byte</span> a, <span class="type">byte</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;byte&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a == b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//short</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">short</span> a, <span class="type">short</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;short&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a == b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//long</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;long&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a == b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java 中，可以将名称相同，功能也相同，但是形参个数不同的多个函数，封装为某个类中的一个函数，比如：要求多个数的和，此时并不能确定一共要求多少个数的和，如果形参的个数每变化一次，就要有一个新的函数，那编程的效率就会大打折扣</p><p><strong>可以通过可变参数的方式</strong>来解决这个简单的问题</p><p><strong>格式：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">访问权限修饰符   返回值类型  函数名（数据类型... 形参名）&#123;</span><br><span class="line">                <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    注意这里的<span class="string">&quot;数据类型... 形参名&quot;</span>格式，里面的三个点的格式是固定的</span><br><span class="line">    不可随便添加空格</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>可变参数的实参可以为 0 个或任意多个</li><li>可变参数的实参可以为数组</li><li>可变参数的本质就是数组</li><li>可变参数可以和普通的参数一起放在形参列表，但必须保证可变参数在最后</li><li>一个形参列表中只能出现一个可变参数</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> csdn.varparameter;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VariableParameter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test1</span>();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//    可变参数的实参可以为0个或任意多个</span></span><br><span class="line">        <span class="type">int</span>[] array1 = &#123;<span class="number">2</span>, <span class="number">11</span>, <span class="number">211</span>, <span class="number">985</span>, <span class="number">141</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] array2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>&#125;;</span><br><span class="line"> </span><br><span class="line">        System.out.println(t1.getSum(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">        System.out.println(t1.getSum(<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line"><span class="comment">//  可变参数的实参可以为数组</span></span><br><span class="line">        System.out.println(t1.getSum(array1));</span><br><span class="line">        System.out.println(t1.getSum(array2));</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span>... parameters)</span> &#123;</span><br><span class="line"><span class="comment">//   可变参数的本质就是数组</span></span><br><span class="line">        System.out.println(<span class="string">&quot;可变参数中含有&quot;</span> + parameters.length + <span class="string">&quot;个参数&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameters.length; ++i) &#123;</span><br><span class="line">            num += parameters[i];</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.print(<span class="string">&quot;传入参数的总和是 : &quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可变参数可以和普通的参数一起放在形参列表，但必须保证可变参数在最后</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span>... parameters)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;可变参数中含有&quot;</span> + parameters.length + <span class="string">&quot;个参数&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            值得注意的是，此处输出的仅仅是可变参数中的个数，并不是所有形参的个数</span></span><br><span class="line"><span class="comment">            形参的个数 &gt;= 实际可变参数的长度</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; ++i) &#123;</span><br><span class="line">            sum1 += arr[i];</span><br><span class="line">        &#125;   <span class="comment">//用变量sum1来保存直接传入的数组arr中所有整型元素的和</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameters.length; ++i) &#123;</span><br><span class="line">            sum2 += parameters[i];</span><br><span class="line">        &#125;   <span class="comment">//用变量sum2来保存可变参数的实际传入参数的值的总和</span></span><br><span class="line"> </span><br><span class="line">        System.out.print(<span class="string">&quot;传入参数的总的和为 : &quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> sum1 + sum2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p> 在 Java 中，主要的变量就是属性（成员变量）和局部变量</p><p><strong>成员变量：类中，方法外</strong></p><p><strong>局部变量：方法的参数列表或方法体语句</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    String name; <span class="comment">//成员变量</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;nb&quot;</span>;    <span class="comment">//局部变量</span></span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><ol><li>有默认的初始值（与数组相同），定义时可以不赋值，正常调用</li><li>作用域为整个类</li><li>存在于堆内存中</li><li>可以加修饰符</li><li>生命周期较长——随着对象的创建而存在，随着对象的消失而消失</li></ol><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><ol><li>无默认的初始化值，定义时可以不赋初值，但必须先赋值再使用</li><li>作用域为定义它的代码块或者方法体中</li><li>存在于栈内存中</li><li>不可以加修饰符</li><li>生命周期较短——随着方法的调用而存在，随着方法的调用完毕而消失</li><li>成员变量和局部变量可以重名，但在<strong>同一作用域中，两个变量不能重名</strong></li><li>当出现成员变量和局部变量重名的情况时，遵循<strong>就近原则</strong></li></ol><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>构造方法是类的一种特殊的方法，他的主要作用是完成对新对象的初始化（Java 是通过 new 关键字创建对象的）</p><h2 id="定义格式"><a href="#定义格式" class="headerlink" title="定义格式"></a>定义格式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">访问权限修饰符  构造方法名（参数列表）&#123; </span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ol><li>参数列表为空，称为空参构造（也叫无参构造），否则称之为带参构造</li><li>构造方法名必须与类名相同</li><li>构造方法没有返回值</li><li>构造方法没有返回值类型</li></ol><h2 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>当类中没有定义任何构造方法时，该类会默认隐含一个无参构造器</li><li>当类中已经定义了构造方法，默认的构造器就会被覆盖，就不能使用无参构造器，除非显式的定义一个</li><li>构造器可以重载，同一个类中可以定义多个构造器</li><li>构造器是在执行 new 关键字的时候，由系统来完成的，即在创建对象时，系统会自动匹配并调用该类的某个构造器完成对对象的初始化</li></ol><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">char</span> gender;</span><br><span class="line">    String work;</span><br><span class="line">    <span class="type">double</span> salary;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String work, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.work = work;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name, <span class="type">char</span> gender, String work)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">        <span class="built_in">this</span>.work = work;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name, <span class="type">char</span> gender, String work, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">        <span class="built_in">this</span>.work = work;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ol><li>Java 虚拟机会给创建的每个对象分配 this，代表当前对象</li><li>每一个创建的对象都有一个 this 属性，指向该对象本身，所以 this 可以代表当前对象</li><li>this 不能在类定义的外部使用，只能在类定义的方法中使用</li></ol><p><strong>用法：</strong></p><ol><li>this.属性名         （ this。属性名就是当前对象的属性）</li><li>this.方法名（参数）；   （可调用当前对象的方法）</li><li>this（参数列表） 可以访问本类的构造器<ol><li>该途径只能在构造器中使用，且使用时必须置于构造器的首句</li></ol></li></ol><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><ol><li><strong>引用当前对象的成员变量</strong> 当方法中的局部变量与类的成员变量同名时，可以使用 <code>this</code> 来区分它们</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name; <span class="comment">// 使用 this 区分成员变量和参数</span></span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Name: &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;Age: &quot;</span> + <span class="built_in">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>调用当前类的其他构造器（构造器重载）</strong></li></ol><p>在一个类的多个构造器之间，可以使用 <code>this</code> 调用另一个构造器，以避免代码重复</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;Unknown&quot;</span>, <span class="number">0</span>); <span class="comment">// 调用带参数的构造器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参数的构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Name: &quot;</span> + name);</span><br><span class="line">        System.out.println(<span class="string">&quot;Age: &quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意： 在构造器中使用 <code>this</code> 调用其他构造器时，必须将 <code>this(...)</code> 放在第一行</p><ol><li><strong>返回当前对象</strong></li></ol><p>可以通过 <code>this</code> 返回当前对象本身，通常用于支持链式调用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>; <span class="comment">// 返回当前对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>; <span class="comment">// 返回当前对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Name: &quot;</span> + name);</span><br><span class="line">        System.out.println(<span class="string">&quot;Age: &quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.setName(<span class="string">&quot;Alice&quot;</span>).setAge(<span class="number">25</span>).display(); <span class="comment">// 链式调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>传递当前对象作为参数</strong></li></ol><p><code>this</code> 可以用来将当前对象作为参数传递给其他方法</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">startEngine</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;Engine started&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">drive</span>(<span class="params"><span class="title class_">Car</span> car</span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;Driving the car&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">operate</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">startEngine</span>(); <span class="comment">// 调用当前对象的方法</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">drive</span>(<span class="variable language_">this</span>);   <span class="comment">// 将当前对象作为参数传递</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="title class_">Car</span> car = <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">        car.<span class="title function_">operate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="this深入理解"><a href="#this深入理解" class="headerlink" title="this深入理解"></a>this深入理解</h2><p><img src="https://ncnp0tw8a19k.feishu.cn/space/api/box/stream/download/asynccode/?code=YWQ4YmMwODFjMWM3MGNhNDE5MTRhNTRkY2I2NDA1ZDBfaThaNTlmZENmakNHY3lCdzR0WXZ6WjcxTFlEWjE5R1JfVG9rZW46RkZBUWJQYVlybzRWWWR4MDBta2NuUXRWblZLXzE3NDk0MDU4MzU6MTc0OTQwOTQzNV9WNA" alt="img"></p><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>包在操作系统中其实就是一个文件夹，<strong>包是用来分门别类的管理技术，不同的技术类放在不同的包下</strong>，方便管理和维护</p><h2 id="包的作用"><a href="#包的作用" class="headerlink" title="包的作用"></a>包的作用</h2><ol><li><strong>代码组织</strong>：包帮助开发者将功能相关的类和接口组织在一起，使得代码更加模块化</li><li><strong>避免命名冲突</strong>：包为类和函数提供了命名空间，这样即使在不同的包中有同名的类，它们也不会冲突</li><li><strong>访问控制</strong>：包可以限制类成员的可见性。使用访问修饰符（如public, protected和private），开发者可以控制哪些其他包的代码可以访问当前包中的类成员</li></ol><h2 id="创建和使用包"><a href="#创建和使用包" class="headerlink" title="创建和使用包"></a>创建和使用包</h2><p><strong>包名的命名规范</strong>：</p><ol><li>包名一般是公司域名的倒写。例如：黑马是<a href="http://www.itheima.com/">www.itheima.com</a>,包名就可以定义成com.itheima.技术名称</li><li>包名必须用”.“连接</li><li>包名的每个路径名必须是一个合法的标识符，而且不能是Java的关键字</li></ol><p><strong>导包：</strong></p><ul><li><p>什么时候需要导包？</p><ul><li>情况一：在使用Java中提供的非核心包中的类时</li><li>情况二：使用自己写的其他包中的类时</li></ul></li><li><p>什么时候不需要导包？</p><ul><li>情况一：在使用Java核心包（java.lang）中的类时</li><li>情况二：在使用自己写的同一个包中的类时</li></ul></li><li><p>使用不同包下的相同类怎么办？</p><ul><li><p>假设demo1和demo2中都有一个Student该如何使用？</p></li><li><pre><code class="java">//使用全类名的形式即可。//全类名：包名 + 类名//拷贝全类名的快捷键：选中类名crtl + shift + alt + c 或者用鼠标点copy，再点击copy Referencecom.itheima.homework.demo1.Student s1 = new com.itheima.homework.demo1.Student();com.itheima.homework.demo2.Student s2 = new com.itheima.homework.demo2.Student();<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**引用包：**</span><br><span class="line"></span><br><span class="line">使用：import 包名</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">import java.util.Scanner;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h2 id="常用的包"><a href="#常用的包" class="headerlink" title="常用的包"></a>常用的包</h2><p>一个包下,包含很多的类,java 中常用的包有:</p><ol><li>java.lang.*    &#x2F;&#x2F;lang 包是基本包，默认引入，不需要再引入. </li><li>java.util.*    &#x2F;&#x2F;util 包，系统提供的工具包, 工具类，使用 Scanner</li><li>java.net.*    &#x2F;&#x2F;网络包，网络开发</li><li>java.awt.*    &#x2F;&#x2F;是做 java 的界面开发，GUI</li></ol><h1 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>java 提供四种访问控制修饰符号，用于控制方法和属性(成员变量)的访问权限（范围）:</p><ol><li><p><strong>公开级别</strong>：用 public 修饰,对外公开</p></li><li><p><strong>受保护级别</strong>:用 protected 修饰,对子类和同一个包中的类公开</p></li><li><p><strong>默认级别</strong>:没有修饰符号,向同一个包的类公开.</p></li><li><p><strong>私有级别</strong>:用 private 修饰,只有类本身可以访问,不对外公开.</p><ol><li><table><thead><tr><th align="left"></th><th align="left">public</th><th align="left">protected</th><th align="left">默认</th><th align="left">private</th></tr></thead><tbody><tr><td align="left">同类</td><td align="left">√</td><td align="left">√</td><td align="left">√</td><td align="left">√</td></tr><tr><td align="left">同包</td><td align="left">√</td><td align="left">√</td><td align="left">√</td><td align="left"></td></tr><tr><td align="left">子类</td><td align="left">√</td><td align="left">√</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">不同包</td><td align="left">√</td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table></li></ol></li></ol><h2 id="注意事项修饰符可以用来修饰类中的属性，成员方法以及类"><a href="#注意事项修饰符可以用来修饰类中的属性，成员方法以及类" class="headerlink" title="注意事项修饰符可以用来修饰类中的属性，成员方法以及类"></a>注意事项修饰符可以用来修饰类中的属性，成员方法以及类</h2><ol><li>只有默认的和public才能修饰类，并且遵循访问权限的特点</li><li>成员方法的访问规则和属性完全一样</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.modifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">//四个属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n4</span> <span class="operator">=</span> <span class="number">400</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//该方法可以访问 四个属性</span></span><br><span class="line">        System.out.println(<span class="string">&quot;n1=&quot;</span> + n1 + <span class="string">&quot; n2=&quot;</span> + n2 + <span class="string">&quot; n3=&quot;</span> + n3 + <span class="string">&quot; n4=&quot;</span> + n4);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//在同一类中，可以访问 public protected 默认 private 修饰属性和方法</span></span><br><span class="line">        m1();</span><br><span class="line">        m2();</span><br><span class="line">        m3();</span><br><span class="line">        m4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> com.study.modifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span> ();</span><br><span class="line">        a.m1();</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        b.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> com.study.modifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="comment">//在同一个包下，可以访问 public , protected 和 默认修饰属性或方法,不能访问 private 属性或方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;n1=&quot;</span> + a.n1 + <span class="string">&quot; n2=&quot;</span> + a.n2 + <span class="string">&quot; n3=&quot;</span> + a.n3);</span><br><span class="line">        a.m1();</span><br><span class="line">        a.m2();</span><br><span class="line">        a.m3();</span><br><span class="line">        <span class="comment">//a.m4(); 错误的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议：</strong></p><p>编写代码时，如果没有特殊的考虑，建议这样使用权限：</p><ul><li>成员变量使用<code>private</code> ，隐藏细节</li><li>构造方法使用<code>public</code> ，方便创建对象</li><li>成员方法使用<code>public</code> ，方便调用方法</li></ul><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h2><ol><li><strong>封装的概念:</strong></li></ol><p>封装就是将一系列相关事物的共同的属性和行为提取出来，放到一个类中，同时隐藏对象的属性和实现细节，仅对外提供公共的访问方式</p><ol><li><strong>封装的关键：</strong><ol><li>封装使数据被保护在内部</li><li>绝对不可以让类中的方法直接访问其他类的数据（属性)，程序仅通过对象的方法与对象的数据进行间接交互</li><li>装可以使得我们对传入的数据进行校验和限制，加强了业务逻辑</li></ol></li></ol><h2 id="封装的实现"><a href="#封装的实现" class="headerlink" title="封装的实现"></a>封装的实现</h2><ol><li><p>将属性进行私有化private</p></li><li><p>提供一个公共的[public]set方法，用于对属性判断并赋值</p><ol><li><pre><code class="Java">public void setXxx(类型 参数名) &#123;    //加入数据验证的业务逻辑    属性=参数名；&#125;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. 提供一个公共的[public]get方法，用于获取属性的值</span><br><span class="line"></span><br><span class="line">   1. ```Java</span><br><span class="line">      public 数据类型 getXxx() &#123;</span><br><span class="line">          return xxx;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ol></li></ol><p><strong>案例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;信息为 name=&quot;</span> + name + <span class="string">&quot; age=&quot;</span> + age + <span class="string">&quot; 薪水=&quot;</span> + salary);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="封装的好处"><a href="#封装的好处" class="headerlink" title="封装的好处"></a>封装的好处</h2><ol><li><h3 id="数据保护与安全性"><a href="#数据保护与安全性" class="headerlink" title="数据保护与安全性"></a><strong>数据保护与安全性</strong></h3></li></ol><ul><li><strong>直接暴露数据的风险</strong>：如果类的字段（成员变量）被直接暴露（<code>public</code>），外部代码可以随意修改其值，可能导致数据不一致或非法状态。例如：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age; <span class="comment">// 直接暴露&#125;// 外部可以随意赋值：</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//别的类中直接赋值</span></span><br><span class="line">person.age = -<span class="number">100</span>; <span class="comment">// 明显不合理</span></span><br></pre></td></tr></table></figure><ul><li><strong>封装后的控制</strong>：通过私有字段（<code>private</code>）和公共方法（<code>getter/setter</code>），可以在方法中添加逻辑校验，确保数据合法性：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (age &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><h3 id="隐藏实现细节"><a href="#隐藏实现细节" class="headerlink" title="隐藏实现细节"></a>隐藏实现细节</h3></li></ol><ul><li><strong>内部实现的灵活性</strong>：封装允许类的内部实现细节（如数据结构、算法）对外部透明。例如：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankAccount</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance; <span class="comment">// 当前使用 double 存储金额</span></span><br><span class="line">    <span class="comment">// 未来可以改为 int，而外部无需感知变化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> balance; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>降低耦合性</strong>：外部代码依赖的是类的接口（方法），而非具体实现，这使得修改内部逻辑时不会影响调用方</li></ul><ol><li><h3 id="代码可维护性"><a href="#代码可维护性" class="headerlink" title="代码可维护性"></a><strong>代码可维护性</strong></h3></li></ol><ul><li><strong>集中控制</strong>：通过方法操作数据，可以在一个地方统一管理数据的行为（如日志、缓存、校验等）</li><li><strong>减少代码冗余</strong>：若多个地方直接操作字段，未来修改逻辑时需要逐个修改；而通过方法封装，只需修改方法内部即可</li></ul><ol><li><h3 id="避免滥用封装的情况"><a href="#避免滥用封装的情况" class="headerlink" title="避免滥用封装的情况"></a><strong>避免滥用封装的情况</strong></h3></li></ol><p>封装的意义在于合理控制访问，而非“机械地为所有字段添加 <code>getter/setter</code>,以下情况可能被误认为“多此一举”：</p><ul><li><strong>无意义的</strong> <code>getter/setter</code>：如果字段不需要校验或控制，直接暴露可能更简洁（但需权衡未来需求变化的风险）</li><li><strong>过度设计</strong>：例如为工具类的静态常量添加封装方法，反而增加复杂度</li></ul><h2 id="构造器和-setXxx-结合"><a href="#构造器和-setXxx-结合" class="headerlink" title="构造器和 setXxx 结合"></a>构造器和 setXxx 结合</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line"><span class="comment">// this.name = name;</span></span><br><span class="line"><span class="comment">// this.age = age;</span></span><br><span class="line"><span class="comment">// this.salary = salary;</span></span><br><span class="line"><span class="comment">//我们可以将 set 方法写在构造器中，这样仍然可以验证</span></span><br><span class="line">setName(name);</span><br><span class="line">setAge(age);</span><br><span class="line">setSalary(salary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="标准代码JavaBean"><a href="#标准代码JavaBean" class="headerlink" title="标准代码JavaBean"></a>标准代码JavaBean</h2><p>avaBean是一种特殊的Java类，是Java语言编写类的标准规范，也是最美的Java类</p><p><strong>Java语言编写类的标准规范 :</strong></p><ol><li>符合JavaBean标准的类，必须是具体，公共的</li><li>并且不但具有空参构造，通常也需要写出它的带参构造</li><li>成员变量全部用private关键字修饰，并且要提供用来操作这些成员变量的setter和getter方法</li></ol><p><strong>标准JavaBean类代码演示 :</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> knowledge.define.student;</span><br><span class="line"><span class="comment">//这就是一个标准的javaBean类</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student2</span> &#123;</span><br><span class="line">    <span class="comment">//无参构造：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student2</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="comment">//带参构造：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student2</span><span class="params">(String name, <span class="type">int</span> age, String sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//成员变量的setter和getter方法。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(String sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h2><p>Java继承是面向对象编程的核心特性之一，它允许一个类(子类）基于另外一个(父类)来构建，继承父类的属性和方法，并可以扩展或修改其行为，<strong>继承的核心目的是实现代码复用</strong>和<strong>建立类之间的层次关系</strong></p><p><img src="https://ncnp0tw8a19k.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTM4NjQ4NjY5ZDQ4OThiM2ZhM2RjOWExYjBkYmE1NDZfVzJXMThVUkxaSnV4SXVJckhEMkE5MGRzMW5xamZBZVJfVG9rZW46WTlWRGJZSlV5b3BNT2F4VXhqT2NvMGZZbjhjXzE3NDk0MDU4MzU6MTc0OTQwOTQzNV9WNA" alt="img"></p><h2 id="继承的基本语法"><a href="#继承的基本语法" class="headerlink" title="继承的基本语法"></a>继承的基本语法</h2><p>通过 <code>extends</code> 关键字实现继承：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ParentClass</span> &#123;</span><br><span class="line">    <span class="comment">// 父类的属性和方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChildClass</span> <span class="keyword">extends</span> <span class="title class_">ParentClass</span> &#123;</span><br><span class="line">    <span class="comment">// 子类可以继承父类的非私有属性和方法</span></span><br><span class="line">    <span class="comment">// 子类可以添加新属性和方法，或重写父类方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类：Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;  <span class="comment">// 私有属性（需通过 getter/setter 访问）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;正在吃东西&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类：Dog</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 继承 Animal 的属性和方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot;汪汪叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类：Cat</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 重写父类方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot;优雅地吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        dog.setName(<span class="string">&quot;小黑&quot;</span>);</span><br><span class="line">        dog.eat();   <span class="comment">// 调用父类方法（输出：小黑正在吃东西）</span></span><br><span class="line">        dog.bark();  <span class="comment">// 调用子类新增方法（输出：小黑汪汪叫）</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        cat.setName(<span class="string">&quot;小白&quot;</span>);</span><br><span class="line">        cat.eat();    <span class="comment">// 调用子类重写方法（输出：小白优雅地吃鱼）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承的使用细节"><a href="#继承的使用细节" class="headerlink" title="继承的使用细节"></a>继承的使用细节</h2><ol><li>Java中查找变量(或方法)的原则</li></ol><p>继承关系中成员变量的使用，和继承关系中成员方法的使用，其实是大同小异</p><p><strong>就近原则</strong></p><p><strong>查找顺序：</strong></p><p>局部变量(方法) -&gt; 成员变量(方法) -&gt;父类 -&gt; 更高的父类-&gt;…..-&gt;Object</p><p><strong>注意：</strong></p><ol><li><p>Object类是Java中所有类的顶层父类</p></li><li><p>如果本类没有该变量，父类中有该变量(方法)但是为父类私有时，IDEA会报错！因为私有属性无法在其他类直接访问</p></li><li><p>如果从局部位置开始一直找到Object类也没有找到该变量，IDEA会报错！</p></li><li><p>子类拥有了父类的所有非私有成员变量(成员变量，成员方法)，并可以直接访问它们</p></li><li><p>对于父类的私有成员(成员变量，成员方法)，子类只能通过父类提供的公有方法来间接访问父类的私有成员</p></li><li><p>同时，子类也可以有自己特有的属性(成员变量)和行为(成员方法)</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span> &#123; <span class="comment">//父类</span></span><br><span class="line">    <span class="comment">//4个属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n4</span> <span class="operator">=</span> <span class="number">400</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getN4</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n4;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//四个方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test100</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test100&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">test200</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test200&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test300</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test300&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test400</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test400&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callTest400</span><span class="params">()</span> &#123;</span><br><span class="line">        test400();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123; <span class="comment">//子类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayOk</span><span class="params">()</span> &#123;<span class="comment">//子类方法</span></span><br><span class="line">        <span class="comment">//非私有的属性和方法可以在子类直接访问</span></span><br><span class="line">        <span class="comment">//但是私有属性和方法不能在子类直接访问</span></span><br><span class="line">        System.out.println(n1 + <span class="string">&quot; &quot;</span> + n2 + <span class="string">&quot; &quot;</span> + n3);</span><br><span class="line">        test100();</span><br><span class="line">        test200();</span><br><span class="line">        test300();</span><br><span class="line">        <span class="comment">//test400();错误</span></span><br><span class="line">        <span class="comment">//要通过父类提供公共的方法去访问</span></span><br><span class="line">        System.out.println(<span class="string">&quot;n4=&quot;</span> + getN4());</span><br><span class="line">        callTest400();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">Son</span>(); <span class="comment">//创建了子类对象 sub</span></span><br><span class="line">         son.sayOk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">100</span> <span class="number">200</span> <span class="number">300</span></span><br><span class="line">test100</span><br><span class="line">test200</span><br><span class="line">test300</span><br><span class="line">n4=<span class="number">400</span></span><br><span class="line">test400</span><br></pre></td></tr></table></figure><ol><li>子类必须调用父类的构造器，完成父类的初始化</li><li>当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用super关键字去指定使用父类的哪个构造器完成对父类的初始化工作，否则编译不会通过</li><li>如果希望指定去调用父类的某个构造器，则显式的调用一下：super(参数列表)</li><li>super在使用时，必须放在构造器第一行(super只能在构造器中使用)</li><li>super() 和 this() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span> &#123; <span class="comment">//父类</span></span><br><span class="line">    <span class="comment">//4个属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n4</span> <span class="operator">=</span> <span class="number">400</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="title function_">Parent</span><span class="params">()</span> &#123; <span class="comment">//无参构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;父类Base()构造器被调用....&quot;</span>);</span><br><span class="line">        </span><br><span class="line">     &#125;</span><br><span class="line">        <span class="comment">//参数没有意义，只能举例</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="title function_">Parent</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;<span class="comment">//有参构造器</span></span><br><span class="line">        <span class="comment">//默认super()</span></span><br><span class="line">        System.out.println(<span class="string">&quot;父类Base(String name, int age)构造器被调用....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//参数没有意义，只能举例</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="title function_">Parent</span><span class="params">(String name)</span> &#123;<span class="comment">//有参构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;父类Base(String name)构造器被调用....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123; <span class="comment">//子类</span></span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span> &#123;<span class="comment">//无参构造器</span></span><br><span class="line">            <span class="built_in">super</span>(); <span class="comment">//默认调用父类的无参构造器</span></span><br><span class="line">            System.out.println(<span class="string">&quot;子类Sub()构造器被调用....&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">     <span class="comment">//当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器</span></span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">(String name)</span> &#123;<span class="comment">//参数没有意义，只能举例</span></span><br><span class="line">            <span class="built_in">super</span>(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">            <span class="comment">//do nothing...</span></span><br><span class="line">            System.out.println(<span class="string">&quot;子类Sub(String name)构造器被调用....&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">        </span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;<span class="comment">//参数没有意义，只能举例</span></span><br><span class="line">        <span class="comment">// 调用父类的 Base(String name, int age) 构造器</span></span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;king&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        <span class="comment">//细节： super在使用时，必须放在构造器第一行</span></span><br><span class="line">        <span class="comment">//细节: super() 和 this() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器</span></span><br><span class="line">        <span class="comment">//this() 不能再使用了</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类Sub(String name, int age)构造器被调用....&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===第1个对象====&quot;</span>);</span><br><span class="line">        <span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">Son</span>(); <span class="comment">//创建了子类对象 son</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===第2个对象====&quot;</span>);</span><br><span class="line">        <span class="type">Son</span> <span class="variable">son1</span> <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">Son</span>(<span class="string">&quot;jack&quot;</span>); <span class="comment">//创建了子类对象 son1</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===第3对象====&quot;</span>);</span><br><span class="line">        <span class="type">Son</span> <span class="variable">son2</span> <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">Son</span>(<span class="string">&quot;king&quot;</span>, <span class="number">10</span>); <span class="comment">//创建了子类对象 son2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">===第<span class="number">1</span>个对象====</span><br><span class="line">父类Base()构造器被调用....</span><br><span class="line">子类Sub()构造器被调用....</span><br><span class="line"></span><br><span class="line">===第<span class="number">2</span>个对象====</span><br><span class="line">父类Base(String name)构造器被调用....</span><br><span class="line">子类Sub(String name)构造器被调用....</span><br><span class="line"></span><br><span class="line">===第<span class="number">3</span>对象====</span><br><span class="line">父类Base(String name, <span class="type">int</span> age)构造器被调用....</span><br><span class="line">子类Sub(String name, <span class="type">int</span> age)构造器被调用....</span><br></pre></td></tr></table></figure><ol><li>子类最多只能继承一个父类(指直接继承)，即 java 中是单继承机制</li><li>不能滥用继承，子类和父类之间必须满足 is-a 的逻辑关系</li></ol><h2 id="继承的本质-JVM内存"><a href="#继承的本质-JVM内存" class="headerlink" title="继承的本质(JVM内存)"></a>继承的本质(JVM内存)</h2><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 父类：Parent类（JavaBean标准）</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//无参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Parent</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Parent</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//getter,setter方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Child:子类（派生类）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;    </span><br><span class="line">    <span class="comment">//Child类构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Child</span> <span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Child</span> <span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//Child类成员方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ears</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动耳神功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 子类的子类 : Hua类 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hua</span> <span class="keyword">extends</span> <span class="title class_">Child</span>&#123;</span><br><span class="line">    <span class="comment">//Hua类的构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hua</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hua</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//Hua类特有成员方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">skill</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;五行相生，分石化玉。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Hua</span> <span class="variable">fuHua</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hua</span>();      <span class="comment">//从这行代码开始执行。</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//利用setter，getter方法来修改和获取fuHua对象的属性</span></span><br><span class="line">        <span class="comment">// （本质上修改的就是Parent父类的成员变量）</span></span><br><span class="line">        fuHua.setName(<span class="string">&quot;Jason&quot;</span>);</span><br><span class="line">        fuHua.setAge(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;fuHua&#x27;s name = &quot;</span> + fuHua.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;fuHua&#x27;s age = &quot;</span> + fuHua.getAge());</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//调用Child类的成员方法</span></span><br><span class="line">        fuHua.ears();</span><br><span class="line">        <span class="comment">//调用Hua类特有的成员方法</span></span><br><span class="line">        fuHua.skill();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>内存分析</strong></p><ol><li>包含main方法的类优先加载到方法区</li><li>main方法加载进栈</li><li>开始执行main方法中的代码 :<ol><li>创建Hua类对象,从右向左执行。遇到了new关键字，new的是Hua类对象</li><li>将Hua类的字节码文件加载到方法区（假设Hua类成员方法在方法区中的地址值为0x0088）但是，加载前jvm发现：Hua类继承了Child类，而Child类又继承了Parent类，因此类的字节码文件的加载顺序为 ：先加载Parent类，再加载Child类，最后加载Hua类,(假设Child类成员方法在方法区中的地址值为0x0077，Parent类成员方法在方法区中的地址值为0x0066）</li></ol></li><li>new关键字会在堆中开辟空间给新的Hua类对象，设Hua类对象在堆内存中的地址值为0x0011</li><li><strong>继承中对象的初始化顺序 : 先初始化父类内容，再初始化子类内容</strong><ol><li>首先将fuHua对象的堆空间划分出一块来，用于存放Parent类的内容，并根据Parent类的字节码文件，将划分出的空间在分成三部分</li><li>其中的成员方法部分，实际保存的是成员方法在方法区中的地址值，将来如果通过对象调用成员方法，可以通过这个保存的地址值进一步找到方法区中的成员方法</li><li>对属性的初始化共分为三个步骤 : ①默认初始化，②显式初始化，③构造器初始化</li><li>在fuHua对象的堆空间内再划分出一片区域来，去存放Child类的内容</li><li>Hua类的父类的父类和Hua类的父类都已经初始化完成，下一步就是初始化子类——Hua类的内容了</li></ol></li><li>最后<strong>把对象的地址值返回给fuHua引用</strong></li><li>继续执行后面的代码</li></ol><p><img src="https://ncnp0tw8a19k.feishu.cn/space/api/box/stream/download/asynccode/?code=NDkzMDUyYmI3NGE4NDIxNDA3YzdhZjk0MjkxN2UyNmFfVkloTWNHRFBkNGRJNU1BTHhuc3JJRXNhRjJIbk5lOTVfVG9rZW46TFdlTmJxNG4wb0lxNzN4U0wwcGNDT0V4bnBkXzE3NDk0MDU4MzU6MTc0OTQwOTQzNV9WNA" alt="img"></p><p>当通过**”对象.”<strong>的形式来调用时，实际就是通过引用fuHua指向的堆内存中对象的地址，进一步找到对象的成员变量或成员方法。</strong>子类堆内存存放了父类的属性**</p><h1 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h1><h2 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h2><p>super是一种指向当前对象父类的“引用机制”，用于访问父类的属性，方法，构造器</p><p>当new关键字在创建子类对象时，子类对象的堆空间中会有一部分用于存放父类的内容，就是继承父类的非私有成员，super就是指向这个部分</p><p><img src="https://ncnp0tw8a19k.feishu.cn/space/api/box/stream/download/asynccode/?code=YmIxMmRhMTE0YWExYWJiOTNkMzUyYzU1NTIxYmRlNDVfaGpCMkRqV0c4ZkJBMXhpRUxldXJ2bDEzb2Jxd2txZ21fVG9rZW46QXdrMmJNSnBDb0dUcVF4WHZJOGNzdlYzbnVVXzE3NDk0MDU4MzU6MTc0OTQwOTQzNV9WNA" alt="img"></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="super和this比较"><a href="#super和this比较" class="headerlink" title="super和this比较"></a>super和this比较</h2><table><thead><tr><th align="left">特性</th><th align="left">this</th><th align="left">super</th></tr></thead><tbody><tr><td align="left">作用</td><td align="left">引用当前对象实例</td><td align="left">引用父类成员</td></tr><tr><td align="left">存储位置</td><td align="left">栈帧的局部变量表中（索引 0 ）</td><td align="left">无独立存储位置，是编译器的符号引用机制</td></tr><tr><td align="left">生命周期</td><td align="left">与方法调用栈帧一致</td><td align="left">无独立生命周期</td></tr><tr><td align="left">多态支持</td><td align="left">支持动态绑定（根据实际对象类型调用方法）</td><td align="left">不支持动态绑定（直接调用父类方法）</td></tr><tr><td align="left">构造函数调用</td><td align="left">可用于调用本类的其他构造函数（ this() ）</td><td align="left">必须用于调用父类构造函数（ super() ）</td></tr><tr><td align="left">成员访问</td><td align="left">访问本类的成员（变量、方法）</td><td align="left">访问父类的成员（变量、方法）</td></tr></tbody></table><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li><strong>访问父类属性</strong><ol><li>super.属性名 <strong>（仅能访问非私有属性）</strong></li></ol></li><li><strong>访问父类的方法</strong><ol><li>super.方法名(参数列表) <strong>（仅能访问非私有属性）</strong></li></ol></li><li><strong>访问父类的构造器</strong><ol><li>super(参数列表)  (<strong>只能放在构造器的第一句</strong>)</li></ol></li><li><strong>new关键字创建对象后，对象的初始化顺序</strong><ol><li><strong>先初始化父类内容，再初始化子类内容（原因是创建子类对象时，优先调用父类的构造器）</strong></li></ol></li></ol><h2 id="super-给编程带来的便利"><a href="#super-给编程带来的便利" class="headerlink" title="super 给编程带来的便利"></a><strong>super 给编程带来的便利</strong></h2><ol><li>调用父类的构造器的好处(分工明确，父类属性有父类初始化，子类的属性由子类初始化)</li><li>当子类中有和父类中的成员(属性和方法)重名时，为了访问父类的成员，必须通过super</li><li>super的访问不限于直接父类，可以是父类的父类</li></ol><h1 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h1><h2 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h2><p>如果子类中定义了一个<strong>返回类型，方法名，参数列表都与父类中某个方法相同</strong>的方法，只是方法体中的语句不同，这就称为：子类重写了父类的某个方法</p><h2 id="注意事项和使用细节"><a href="#注意事项和使用细节" class="headerlink" title="注意事项和使用细节"></a>注意事项和使用细节</h2><ol><li>想达到方法重写，必须满足返回值类型、方法名，参数列表都相同！即——外壳不变，内部重写。(实际子类返回值类型也可以是父类返回值类型的子类）</li><li>子类的重写方法<strong>可以用</strong><strong>@Override****注解来标注</strong></li><li>父类私有方法不能被重写</li><li>子类方法访问权限不能小于父类方法，即访问权限 : 子类 ≥ 父类</li><li>子类不能比父类抛出更大的异常</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;<span class="comment">//父类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物叫唤..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AAA <span class="title function_">m3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> com.study.override;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;<span class="comment">//子类</span></span><br><span class="line">    <span class="comment">//1. 因为Dog 是 Animal子类</span></span><br><span class="line">    <span class="comment">//2. Dog的 cry方法和 Animal的 cry定义形式一样(名称、返回类型、参数)</span></span><br><span class="line">    <span class="comment">//3. 这时我们就说 Dog的cry方法，重写了Animal的cry方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小狗汪汪叫..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//细节: 子类方法的返回类型和父类方法返回类型一样，</span></span><br><span class="line">    <span class="comment">//      或者是父类返回类型的子类比如 父类 返回类型是 Object ,</span></span><br><span class="line">    <span class="comment">//      子类方法返回类型是String</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//细节: 子类方法不能缩小父类方法的访问权限 【演示】</span></span><br><span class="line">    <span class="comment">//public &gt; protected &gt; 默认&gt;private</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法重写和方法重载的区别"><a href="#方法重写和方法重载的区别" class="headerlink" title="方法重写和方法重载的区别"></a>方法重写和方法重载的区别</h2><p><img src="https://ncnp0tw8a19k.feishu.cn/space/api/box/stream/download/asynccode/?code=MjgyMmFlZTNiMDY5ZWQ1NTk4YzQxNDU1ODBmMDExZDhfamVhMnBMUktDWlVhTGJqcUQwR1RaM1RidDNuVHdzbkhfVG9rZW46TWJ6YmJOdVoxb0VLRmJ4S1Fad2NOR2hXbjhnXzE3NDk0MDU4MzU6MTc0OTQwOTQzNV9WNA" alt="img"></p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h2><p>方法或对象具有多种形态，是面向对象的第三大特征，多态是建立在封装和继承基础之上</p><ol><li><strong>对于方法</strong>，多态表现在方法重载和方法重写上<ol><li>方法重载：同一行为，形参不同则表现不同</li><li>方法重写：同一行为，调用者不同则表现形式不同</li></ol></li><li><strong>对于对象</strong>，多态表现在同一对象在不同情况下表现出不同的状态或行为。对象不仅仅是体现多态，更重要的应用多态。因此，<strong>对象的多态就是Java多态的核心</strong></li></ol><h2 id="⭐多态的实现"><a href="#⭐多态的实现" class="headerlink" title="⭐多态的实现"></a>⭐多态的实现</h2><ol><li>有继承(或实现)关系，继承是多态的前提</li><li>有方法重写</li><li>父类引用指向子类对象</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;🐱喜欢吃🥩&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>父类引用指向子类对象即</strong> : </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"></span><br><span class="line">animal=<span class="keyword">new</span> <span class="title class_">Dog</span>();<span class="comment">//说明第三点</span></span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ol><li>一个对象的编译类型和运行类型可以不一致</li><li>编译类型在定义对象时，就确定了，不能改变</li><li>运行类型是可以变化的</li><li>编译类型看定义时 + 号的左边，运行类型看 &#x3D; 号的右边<ol><li>编译类型决定了引用变量可以调用哪些属性和行为</li><li>运行类型则是在程序运行过程中jvm实际使用的类型</li></ol></li></ol><h2 id="⭐多态的使用"><a href="#⭐多态的使用" class="headerlink" title="⭐多态的使用"></a>⭐多态的使用</h2><h3 id="多态中成员方法的使用"><a href="#多态中成员方法的使用" class="headerlink" title="多态中成员方法的使用"></a>多态中成员方法的使用</h3><ol><li><strong>使用规则：</strong><ol><li><strong>编译看左</strong>(即左边的编译类型有没有这个方法，决定了能不能调用目标方法)</li><li><strong>运行看右</strong>(即右边的运行类型中的该方法，才是运行中<strong>实际使用</strong>的方法)</li><li></li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal cry() 动物在叫....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat cry() 小猫喵喵叫...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog cry() 小狗汪汪叫...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyObject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//体验对象多态特点</span></span><br><span class="line">        <span class="comment">//animal 编译类型就是 Animal , 运行类型 Dog</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">//因为运行时 , 执行到改行时，animal运行类型是Dog,所以cry就是Dog的cry</span></span><br><span class="line">        animal.cry(); <span class="comment">//小狗汪汪叫</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//animal 编译类型 Animal,运行类型就是 Cat</span></span><br><span class="line">        animal = <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        animal.cry(); <span class="comment">//小猫喵喵叫</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">小狗汪汪叫</span><br><span class="line"></span><br><span class="line">小猫喵喵叫</span><br></pre></td></tr></table></figure><h3 id="多态中成员变量的使用"><a href="#多态中成员变量的使用" class="headerlink" title="多态中成员变量的使用"></a>多态中成员变量的使用</h3><ol><li><strong>使用规则 :</strong><ol><li><strong>编译看左</strong>（即左边的编译类型有没有这个成员，这决定了我们能不能调用目标成员）</li><li><strong>运行看左</strong>（多态关系中，成员变量是不涉及重写的）</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Parent&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Child&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Parent</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">        System.out.println(obj.name); <span class="comment">// 输出: Parent</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li><strong>静态绑定（编译时多态）：</strong>成员变量与成员方法不同，成员变量不支持多态性，也就是无论引用指向的是父类还是子类对象，访问的成员变量都是由引用类型决定的，而不是由对象的实际类型决定的</li><li><strong>隐藏而非覆盖：</strong>虽然子类可以定义与父类同名的成员变量，但这并不是方法覆盖的概念，而是简单的名称隐藏。这意味着不能通过覆写来改变父类中成员变量的值</li></ol><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="向上转型-自动"><a href="#向上转型-自动" class="headerlink" title="向上转型(自动)"></a>向上转型(自动)</h3><ol><li><p>子类类型转换成父类类型(父类引用指向子类对象)，向上转型是自动进行的</p></li><li><p>语法：</p><ol><li><pre><code class="Java">父类类型  父类引用变量  =  new  子类类型();<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. 特点：</span><br><span class="line"></span><br><span class="line">   1. 可以调用父类中的所有成员(需要遵守访问权限)</span><br><span class="line">   2. 不能调用子类中特有的成员</span><br><span class="line">   3. 最终运行效果看子类的具体实现</span><br><span class="line"></span><br><span class="line">### 向下转型(强制)</span><br><span class="line"></span><br><span class="line">1. 父类类型转成子类类型（向下转型改变了编译类型）</span><br><span class="line"></span><br><span class="line">2. 语法格式：</span><br><span class="line"></span><br><span class="line">   1. ```Java</span><br><span class="line">      子类类型  子类引用变量  =  (子类类型) 父类引用</span><br><span class="line">      或者 </span><br><span class="line">      直接使用 &quot; ((子类类型)父类引用变量).method_name(..) &quot; 的方式来调用子类特有成员，而不去做接收</span><br><span class="line">      </span><br><span class="line">      Cat cat =(Cat) animal；</span><br></pre></td></tr></table></figure></code></pre></li></ol></li><li><p>只能强转父类的引用，不能强转父类的对象</p></li><li><p>要求父类的引用必须指向的是当前目标类型的对象</p></li><li><p>当向下转型后，可以调用子类类型中所有的成员</p></li></ol><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="title class_">String</span> name = <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">    int age = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">sleep</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;睡&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">run</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;跑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">eat</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;吃&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">show</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;hello,你好&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">eat</span>(<span class="params"></span>)&#123;<span class="comment">//方法重写</span></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;猫吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">catchMouse</span>(<span class="params"></span>)&#123;<span class="comment">//Cat特有方法</span></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;猫抓老鼠&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;<span class="comment">//Dog是Animal的子类</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyDetail</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向上转型: 父类的引用指向了子类的对象</span></span><br><span class="line">        <span class="comment">//语法：父类类型引用名 = new 子类类型();</span></span><br><span class="line">        <span class="title class_">Animal</span> animal = <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="title class_">Object</span> obj = <span class="keyword">new</span> <span class="title class_">Cat</span>();<span class="comment">//可以吗? 可以 Object 也是 Cat的父类</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//向上转型调用方法的规则如下:</span></span><br><span class="line">        <span class="comment">//(1)可以调用父类中的所有成员(需遵守访问权限)</span></span><br><span class="line">        <span class="comment">//(2)但是不能调用子类的特有的成员</span></span><br><span class="line">        <span class="comment">//(#)因为在编译阶段，能调用哪些成员,是由编译类型来决定的</span></span><br><span class="line">        <span class="comment">//animal.catchMouse();错误</span></span><br><span class="line">        <span class="comment">//(4)最终运行效果看子类(运行类型)的具体实现, 即调用方法时，按照从子类(运行类型)开始查找方法</span></span><br><span class="line">        <span class="comment">//，然后调用，规则我前面我们讲的方法调用规则一致。</span></span><br><span class="line">        animal.<span class="title function_">eat</span>();<span class="comment">//猫吃鱼..</span></span><br><span class="line">        animal.<span class="title function_">run</span>();<span class="comment">//跑</span></span><br><span class="line">        animal.<span class="title function_">show</span>();<span class="comment">//hello,你好</span></span><br><span class="line">        animal.<span class="title function_">sleep</span>();<span class="comment">//睡</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//多态的向下转型</span></span><br><span class="line">        <span class="comment">//(1)语法：子类类型 引用名 =（子类类型）父类引用;</span></span><br><span class="line">        <span class="comment">//cat 的编译类型 Cat,运行类型是 Cat</span></span><br><span class="line">        <span class="title class_">Cat</span> cat = (<span class="title class_">Cat</span>) animal;</span><br><span class="line">        cat.<span class="title function_">catchMouse</span>();<span class="comment">//猫抓老鼠</span></span><br><span class="line">        <span class="comment">//(2)要求父类的引用必须指向的是当前目标类型的对象</span></span><br><span class="line">        <span class="title class_">Dog</span> dog = (<span class="title class_">Dog</span>) animal; <span class="comment">//可以吗？</span></span><br><span class="line"></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;ok~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="instanceof关键字"><a href="#instanceof关键字" class="headerlink" title="instanceof关键字"></a>instanceof关键字</h2><ol><li><p>instanceof关键字可以判断指定对象是否为指定的类型，并返回一个Boolean类型的值，常与if条件语句一起使用</p></li><li><p>语法：</p><ol><li><pre><code class="Java"> 对象名  instanceof  数据类型        说明 : 前面的“对象名”即引用变量实际参与判断的是引用变量指向的——堆空间中真正的对象      <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class PolyDetail03 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BB bb = new BB();</span><br><span class="line">        System.out.println(bb instanceof  BB);// true</span><br><span class="line">        System.out.println(bb instanceof  AA);// true</span><br><span class="line"></span><br><span class="line">        //aa 编译类型 AA, 运行类型是BB</span><br><span class="line">        //BB是AA子类</span><br><span class="line">        AA aa = new BB();</span><br><span class="line">        System.out.println(aa instanceof AA);</span><br><span class="line">        System.out.println(aa instanceof BB);</span><br><span class="line"></span><br><span class="line">        Object obj = new Object();</span><br><span class="line">        System.out.println(obj instanceof AA);//false</span><br><span class="line">        String str = &quot;hello&quot;;</span><br><span class="line">        //System.out.println(str instanceof AA);</span><br><span class="line">        System.out.println(str instanceof Object);//true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AA &#123;&#125; //父类</span><br><span class="line">class BB extends AA &#123;&#125;//子类</span><br></pre></td></tr></table></figure></code></pre></li></ol></li></ol><h2 id="java-的动态绑定机制"><a href="#java-的动态绑定机制" class="headerlink" title="java 的动态绑定机制"></a>java 的动态绑定机制</h2><h3 id="动态绑定的工作原理"><a href="#动态绑定的工作原理" class="headerlink" title="动态绑定的工作原理"></a>动态绑定的工作原理</h3><ol><li>当通过对象的形式调用方法时，该方法会和堆内存中真正的该对象的内存地址绑定，且这种绑定关系会贯穿方法的执行全过程</li><li><strong>方法表（Method Table）</strong>：<ol><li>每个类在加载时都会生成一个方法表（也称为虚方法表或vtable），其中包含所有可被重写的实例方法</li><li>子类继承父类的方法表，并覆盖被重写方法的入口地址</li></ol></li><li><strong>调用过程：</strong><ol><li>当通过父类引用调用方法时，JVM会查找引用所指向对象的实际类型</li><li>然后根据实际类型的vtable找到对应方法的实现并调用</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal makes a sound&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog barks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat meows&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">myAnimal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(); <span class="comment">// 父类引用指向子类对象</span></span><br><span class="line">        myAnimal.sound(); <span class="comment">// 输出: Dog barks</span></span><br><span class="line"></span><br><span class="line">        myAnimal = <span class="keyword">new</span> <span class="title class_">Cat</span>(); <span class="comment">// 修改引用指向另一个子类对象</span></span><br><span class="line">        myAnimal.sound(); <span class="comment">// 输出: Cat meows</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态绑定"><a href="#静态绑定" class="headerlink" title="静态绑定"></a>静态绑定</h3><ol><li>当通过对象的形式调用属性时，不存在动态绑定机制</li><li><strong>成员变量</strong>的访问依据的是引用类型，而不是对象的实际类型</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Parent&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Child&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Parent</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">        System.out.println(obj.name); <span class="comment">// 输出: Parent</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>静态方法</strong>属于类本身，而不是某个具体对象。无论通过父类还是子类调用静态方法，都只会调用定义该方法的类中的版本</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent&#x27;s static method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child&#x27;s static method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Parent</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">        obj.display(); <span class="comment">// 输出: Parent&#x27;s static method</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多态的应用"><a href="#多态的应用" class="headerlink" title="多态的应用"></a>多态的应用</h2><h3 id="多态数组"><a href="#多态数组" class="headerlink" title="多态数组"></a>多态数组</h3><p>数组的定义类型为父类类型，里面保存的实际元素类型为子类类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;<span class="comment">//父类</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">say</span><span class="params">()</span> &#123;<span class="comment">//返回名字和年龄</span></span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">&quot;\t&quot;</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">double</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age);</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">double</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写父类say</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;学生 &quot;</span> + <span class="built_in">super</span>.say() + <span class="string">&quot; score=&quot;</span> + score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//特有的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生 &quot;</span> + getName() + <span class="string">&quot; 正在学java...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> com.hspedu.poly_.polyarr_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age);</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写重写父类的say方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;老师 &quot;</span> + <span class="built_in">super</span>.say() + <span class="string">&quot; salary=&quot;</span> + salary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//特有方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老师 &quot;</span> + getName() + <span class="string">&quot; 正在讲java课程...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PloyArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//应用实例:现有一个继承结构如下：要求创建1个Person对象、</span></span><br><span class="line">        <span class="comment">// 2个Student 对象和2个Teacher对象, 统一放在数组中，并调用每个对象say方法</span></span><br><span class="line"></span><br><span class="line">        Person[] persons = <span class="keyword">new</span> <span class="title class_">Person</span>[<span class="number">5</span>];</span><br><span class="line">        persons[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;jack&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        persons[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;mary&quot;</span>, <span class="number">18</span>, <span class="number">100</span>);</span><br><span class="line">        persons[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;smith&quot;</span>, <span class="number">19</span>, <span class="number">30.1</span>);</span><br><span class="line">        persons[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;scott&quot;</span>, <span class="number">30</span>, <span class="number">20000</span>);</span><br><span class="line">        persons[<span class="number">4</span>] = <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;king&quot;</span>, <span class="number">50</span>, <span class="number">25000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环遍历多态数组，调用say</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; persons.length; i++) &#123;</span><br><span class="line">            <span class="comment">//老师提示: person[i] 编译类型是 Person ,运行类型是是根据实际情况有JVM来判断</span></span><br><span class="line">            System.out.println(persons[i].say());<span class="comment">//动态绑定机制</span></span><br><span class="line">            <span class="comment">//这里大家聪明. 使用 类型判断 + 向下转型.</span></span><br><span class="line">            <span class="keyword">if</span>(persons[i]  <span class="keyword">instanceof</span>  Student) &#123;<span class="comment">//判断person[i] 的运行类型是不是Student</span></span><br><span class="line">                <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student)persons[i];<span class="comment">//向下转型</span></span><br><span class="line">                student.study();</span><br><span class="line">                <span class="comment">//小伙伴也可以使用一条语句 ((Student)persons[i]).study();</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(persons[i] <span class="keyword">instanceof</span>  Teacher) &#123;</span><br><span class="line">                <span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> (Teacher)persons[i];</span><br><span class="line">                teacher.teach();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(persons[i] <span class="keyword">instanceof</span>  Person)&#123;</span><br><span class="line">                <span class="comment">//System.out.println(&quot;你的类型有误, 请自己检查...&quot;);</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;你的类型有误, 请自己检查...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多态参数"><a href="#多态参数" class="headerlink" title="多态参数"></a>多态参数</h3><p> 方法的形参类型定义为父类类型，当传入的实参类型为子类类型时，每传入一个子类对象，都相当于形成了一次多态</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到年工资的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getAnnual</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">12</span> * salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> bonus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">(String name, <span class="type">double</span> salary, <span class="type">double</span> bonus)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, salary);</span><br><span class="line">        <span class="built_in">this</span>.bonus = bonus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBonus</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bonus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBonus</span><span class="params">(<span class="type">double</span> bonus)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bonus = bonus;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">manage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;经理 &quot;</span> + getName() + <span class="string">&quot; is managing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写获取年薪方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getAnnual</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getAnnual() + bonus;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String name, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, salary);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通员工 &quot;</span> + getName() + <span class="string">&quot; is working&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getAnnual</span><span class="params">()</span> &#123; <span class="comment">//因为普通员工没有其它收入，则直接调用父类方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getAnnual();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PloyParameter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Worker</span> <span class="variable">tom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;tom&quot;</span>, <span class="number">2500</span>);</span><br><span class="line">        <span class="type">Manager</span> <span class="variable">milan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>(<span class="string">&quot;milan&quot;</span>, <span class="number">5000</span>, <span class="number">200000</span>);</span><br><span class="line">        <span class="type">PloyParameter</span> <span class="variable">ployParameter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PloyParameter</span>();</span><br><span class="line">        ployParameter.showEmpAnnual(tom);</span><br><span class="line">        ployParameter.showEmpAnnual(milan);</span><br><span class="line"></span><br><span class="line">        ployParameter.testWork(tom);</span><br><span class="line">        ployParameter.testWork(milan);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//showEmpAnnual(Employee e)</span></span><br><span class="line">    <span class="comment">//实现获取任何员工对象的年工资,并在main方法中调用该方法 [e.getAnnual()]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showEmpAnnual</span><span class="params">(Employee e)</span> &#123;</span><br><span class="line">        System.out.println(e.getAnnual());<span class="comment">//动态绑定机制.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加一个方法，testWork,如果是普通员工，则调用work方法，如果是经理，则调用manage方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWork</span><span class="params">(Employee e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(e <span class="keyword">instanceof</span>  Worker) &#123;</span><br><span class="line">            ((Worker) e).work();<span class="comment">//有向下转型操作</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(e <span class="keyword">instanceof</span> Manager) &#123;</span><br><span class="line">            ((Manager) e).manage();<span class="comment">//有向下转型操作</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不做处理...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h1><h2 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h2><ol><li>Object类是Java类层次最顶层的父类，所有类都是直接或间接继承值object类，因此使用类都可以使用object类中的成员方法</li><li>Object类属于java.base模块，java.lang包下（java.lang包下的类可以直接使用，不需要导包）</li></ol><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><ol><li><h3 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals 方法"></a>equals 方法</h3></li></ol><p>&#x3D;&#x3D;和equals的对比</p><ol><li>&#x3D;&#x3D;是一个比较运算符</li><li>&#x3D;&#x3D;：既可以判断基本类型，又可以判断引用类型</li><li>&#x3D;&#x3D;：如果判断基本类型，判断的是值是否相等</li><li>&#x3D;&#x3D;：如果判断引用类型，判断的是地址是否相等，即判断是不是同一个对象</li><li>equals：是Object类中的方法，只能判断引用类型</li><li>默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.object_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Equals01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">A</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br><span class="line">        <span class="type">A</span> <span class="variable">c</span> <span class="operator">=</span> b;</span><br><span class="line">        System.out.println(a == c);<span class="comment">//true</span></span><br><span class="line">        System.out.println(b == c);<span class="comment">//true</span></span><br><span class="line">        <span class="type">B</span> <span class="variable">bObj</span> <span class="operator">=</span> a;</span><br><span class="line">        System.out.println(bObj == c);<span class="comment">//true</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">10.0</span>;</span><br><span class="line">        System.out.println(num1 == num2);<span class="comment">//基本数据类型，判断值是否相等</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(integer1 == integer2);<span class="comment">//false</span></span><br><span class="line">        System.out.println(integer1.equals(integer2));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hspedu&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hspedu&quot;</span>);</span><br><span class="line">        System.out.println(str1 == str2);<span class="comment">//false</span></span><br><span class="line">        System.out.println(str1.equals(str2));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">B</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>重写equals</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.object_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EqualsExercise01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;jack&quot;</span>, <span class="number">10</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;jack&quot;</span>, <span class="number">20</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(person1.equals(person2));<span class="comment">//假</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断两个Person对象的内容是否相等，</span></span><br><span class="line"><span class="comment">//如果两个Person对象的各个属性值都一样，则返回true，反之false</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123; <span class="comment">//extends Object</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> gender;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写Object 的 equals方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="comment">//判断如果比较的两个对象是同一个对象，则直接返回true</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span> == obj) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//类型判断</span></span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span>  Person) &#123;<span class="comment">//是Person，我们才比较</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//进行 向下转型, 因为我需要得到obj的 各个属性</span></span><br><span class="line">            <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person)obj;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.name.equals(p.name) &amp;&amp; <span class="built_in">this</span>.age == p.age &amp;&amp; <span class="built_in">this</span>.gender == p.gender;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不是Person ，则直接返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">char</span> gender)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">getGender</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGender</span><span class="params">(<span class="type">char</span> gender)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><h3 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h3></li></ol><p>返回当前对象的哈希码值，该方法通过对象的地址值进行计算，不同对象的返回值一般不同</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashCode_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建学生类对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student_0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student_1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="comment">//比较不同学生对象的哈希码值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;student_0对象的哈希码值为 : &quot;</span> + student_0.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;student_1对象的哈希码值为 : &quot;</span> + student_1.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;student_0对象的哈希码值为 : &quot;</span> + student_0.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;&#125;</span><br></pre></td></tr></table></figure><ol><li><h3 id="getClass方法"><a href="#getClass方法" class="headerlink" title="getClass方法"></a>getClass方法</h3></li></ol><p>返回调用此方法的对象的运行时类对象（即Class对象，也叫字节码文件对象）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetClass_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建葡萄类对象</span></span><br><span class="line">        <span class="type">Grape</span> <span class="variable">grape_0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Grape</span>();</span><br><span class="line">        <span class="type">Grape</span> <span class="variable">grape_1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Grape</span>();</span><br><span class="line">        <span class="comment">//获取葡萄类的Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">class_grape_0</span> <span class="operator">=</span> grape_0.getClass();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">class_grape_1</span> <span class="operator">=</span> grape_1.getClass();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">grape_0_class</span> <span class="operator">=</span> grape_0.getClass();</span><br><span class="line">        <span class="comment">//比较通过葡萄类不同对象获得的葡萄类的Class对象有什么不同。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;grape_0对象的字节码文件对象是：&quot;</span> + class_grape_0);</span><br><span class="line">        System.out.println(<span class="string">&quot;grape_1对象的字节码文件对象是：&quot;</span> + class_grape_1);</span><br><span class="line">        System.out.println(<span class="string">&quot;grape_0对象的字节码文件对象是：&quot;</span> + grape_0_class);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------------------------------&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建苹果类对象</span></span><br><span class="line">        <span class="type">Apple</span> <span class="variable">apple_0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">        <span class="type">Apple</span> <span class="variable">apple_1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">        <span class="comment">//获取苹果类的Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">apple_0_class</span> <span class="operator">=</span> apple_0.getClass();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">apple_1_class</span> <span class="operator">=</span> apple_1.getClass();</span><br><span class="line">        <span class="comment">//比较通过苹果类不同对象获得的苹果类的Class文件有什么不同</span></span><br><span class="line">        System.out.println(<span class="string">&quot;apple_0对象的字节码文件对象是：&quot;</span> + apple_0_class);</span><br><span class="line">        System.out.println(<span class="string">&quot;apple_1对象的字节码文件对象是：&quot;</span> + apple_1_class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Grape</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> &#123;&#125;</span><br></pre></td></tr></table></figure><ol><li><h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h3></li><li><p>默认返回：全类名+@+哈希值的十六进制</p></li><li><p>子类往往重写 toString 方法，用于返回对象的属性信息</p></li><li><p>重写 toString 方法，打印对象或拼接对象时，都会自动调用该对象的 toString 形式</p></li><li><p>当直接输出一个对象时，toString 方法会被默认的调用, 比如 System.out.println(monster)； 就会默认调用 monster.toString()</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.object_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToString_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Object的toString() 源码</span></span><br><span class="line"><span class="comment">        (1)getClass().getName() 类的全类名(包名+类名 )</span></span><br><span class="line"><span class="comment">        (2)Integer.toHexString(hashCode()) 将对象的hashCode值转成16进制字符串</span></span><br><span class="line"><span class="comment">        public String toString() &#123;</span></span><br><span class="line"><span class="comment">            return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Monster</span> <span class="variable">monster</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Monster</span>(<span class="string">&quot;小妖怪&quot;</span>, <span class="string">&quot;巡山的&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">        System.out.println(monster.toString() + <span class="string">&quot; hashcode=&quot;</span> + monster.hashCode());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;==当直接输出一个对象时，toString 方法会被默认的调用==&quot;</span>);</span><br><span class="line">        System.out.println(monster); <span class="comment">//等价 monster.toString()</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Monster</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String job;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> sal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Monster</span><span class="params">(String name, String job, <span class="type">double</span> sal)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.job = job;</span><br><span class="line">        <span class="built_in">this</span>.sal = sal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写toString方法, 输出对象的属性</span></span><br><span class="line">    <span class="comment">//使用快捷键即可 alt+insert -&gt; toString</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="comment">//重写后，一般是把对象的属性值输出，当然程序员也可以自己定制</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Monster&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, job=&#x27;&quot;</span> + job + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, sal=&quot;</span> + sal +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;fin..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize 方法"></a>finalize 方法</h3></li><li><p>当对象被回收时，系统自动调用该对象的 finalize 方法。子类可以重写该方法，做一些释放资源的操作</p></li><li><p>什么时候被回收：当某个对象没有任何引用时，则 jvm 就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来</p></li></ol><p>销毁该对象，在销毁该对象前，会先调用 finalize 方法。</p><ol><li>垃圾回收机制的调用，是由系统来决定(即有自己的 GC 算法), 也可以通过 System.gc() 主动触发垃圾回收机制</li><li>在实际开发中，几乎不会运用 finalize , 所以更多就是为了应付面试</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础知识</title>
      <link href="/2025/04/24/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2025/04/24/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-变量"><a href="#1-变量" class="headerlink" title="1.变量"></a>1.变量</h1><h2 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h2><p>变量相当于内存中一个数据存储空间</p><h2 id="1-2-格式"><a href="#1-2-格式" class="headerlink" title="1.2 格式"></a>1.2 格式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型 变量名 = 数据值；</span><br></pre></td></tr></table></figure><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VariableDemo</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">                <span class="comment">//定义一个整数类型的变量</span></span><br><span class="line">                <span class="comment">//数据类型 变量名 = 数据值;</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">                System.out.println(a);<span class="comment">//16</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//定义一个小数类型的变量</span></span><br><span class="line">                <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10.1</span>;</span><br><span class="line">                System.out.println(b);<span class="comment">//10.1</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>变量必须先声名，后使用</li><li>变量在同一个作用域内不能重名</li></ol><h2 id="1-3-程序中-号的使用"><a href="#1-3-程序中-号的使用" class="headerlink" title="1.3 程序中+号的使用"></a>1.3 程序中+号的使用</h2><ol><li>当作用两边都是数值型时，做加法运算</li><li>当左右两边有一方为字符串，做拼接运算</li><li>运算顺序，是从左到右</li></ol><p><strong>案例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Plus</span> &#123; </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">                System.out.println(<span class="number">100</span> + <span class="number">98</span>); <span class="comment">//198</span></span><br><span class="line">                System.out.println(<span class="string">&quot;100&quot;</span> + <span class="number">98</span>);<span class="comment">//10098</span></span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="number">100</span> + <span class="number">3</span> + <span class="string">&quot;hello&quot;</span>);<span class="comment">//103hello</span></span><br><span class="line">                System.out.println(<span class="string">&quot;hello&quot;</span> + <span class="number">100</span> +<span class="number">3</span>); <span class="comment">//hello1003</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2.数据类型"></a>2.数据类型</h1><p>Java 是一种强类型的编程语言，它对变量的数据类型有严格的限定，在定义变量是必须声名变量的数据类型，在为变量赋值时必须赋予与变量同一种类型的值</p><p><img src="https://pic1.imgdb.cn/item/680953bc58cb8da5c8c6c814.png" alt="img"></p><h2 id="2-1-整数类型"><a href="#2-1-整数类型" class="headerlink" title="2.1 整数类型"></a>2.1 整数类型</h2><table><thead><tr><th>数据类型</th><th>内存空间（8 位等于 1 字节）</th><th>取值范围</th></tr></thead><tbody><tr><td>byte</td><td>8 位（1 字节）</td><td>-128~ 127</td></tr><tr><td>short</td><td>16 位（2 字节）</td><td>-32768~ 32767</td></tr><tr><td>int</td><td>32 位（4 字节）</td><td>-2147483648~ 2147483647</td></tr><tr><td>long</td><td>64 位（8 字节）</td><td>-9223372036854775808~ 9223372036854775807</td></tr></tbody></table><p><strong>注意：</strong></p><ul><li>Java 的整数类型默认为 int 类型，声名 long 类型须加上 ‘l’ 或 ‘L’</li></ul><p><strong>案例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntDetail</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//1.定义byte类型的变量</span></span><br><span class="line">        <span class="comment">//数据类型 变量名 = 数据值;</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.定义short类型的变量</span></span><br><span class="line">        <span class="type">short</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        System.out.println(b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.定义int类型的变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">        System.out.println(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.定义long类型的变量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">123456789123456789L</span>;</span><br><span class="line">        System.out.println(d);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-浮点类型"><a href="#2-2-浮点类型" class="headerlink" title="2.2 浮点类型"></a>2.2 浮点类型</h2><p>浮点类型用来存储含有小数部分的数值</p><table><thead><tr><th>数据类型</th><th>内存空间（8 位等于 1 字节）</th><th>取值范围</th></tr></thead><tbody><tr><td>float</td><td>32 位（4 字节）</td><td>1.4E-45~ 3.4028235E38</td></tr><tr><td>double</td><td>64 位（8 字节）</td><td>4.9E-324~ 1.7976931348623157E308</td></tr></tbody></table><p><strong>注意：</strong></p><ol><li>浮点数在机器中存放的形式是：浮点数&#x3D;符号位+指数位+尾数位</li><li>尾数部分可能丢失，造成精度损失（小数都是近似值）</li><li>浮点数的默认类型是 double 型声名 float 型时须加上 ‘f’或‘F’</li><li>double 类型表示的浮点数比 float 类型更精确</li></ol><p><strong>案例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">doubleDetail</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.定义float类型的变量</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">e</span> <span class="operator">=</span> <span class="number">10.1F</span>;</span><br><span class="line">        System.out.println(e);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.定义double类型的变量</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">20.3</span>;</span><br><span class="line">        System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-字符类型"><a href="#2-3-字符类型" class="headerlink" title="2.3 字符类型"></a>2.3 字符类型</h2><p>字符类型（char）用于存储单个字符，占用 16 位（两个字节）的内存空间</p><p><strong>注意：</strong></p><ol><li>字符类型要用单引号（‘ ’）括起来</li><li>Java 中，char 类型本质上是一个整数，在输出时，是 Unicode 码对应的字符</li><li>可以直接给 char 赋一个整数，然后输出是，会按照对应的 Unicode 字符输出</li><li>char 类型可以进行运算</li></ol><p><strong>案例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharDetail</span> &#123; </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">                <span class="comment">//在java中，char的本质是一个整数，在默认输出时，是unicode码对应的字符</span></span><br><span class="line">                <span class="comment">//要输出对应的数字，可以(int)字符</span></span><br><span class="line">                <span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="number">97</span>;</span><br><span class="line">                System.out.println(c1); <span class="comment">// a</span></span><br><span class="line"></span><br><span class="line">                <span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>; <span class="comment">//输出&#x27;a&#x27; 对应的 数字</span></span><br><span class="line">                System.out.println((<span class="type">int</span>)c2);</span><br><span class="line">                <span class="type">char</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="string">&#x27;韩&#x27;</span>;</span><br><span class="line">                System.out.println((<span class="type">int</span>)c3);<span class="comment">//38889</span></span><br><span class="line">                <span class="type">char</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="number">38889</span>;</span><br><span class="line">                System.out.println(c4);<span class="comment">//韩</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//char类型是可以进行运算的，相当于一个整数，因为它都对应有Unicode码.</span></span><br><span class="line">                </span><br><span class="line">                System.out.println(<span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>);<span class="comment">//107</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-转义字符"><a href="#2-4-转义字符" class="headerlink" title="2.4 转义字符"></a>2.4 转义字符</h2><table><thead><tr><th>转义字符（ASCII 码值【十进制】）</th><th>意义</th></tr></thead><tbody><tr><td>\b( 008)</td><td>退格（BS），将当前位置移到前一列</td></tr><tr><td>\f( 012)</td><td>换页（FF），将当前位置一道下页开头</td></tr><tr><td>–</td><td>–</td></tr><tr><td>\n( 010)</td><td>换行（LF），将当前位置移到下一行开头</td></tr><tr><td>\r( 013)</td><td>回车（CR），将当前位置移到本行开头</td></tr><tr><td>–</td><td>–</td></tr><tr><td>\t( 009)</td><td>水平制表（HT）（跳到次啊一个 TAB 位置）</td></tr><tr><td>( 092)</td><td>代表一个反斜字符\</td></tr><tr><td>–</td><td>–</td></tr><tr><td>‘( 039)</td><td>代表一个单引号（撤号字符）</td></tr><tr><td>“( 034)</td><td>代表一个双引号字符</td></tr><tr><td>–</td><td>–</td></tr><tr><td>?( 063)</td><td>代表一个问号</td></tr><tr><td>\0( 000)</td><td>空字符（NULL）</td></tr><tr><td>–</td><td>–</td></tr><tr><td>\ddd（三位八进制）</td><td>1 到 3 位八进制数所代表的任意字符</td></tr><tr><td>\xhh（十六进制）</td><td>十六进制所代表的任意字符</td></tr></tbody></table><h2 id="2-5-布尔类型"><a href="#2-5-布尔类型" class="headerlink" title="2.5 布尔类型"></a>2.5 布尔类型</h2><ol><li>布尔类型（boolean）数据只允许取值 true 或 false</li><li>Boolean 类型占 1 字节</li><li>Boolean 类型适用于逻辑运算，一般用于程序流程控制</li></ol><p><strong>案例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Boolean01</span> &#123; </span><br><span class="line">        <span class="comment">//编写一个main方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">                <span class="comment">//演示判断成绩是否通过的案例</span></span><br><span class="line">                <span class="comment">//定义一个布尔变量</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">isPass</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//</span></span><br><span class="line">                <span class="keyword">if</span>(isPass == <span class="literal">true</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;考试通过，恭喜&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;考试没有通过，下次努力&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-6-基本数据类型转换"><a href="#2-6-基本数据类型转换" class="headerlink" title="2.6 基本数据类型转换"></a>2.6 基本数据类型转换</h2><h3 id="2-6-1-自动类型转换"><a href="#2-6-1-自动类型转换" class="headerlink" title="2.6.1 自动类型转换"></a>2.6.1 自动类型转换</h3><p>Java 程序在进行赋值或运算时，精度下的类型自动转换为精度达的数据类型</p><p><strong>数据类型按精度大小排序为：</strong></p><p><img src="https://pic1.imgdb.cn/item/680953bc58cb8da5c8c6c816.png" alt="img"></p><p><strong>注意：</strong></p><ol><li>有多种类型的数据混合运算时，系统首先自动将所有数据转换成精度最大的那种数据类型，然后再进行计算</li><li>（byte，short）和 char 之间不会相互自动转换</li><li>byte，short，char 可以进行计算，在计算时会转换为 int 类型</li><li>Boolean 类型不参与计算</li></ol><p><strong>案例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自动类型转换细节</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoConvertDetail</span> &#123; </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">                <span class="comment">// 有多种类型的数据混合运算时，</span></span><br><span class="line">                <span class="comment">//系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">//ok</span></span><br><span class="line">                <span class="comment">//float d1 = n1 + 1.1;//错误 n1 + 1.1 =&gt; 结果类型是 double</span></span><br><span class="line">                <span class="comment">//double d1 = n1 + 1.1;//对 n1 + 1.1 =&gt; 结果类型是 double</span></span><br><span class="line">                <span class="type">float</span> <span class="variable">d1</span> <span class="operator">=</span> n1 + <span class="number">1.1F</span>;<span class="comment">//对 n1 + 1.1 =&gt; 结果类型是 float</span></span><br><span class="line">        </span><br><span class="line">                <span class="comment">//(byte, short) 和 char之间不会相互自动转换</span></span><br><span class="line">                <span class="comment">//当把具体数赋给 byte 时，(1)先判断该数是否在byte范围内，如果是就可以</span></span><br><span class="line">                <span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">//对  , -128-127</span></span><br><span class="line">                <span class="comment">// int n2 = 1; //n2 是int </span></span><br><span class="line">                <span class="comment">// byte b2 = n2; //错误，原因： 如果是变量赋值，判断类型</span></span><br><span class="line">                <span class="comment">// char c1 = b1; //错误， 原因 byte 不能自动转成 char</span></span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                <span class="comment">// byte，short，char  他们三者可以计算，在计算时首先转换为int类型</span></span><br><span class="line">                <span class="type">byte</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">                <span class="type">byte</span> <span class="variable">b3</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">                <span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//short s2 = b2 + s1;//错, b2 + s1 =&gt; int</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">s2</span> <span class="operator">=</span> b2 + s1;<span class="comment">//对, b2 + s1 =&gt; int</span></span><br><span class="line">                <span class="comment">//byte b4 = b2 + b3; //错误: b2 + b3 =&gt; int</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//boolean 不参与转换</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">pass</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//int num100 = pass;// boolean 不参与类型的自动转换</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-2-强制类型转换"><a href="#2-6-2-强制类型转换" class="headerlink" title="2.6.2 强制类型转换"></a>2.6.2 强制类型转换</h3><p>强制类型转换的逆过程，<strong>将容量大的数据类型转换为容量小的数据类型</strong>，使用时要加上强制转换符 （ ），但可能造成精度降低或溢出</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForceConvert</span> &#123; </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">                <span class="comment">//演示强制类型转换</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1.9</span>;</span><br><span class="line">                System.out.println(<span class="string">&quot;n1=&quot;</span> + n1);<span class="comment">//1, 造成精度损失</span></span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">2000</span>;</span><br><span class="line">                <span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> (<span class="type">byte</span>)n2;</span><br><span class="line">                System.out.println(<span class="string">&quot;b1=&quot;</span> + b1);<span class="comment">//造成 数据溢出</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-7-基本数据类型和-String-类型的转换"><a href="#2-7-基本数据类型和-String-类型的转换" class="headerlink" title="2.7 基本数据类型和 String 类型的转换"></a>2.7 基本数据类型和 String 类型的转换</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringToBasic</span> &#123; </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">                <span class="comment">//基本数据类型-&gt;String</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">                <span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">1.1F</span>;</span><br><span class="line">                <span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="number">4.5</span>;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> n1 + <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> f1 + <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> d1 + <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> b1 + <span class="string">&quot;&quot;</span>;</span><br><span class="line">                System.out.println(s1 + <span class="string">&quot; &quot;</span> + s2 + <span class="string">&quot; &quot;</span> + s3 + <span class="string">&quot; &quot;</span> + s4);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//String-&gt;对应的基本数据类型</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">                <span class="comment">//会在OOP 讲对象和方法的时候回详细</span></span><br><span class="line">                <span class="comment">//解读 使用 基本数据类型对应的包装类，的相应方法，得到基本数据类型</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.parseInt(s5);</span><br><span class="line">                <span class="type">double</span> <span class="variable">num2</span> <span class="operator">=</span> Double.parseDouble(s5);</span><br><span class="line">                <span class="type">float</span> <span class="variable">num3</span> <span class="operator">=</span> Float.parseFloat(s5);</span><br><span class="line">                <span class="type">long</span> <span class="variable">num4</span> <span class="operator">=</span> Long.parseLong(s5);</span><br><span class="line">                <span class="type">byte</span> <span class="variable">num5</span> <span class="operator">=</span> Byte.parseByte(s5);</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> Boolean.parseBoolean(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">                <span class="type">short</span> <span class="variable">num6</span> <span class="operator">=</span> Short.parseShort(s5);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;===================&quot;</span>);</span><br><span class="line">                System.out.println(num1);<span class="comment">//123</span></span><br><span class="line">                System.out.println(num2);<span class="comment">//123.0</span></span><br><span class="line">                System.out.println(num3);<span class="comment">//123.0</span></span><br><span class="line">                System.out.println(num4);<span class="comment">//123</span></span><br><span class="line">                System.out.println(num5);<span class="comment">//123</span></span><br><span class="line">                System.out.println(num6);<span class="comment">//123</span></span><br><span class="line">                System.out.println(b);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//怎么把字符串转成字符char -&gt; 含义是指 把字符串的第一个字符得到</span></span><br><span class="line">                <span class="comment">//解读  s5.charAt(0) 得到 s5字符串的第一个字符 &#x27;1&#x27;</span></span><br><span class="line">                System.out.println(s5.charAt(<span class="number">0</span>));</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>在将 String 类型转成 基本数据类型时， ，比如 我们可以把 “123” ， 转成一个整数，但是不能把 “hello” 转成一个整数</p><ol><li>如果格式不正确，就会抛出异常，程序就会终止</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示字符串转基本数据类型的细节</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringToBasicDetail</span> &#123; </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">                <span class="comment">//转成int</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> Integer.parseInt(str);</span><br><span class="line">                System.out.println(n1);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-数组"><a href="#3-数组" class="headerlink" title="3.数组"></a>3.数组</h1><p>数组是用来存储同一种数据类型的多个元素的容器，数组也是一种数据类型，是引用类型</p><h2 id="3-1-创建数组"><a href="#3-1-创建数组" class="headerlink" title="3.1 创建数组"></a>3.1 创建数组</h2><ol><li><strong>动态初始化</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[] 数据名=<span class="keyword">new</span> 数据类型[大小];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] a1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>]; </span><br><span class="line">数据类型[] 数据名;</span><br><span class="line">数组名=<span class="keyword">new</span> 数据类型[大小];</span><br><span class="line"><span class="type">int</span>[] x;</span><br><span class="line">x=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];</span><br></pre></td></tr></table></figure><ol><li><strong>静态初始化</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[] 数组名 = &#123;元素<span class="number">1</span>，元素<span class="number">2</span>，元素<span class="number">3</span>，...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] a3 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ol><li>数组是多个相同类型数据的组合，实现对这些数据的统一管理</li><li>数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用</li><li>数组创建后，如果没有赋值，有默认值：int 0，short 0, byte 0, long 0, float 0.0,double 0.0，char \u0000，boolean false，String null</li><li>使用数组的步骤 1. 声明数组并开辟空间 2 给数组各个元素赋值 3 使用数组</li><li>数组的下标是从 0 开始的</li><li>数组下标必须在指定范围内使用，否则报：下标越界异常</li><li>数组属引用类型，数组型数据是对象(object)</li></ol><p><strong>案例：</strong></p><ol><li>创建一个 char 类型的 26 个元素的数组，分别 放置’A’-‘Z’。使用 for 循环访问所有元素并打印出来</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayExercise01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ch = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ch.length; i++) &#123;</span><br><span class="line">            ch[i] = (<span class="type">char</span>) (<span class="string">&#x27;A&#x27;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ch.length; i++) &#123;</span><br><span class="line">            System.out.print(ch[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>请求出一个数组 int[]的最大值 {4,-1,9, 10,23}，并得到对应的下标</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayExercise02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] num = &#123;<span class="number">4</span>, -<span class="number">1</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">23</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> num[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">sub</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[i] &gt; max) &#123;</span><br><span class="line">                max = num[i];</span><br><span class="line">                sub = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;最大值：&quot;</span> + max);</span><br><span class="line">        System.out.println(<span class="string">&quot;下标：&quot;</span> + sub);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-数组赋值机制"><a href="#3-2-数组赋值机制" class="headerlink" title="3.2 数组赋值机制"></a>3.2 数组赋值机制</h2><ol><li>基本数据类型赋值，这个值就是具体的数据，而且相互不影响</li><li>数组在默认情况下是引用类型，赋的值是地址</li></ol><p>暂时无法在飞书文档外展示此内容</p><h2 id="3-3-数组拷贝"><a href="#3-3-数组拷贝" class="headerlink" title="3.3 数组拷贝"></a>3.3 数组拷贝</h2><p>将 int[] arr1 &#x3D; {10,20,30}; 拷贝到 arr2 数组, 要求数据空间是独立的</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayCopy</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个main方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 int[] arr1 = &#123;10,20,30&#125;; 拷贝到 arr2数组, </span></span><br><span class="line">        <span class="comment">//要求数据空间是独立的.</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] arr1 = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一个新的数组arr2,开辟新的数据空间</span></span><br><span class="line">        <span class="comment">//大小 arr1.length;</span></span><br><span class="line">        <span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="type">int</span>[arr<span class="number">1.l</span>ength];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历 arr1 ，把每个元素拷贝到arr2对应的元素位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr<span class="number">1.l</span>ength; i++) &#123;</span><br><span class="line">            arr2[i] = arr1[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改 arr2， 不会对arr1有影响.</span></span><br><span class="line">        arr2[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出arr1 </span></span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;====arr1的元素====&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr<span class="number">1.l</span>ength; i++) &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(arr1[i]);<span class="comment">//10,20,30</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;====arr2的元素====&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr<span class="number">2.l</span>ength; i++) &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(arr2[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-数组反转"><a href="#3-4-数组反转" class="headerlink" title="3.4 数组反转"></a>3.4 数组反转</h2><p>要求：把数组的元素内容反转</p><p>arr {11,22,33,44,55,66} -&gt;{66, 55,44,33,22,11}</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayReverse</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个main方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">66</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length; <span class="comment">//计算数组的长度</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            temp = arr[len - <span class="number">1</span> - i];<span class="comment">//保存</span></span><br><span class="line">            arr[len - <span class="number">1</span> - i] = arr[i];</span><br><span class="line">            arr[i] = temp; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===翻转后数组===&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot;\t&quot;</span>);<span class="comment">//66,55,44,33,22,11</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-数组添加-扩容"><a href="#3-5-数组添加-扩容" class="headerlink" title="3.5 数组添加&#x2F;扩容"></a>3.5 数组添加&#x2F;扩容</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayAdd02</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个main方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        要求：实现动态的给数组添加元素效果，实现对数组扩容。ArrayAdd.java</span></span><br><span class="line"><span class="comment">        1.原始数组使用静态分配 int[] arr = &#123;1,2,3&#125;</span></span><br><span class="line"><span class="comment">        2.增加的元素4，直接放在数组的最后 arr = &#123;1,2,3,4&#125;</span></span><br><span class="line"><span class="comment">        3.用户可以通过如下方法来决定是否继续添加，添加成功，是否继续？y/n</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">myScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//初始化数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="type">int</span>[] arrNew = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length + <span class="number">1</span>];</span><br><span class="line">            <span class="comment">//遍历 arr 数组，依次将arr的元素拷贝到 arrNew数组</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                arrNew[i] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入你要添加的元素&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">addNum</span> <span class="operator">=</span> myScanner.nextInt();</span><br><span class="line">            <span class="comment">//把addNum赋给arrNew最后一个元素</span></span><br><span class="line">            arrNew[arrNew.length - <span class="number">1</span>] = addNum;</span><br><span class="line">            <span class="comment">//让 arr 指向 arrNew, </span></span><br><span class="line">            arr = arrNew;</span><br><span class="line">            <span class="comment">//输出arr 看看效果</span></span><br><span class="line">            System.out.println(<span class="string">&quot;====arr扩容后元素情况====&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                System.out.print(arr[i] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//问用户是否继续</span></span><br><span class="line">            System.out.println(<span class="string">&quot;是否继续添加 y/n&quot;</span>);</span><br><span class="line">            <span class="type">char</span> <span class="variable">key</span> <span class="operator">=</span> myScanner.next().charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>( key == <span class="string">&#x27;n&#x27;</span>) &#123; <span class="comment">//如果输入n ,就结束</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;你退出了添加...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-6-冒泡排序"><a href="#3-6-冒泡排序" class="headerlink" title="3.6 冒泡排序"></a>3.6 冒泡排序</h2><p>冒泡排序(double sort)通过连续的比较与交换相邻元素实现排序，这个过程就像气泡从底部升到顶部一样</p><p><strong>动画演示：</strong></p><p><img src="https://pic1.imgdb.cn/item/680953bb58cb8da5c8c6c813.gif" alt="img"></p><p><strong>算法流程：</strong></p><p>设数组的长度为 (n) </p><ol><li>首先，对 (n) 个元素执行“冒泡”，<strong>将数组的最大元素交换至正确位置</strong></li><li>接下来，对剩余 (n - 1) 个元素执行“冒泡”，<strong>将第二大元素交换至正确位置</strong></li><li>以此类推，经过 (n - 1) 轮“冒泡”后，<strong>前 (n - 1) 大的元素都被交换至正确位置</strong></li><li>仅剩的一个元素必定是最小元素，无须排序，因此数组排序完成</li></ol><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">24</span>, <span class="number">69</span>, <span class="number">80</span>, <span class="number">57</span>, <span class="number">13</span>&#125;;</span><br><span class="line">        <span class="comment">// 外循环：未排序区间为 [0, i]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="comment">//比较相邻的两个元素</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 交换 arr[j] 与 arr[j + 1]</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出排序后数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);<span class="comment">//13 24 57 69 80</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-7-顺序查找"><a href="#3-7-顺序查找" class="headerlink" title="3.7 顺序查找"></a>3.7 顺序查找</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeqSearch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] names = &#123;<span class="string">&quot;白眉鹰王&quot;</span>, <span class="string">&quot;金毛狮王&quot;</span>, <span class="string">&quot;紫衫龙王&quot;</span>, <span class="string">&quot;青翼蝠王&quot;</span>&#125;;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">myScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入名字&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">findName</span> <span class="operator">=</span> myScanner.next();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; names.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (findName.equals(names[i])) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;恭喜你找到 &quot;</span> + findName);</span><br><span class="line">                System.out.println(<span class="string">&quot;下标为= &quot;</span> + i);</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//退出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123; <span class="comment">//没有找到</span></span><br><span class="line">            System.out.println(<span class="string">&quot;sorry ,没有找到 &quot;</span> + findName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-8-二维数组"><a href="#3-8-二维数组" class="headerlink" title="3.8 二维数组"></a>3.8 二维数组</h2><h3 id="3-8-1-创建二维数组"><a href="#3-8-1-创建二维数组" class="headerlink" title="3.8.1 创建二维数组"></a>3.8.1 创建二维数组</h3><ol><li><strong>动态初始化</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[][] 数组名=<span class="keyword">new</span> 数据类型[大小];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">4</span>]; </span><br><span class="line">数据类型[] 数组名;</span><br><span class="line">数组名=<span class="keyword">new</span> 数据类型[大小];</span><br><span class="line"><span class="type">int</span>[][] x;</span><br><span class="line">x=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][];</span><br></pre></td></tr></table></figure><p>暂时无法在飞书文档外展示此内容</p><ol><li><strong>静态初始化</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[][] 数组名 = &#123;&#123;第<span class="number">0</span>行初始化&#125;，&#123;第<span class="number">1</span>行初始化&#125;，&#123;第<span class="number">2</span>行初始化&#125;，...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[][] arr = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>暂时无法在飞书文档外展示此内容</p><h3 id="3-8-2-二维数组赋值机制"><a href="#3-8-2-二维数组赋值机制" class="headerlink" title="3.8.2 二维数组赋值机制"></a>3.8.2 二维数组赋值机制</h3><p>暂时无法在飞书文档外展示此内容</p><h3 id="3-8-3-杨辉三角"><a href="#3-8-3-杨辉三角" class="headerlink" title="3.8.3 杨辉三角"></a>3.8.3 杨辉三角</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YangHui</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][];</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = <span class="keyword">new</span> <span class="title class_">int</span>[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">                <span class="comment">//每行第一个元素和最后一个元素为1</span></span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span> || j == arr[i].length - <span class="number">1</span>) &#123;</span><br><span class="line">                    arr[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//其他元素为上一行的两数相加</span></span><br><span class="line">                    arr[i][j] = arr[i - <span class="number">1</span>][j - <span class="number">1</span>] + arr[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历输出二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//输出空格</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> arr.length - <span class="number">1</span> - i; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">                System.out.print(arr[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">          <span class="number">1</span> </span><br><span class="line">         <span class="number">1</span> <span class="number">1</span> </span><br><span class="line">        <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> </span><br><span class="line">       <span class="number">1</span> <span class="number">3</span> <span class="number">3</span> <span class="number">1</span> </span><br><span class="line">      <span class="number">1</span> <span class="number">4</span> <span class="number">6</span> <span class="number">4</span> <span class="number">1</span> </span><br><span class="line">     <span class="number">1</span> <span class="number">5</span> <span class="number">10</span> <span class="number">10</span> <span class="number">5</span> <span class="number">1</span> </span><br><span class="line">    <span class="number">1</span> <span class="number">6</span> <span class="number">15</span> <span class="number">20</span> <span class="number">15</span> <span class="number">6</span> <span class="number">1</span> </span><br><span class="line">   <span class="number">1</span> <span class="number">7</span> <span class="number">21</span> <span class="number">35</span> <span class="number">35</span> <span class="number">21</span> <span class="number">7</span> <span class="number">1</span> </span><br><span class="line">  <span class="number">1</span> <span class="number">8</span> <span class="number">28</span> <span class="number">56</span> <span class="number">70</span> <span class="number">56</span> <span class="number">28</span> <span class="number">8</span> <span class="number">1</span> </span><br><span class="line"> <span class="number">1</span> <span class="number">9</span> <span class="number">36</span> <span class="number">84</span> <span class="number">126</span> <span class="number">126</span> <span class="number">84</span> <span class="number">36</span> <span class="number">9</span> <span class="number">1</span> </span><br></pre></td></tr></table></figure><h1 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4.运算符"></a>4.运算符</h1><h2 id="4-1-算术运算符"><a href="#4-1-算术运算符" class="headerlink" title="4.1 算术运算符"></a>4.1 算术运算符</h2><p>表格中的实例假设整数变量A的值为10，变量B的值为20</p><table><thead><tr><th>运算符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>+</td><td>加法 - 相加运算符两侧的值</td><td>A + B 等于 30</td></tr><tr><td>-</td><td>减法 - 左操作数减去右操作数</td><td>A – B 等于 -10</td></tr><tr><td>*</td><td>乘法 - 相乘操作符两侧的值</td><td>A * B等于200</td></tr><tr><td>&#x2F;</td><td>除法 - 左操作数除以右操作数</td><td>B &#x2F; A等于2</td></tr><tr><td>％</td><td>取余 - 左操作数除以右操作数的余数</td><td>B%A等于0</td></tr><tr><td>++</td><td>自增: 操作数的值增加1</td><td>B++ 或 ++B 等于 21</td></tr><tr><td>–</td><td>自减: 操作数的值减少1</td><td>B– 或 –B 等于 19</td></tr></tbody></table><p><strong>自增自减运算符</strong></p><ol><li>当++出现在变量前，会<code>先自加一</code>，在做赋值运算</li><li>当++出现在变量后，会<code>先做赋值运算</code>，再自加1</li><li>当–出现在变量前，会<code>先自减一</code>，在做赋值运算</li><li>当–出现在变量后，会<code>先做赋值运算</code>，再自减1</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArithmeticOperator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//++的使用</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        i++;<span class="comment">//自增 等价与i=i+1;</span></span><br><span class="line">        ++i;<span class="comment">//自增 等价与i=i+1;</span></span><br><span class="line">        System.out.println(i);<span class="comment">//12</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        作为表达式使用</span></span><br><span class="line"><span class="comment">        前++：++i先只增后赋值</span></span><br><span class="line"><span class="comment">        后++；i++先赋值后自增</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> ++a;</span><br><span class="line">        System.out.println(b);<span class="comment">//9</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j++;</span><br><span class="line">        System.out.println(k);<span class="comment">//8</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        i = i++;</span><br><span class="line">        <span class="comment">//规则使用临时变量:</span></span><br><span class="line">        <span class="comment">//temp=i;</span></span><br><span class="line">        <span class="comment">//i=i+1;</span></span><br><span class="line">        <span class="comment">//i=temp</span></span><br><span class="line">        System.out.println(i);<span class="comment">//1</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">                 i=++i; </span><br><span class="line">        <span class="comment">//规则使用临时变量: </span></span><br><span class="line">        <span class="comment">// i=i+1;</span></span><br><span class="line">        <span class="comment">//temp=i;</span></span><br><span class="line">        <span class="comment">//i=temp;</span></span><br><span class="line">                 System.out.println(i); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-关系运算符"><a href="#4-2-关系运算符" class="headerlink" title="4.2 关系运算符"></a>4.2 关系运算符</h2><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&#x3D;&#x3D;</td><td>等于</td></tr><tr><td>!&#x3D;</td><td>不等于</td></tr></tbody></table><p><em><strong>注意</strong></em>：所有的关系运算符的运算结果都是布尔类型，<code>不是true就是false</code>，不可能是其他值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">     <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">     System.out.println(<span class="string">&quot;a == b = &quot;</span> + (a == b) );<span class="comment">//F</span></span><br><span class="line">     System.out.println(<span class="string">&quot;a != b = &quot;</span> + (a != b) );<span class="comment">//T</span></span><br><span class="line">     System.out.println(<span class="string">&quot;a &gt; b = &quot;</span> + (a &gt; b) );<span class="comment">//F</span></span><br><span class="line">     System.out.println(<span class="string">&quot;a &lt; b = &quot;</span> + (a &lt; b) );<span class="comment">//T</span></span><br><span class="line">     System.out.println(<span class="string">&quot;b &gt;= a = &quot;</span> + (b &gt;= a) );<span class="comment">//T</span></span><br><span class="line">     System.out.println(<span class="string">&quot;b &lt;= a = &quot;</span> + (b &lt;= a) );<span class="comment">//F</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-逻辑运算符"><a href="#4-3-逻辑运算符" class="headerlink" title="4.3 逻辑运算符"></a>4.3 逻辑运算符</h2><table><thead><tr><th align="left">操作符</th><th align="left">描述</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">＆</td><td align="left">逻辑与（并且）</td><td align="left">当两边都为true，结果为true,否则为false</td></tr><tr><td align="left">|</td><td align="left">逻辑或（或者）</td><td align="left">有一边是true，结果为true，否则为false</td></tr><tr><td align="left">^</td><td align="left">逻辑异或</td><td align="left">当两边的不同时，结果为true，否则为false</td></tr><tr><td align="left">&amp;&amp;</td><td align="left">短路与（并且）</td><td align="left">当两边都为true，结果为true,否则为false</td></tr><tr><td align="left">||</td><td align="left">短路或（或者）</td><td align="left">有一边是true，结果为true，否则为false</td></tr><tr><td align="left">!</td><td align="left">逻辑非（取反）</td><td align="left">false取反就是true，true取反就是false&#x3D;</td></tr></tbody></table><p><strong>注意</strong></p><ol><li>使用短路与 &amp;&amp; 的时候，当左边的表达式为<code>false</code>的时候，右边的表达式不执行</li><li>使用短路或 || 的时候当左边的表达式结果是<code>true</code>的时候，右边的表达式不执行</li><li>逻辑运算符两边要求都是布尔类型，并且最终的运算结果也是布尔类型</li></ol><h2 id="4-4-赋值运算符"><a href="#4-4-赋值运算符" class="headerlink" title="4.4 赋值运算符"></a>4.4 赋值运算符</h2><table><thead><tr><th align="left">运算符</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">&#x3D;</td><td align="left">赋值</td></tr><tr><td align="left">+&#x3D;</td><td align="left">加等（原先的基础上加上这个数）</td></tr><tr><td align="left">-&#x3D;</td><td align="left">减等（原先的基础上减上这个数）</td></tr><tr><td align="left">*&#x3D;</td><td align="left">乘等（原先的基础上乘上这个数）</td></tr><tr><td align="left">&#x2F;&#x3D;</td><td align="left">除等（原先的基础上除上这个数）</td></tr><tr><td align="left">%&#x3D;</td><td align="left">模等（原先的基础上模上这个数）</td></tr></tbody></table><p>使用<code>扩展赋值运算符</code>的时候，永远都<code>不会改变</code>运算结果类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">n1 += <span class="number">4</span>;<span class="comment">// n1 = n1 + 4;</span></span><br><span class="line">System.out.println(n1); <span class="comment">// 14</span></span><br><span class="line">n1 /= <span class="number">3</span>;<span class="comment">// n1 = n1 / 3;//4</span></span><br><span class="line">System.out.println(n1); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//复合赋值运算符会进行类型转换</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">b += <span class="number">2</span>; <span class="comment">// 等价 b = (byte)(b + 2);</span></span><br><span class="line">b++; <span class="comment">// b = (byte)(b+1);</span></span><br></pre></td></tr></table></figure><h2 id="4-5-三元运算符"><a href="#4-5-三元运算符" class="headerlink" title="4.5 三元运算符"></a>4.5 三元运算符</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">条件表达式 ？表达式<span class="number">1</span> ：表达式<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>运算规则：</p><ol><li>如果条件表达式为true，运算后的结果是表达式1</li><li>如果条件表达式为false，运算后的结果是表达式2</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorDemo12</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//需求：求两个数的较大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//格式：关系表达式 ？ 表达式1 ： 表达式2 ；</span></span><br><span class="line">        <span class="comment">//注意点：</span></span><br><span class="line">        <span class="comment">//三元运算符的最终结果一定要被使用。</span></span><br><span class="line">        <span class="comment">//要么赋值给一个变量，要么直接输出。</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span>  a &gt; b ? a : b ;</span><br><span class="line">        System.out.println(max);<span class="comment">//20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(a &gt; b ? a : b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-6-运算符的优先级"><a href="#4-6-运算符的优先级" class="headerlink" title="4.6 运算符的优先级"></a>4.6 运算符的优先级</h2><p>括号级别最高，逗号级别最低，单目 &gt; 算术 &gt; 位移 &gt; 关系 &gt; 逻辑 &gt; 三目 &gt; 赋值</p><table><thead><tr><th align="left">优先级</th><th align="left">运算符</th><th align="left">结合性</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">( )　[ ] 　.</td><td align="left">从左到右</td></tr><tr><td align="left">2</td><td align="left">! 　~　 ++　 –</td><td align="left">从右到左</td></tr><tr><td align="left">3</td><td align="left">*　 &#x2F;　 %</td><td align="left">从左到右</td></tr><tr><td align="left">4</td><td align="left">+　 -</td><td align="left">从左到右</td></tr><tr><td align="left">5</td><td align="left">&lt;&lt; 　&gt;&gt;　 &gt;&gt;&gt;</td><td align="left">从左到右</td></tr><tr><td align="left">6</td><td align="left">&lt; 　&lt;&#x3D;　 &gt; 　&gt;&#x3D;　 instanceof</td><td align="left">从左到右</td></tr><tr><td align="left">7</td><td align="left">&#x3D;&#x3D; 　!&#x3D;</td><td align="left">从左到右</td></tr><tr><td align="left">8</td><td align="left">&amp;</td><td align="left">从左到右</td></tr><tr><td align="left">9</td><td align="left">^</td><td align="left">从左到右</td></tr><tr><td align="left">10</td><td align="left">&#96;</td><td align="left">&#96;</td></tr><tr><td align="left">11</td><td align="left">&amp;&amp;</td><td align="left">从左到右</td></tr><tr><td align="left">12</td><td align="left">&#96;</td><td align="left"></td></tr><tr><td align="left">13</td><td align="left">? :</td><td align="left">从左到右</td></tr><tr><td align="left">14</td><td align="left">&#x3D; 　+&#x3D; 　-&#x3D; 　*&#x3D;　 &#x2F;&#x3D;　 %&#x3D;　 &amp;&#x3D;　 &#96;</td><td align="left">&#x3D;&#96;　 ^&#x3D;　 ~&#x3D; 　&lt;&lt;&#x3D; 　&gt;&gt;&#x3D;　 &gt;&gt;&gt;&#x3D;</td></tr><tr><td align="left">15</td><td align="left">，</td><td align="left">从右到左</td></tr></tbody></table><h2 id="4-7-标识符"><a href="#4-7-标识符" class="headerlink" title="4.7 标识符"></a>4.7 标识符</h2><ol><li>Java对各种变量，方法和类等命名时使用的字符序列称为标识符</li><li>凡是自己可以起名字的地方都叫标识符</li></ol><p><strong>标识符的命名规则：</strong></p><ol><li>由26个英文字母大小写0-9，下划线_ 或$组成</li><li>数字不可以开头</li><li>不可以使用关键字和保留字，但能包含关键字和保留字</li><li>Java中严格区分大小写，长度无限制</li><li>标识符不能包含空格</li></ol><p><strong>标识符的命名规范:</strong></p><ol><li>包名：多单词组成时所有字母都小写</li><li>类名，接口名：多单词组成时，所有单词都首字母大写</li><li>变量名，方法名：多单词组成时，第一个单词首字母小写，第二单词开始每个单词首字母大写</li><li>常量名：所有字母都大写，多单词时每个单词用下划线连接</li></ol><h2 id="4-8-关键字和保留字"><a href="#4-8-关键字和保留字" class="headerlink" title="4.8 关键字和保留字"></a>4.8 关键字和保留字</h2><p><strong>关键字：</strong></p><p>Java 语言目前定义了 51 个关键字，这些关键字不能作为变量名、类名和方法名来使用</p><table><thead><tr><th align="left">关键字</th><th></th></tr></thead><tbody><tr><td align="left">数据类型</td><td>boolean、int、long、short、byte、float、double、char、class、interface、enum、void</td></tr><tr><td align="left">流程控制</td><td>if、else、do、while、for、switch、case、default、break、continue、return</td></tr><tr><td align="left">异常处理</td><td>try、catch、finally、throw、throws</td></tr><tr><td align="left">修饰符</td><td>public、protected、private、final、void、static、strict、abstract、transient、synchronized、volatile、native</td></tr><tr><td align="left">类与类之间关系</td><td>extends、implements</td></tr><tr><td align="left">建立实例及引用实例</td><td>this、supper、instanceof、new</td></tr><tr><td align="left">导包</td><td>package、impor</td></tr></tbody></table><p><strong>保留字：</strong></p><p>保留字：Java版本尚未使用，但以后版本可能会作为关键字使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">goto</span>、const、byValue、cast、future、 generic、 inner、 operator、 outer、 rest、 <span class="keyword">var</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>Java中true、false、friendly和null不属于关键字，也不是保留字，它们只是显式常量值，但是你在程序中不能使用它们作为标识符</li><li>Jxxxava关键字和保留字都是小写。即null是关键字，NULL不是关键字；TRUE、FALSE也不是关键字</li></ul><h2 id="4-9-进制"><a href="#4-9-进制" class="headerlink" title="4.9 进制"></a>4.9 进制</h2><p><strong>介绍</strong></p><ol><li>二进制：0,1，满2进1，以0b或0B开头</li><li>十进制：0-9，满10进1</li><li>八进制：0-7，满8进1，以数字0开头</li><li>十六进制：0-9以及A(10)~F(15),满16进1，以0x开头</li></ol><p><strong>N进制转十进制</strong></p><ol><li>二进制转十进制</li></ol><p><img src="https://pic1.imgdb.cn/item/680953bc58cb8da5c8c6c815.png" alt="img"></p><ol><li>八进制换十进制</li></ol><p><img src="https://pic1.imgdb.cn/item/680953bd58cb8da5c8c6c817.png" alt="img"></p><ol><li>十六进制转十进制</li></ol><p><img src="https://pic1.imgdb.cn/item/680953bd58cb8da5c8c6c818.png" alt="img"></p><p><strong>十进制转n进制</strong></p><ol><li>十进制转二进制</li><li>规则：将该数不断除以 2，直到商为 0 为止，然后将每步得到的余数倒过来，就是对应的二进制</li><li>十进制转八进制</li><li>规则：将该数不断除以 8，直到商为 0 为止，然后将每步得到的余数倒过来，就是对应的八进制</li><li>十进制转十六进制 规则：将该数不断除以 16，直到商为 0 为止，然后将每步得到的余数倒过来，就是对应的十六进制</li></ol><p><strong>n进制转n进制</strong></p><ol><li>二进制转八进制</li><li>规则：从低位开始,将二进制数每三位一组，转成对应的八进制数即可。 案例：请将 ob11010101 转成八进制 ob11(3)010(2)101(5) &#x3D;&gt; 0325</li><li>二进制转十六进制</li><li>规则：从低位开始，将二进制数每四位一组，转成对应的十六进制数即可。 案例：请将 ob11010101 转成十六进制 ob1101(D)0101(5) &#x3D; 0xD5</li><li>八进制转二进制</li><li>规则：将八进制数每 1 位，转成对应的一个 3 位的二进制数即可。 案例：请将 0237 转成二进制 02(010)3(011)7(111) &#x3D; 0b10011111</li><li>十六进制转二进制</li><li>规则：将十六进制数每 1 位，转成对应的 4 位的一个二进制数即可。 案例：请将 0x23B 转成二进制 0x2(0010)3(0011)B(1011) &#x3D; 0b001000111011</li></ol><h2 id="4-10-原码，反码，补码"><a href="#4-10-原码，反码，补码" class="headerlink" title="4.10 原码，反码，补码"></a>4.10 原码，反码，补码</h2><ol><li>二进制的最高位是符号位：0表示负数</li><li>正数的原码，反码，补码都一样(三码合一)</li><li>负数的反码&#x3D;它的原码符号位不变，其它位取反（ 0 -&gt; 1 ， 1 -&gt; 0 )</li><li>负数的补码&#x3D;它的反码+ 1 ，负数的反码&#x3D;负数的补码- 1</li><li>0 的反码，补码都是 0</li><li>j ava 没有无符号数，换言之， java 中的数都是有符号的</li><li>在计算机运算的时候，都是以补码的方式来运算的</li><li>当我们看运算结果的时候，要看他的原码（重点）</li></ol><h2 id="4-11位运算"><a href="#4-11位运算" class="headerlink" title="4.11位运算"></a>4.11位运算</h2><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">＆</td><td align="left">如果相对应位都是1，则结果为1，否则为0</td></tr><tr><td align="left">|</td><td align="left">如果相对应位都是 0，则结果为 0，否则为 1</td></tr><tr><td align="left">^</td><td align="left">如果相对应位值相同，则结果为0，否则为1</td></tr><tr><td align="left">〜</td><td align="left">按位取反运算符翻转操作数的每一位，即0变成1，1变成0</td></tr><tr><td align="left">&lt;&lt;</td><td align="left">按位左移运算符。左操作数按位左移右操作数指定的位数</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">按位右移运算符。左操作数按位右移右操作数指定的位数</td></tr><tr><td align="left">&gt;&gt;&gt;</td><td align="left">按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充</td></tr></tbody></table><ol><li><strong>&amp;按位与</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">                System.out.println(<span class="number">2</span> &amp; <span class="number">3</span>);<span class="comment">//结果为2</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2的补码   00000000 00000000 00000000 00000010</span></span><br><span class="line"><span class="comment">//3的补码   00000000 00000000 00000000 00000011 </span></span><br><span class="line"><span class="comment">//&amp;运算后   00000000 00000000 00000000 00000010 </span></span><br><span class="line"><span class="comment">//结果就是  2</span></span><br></pre></td></tr></table></figure><ol><li><strong>|按位或</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">                System.out.println(<span class="number">5</span> | <span class="number">3</span>);<span class="comment">//结果为7</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5转换为二进制：0000 0000 0000 0000 0000 0000 0000 0101</span></span><br><span class="line"><span class="comment">//3转换为二进制：0000 0000 0000 0000 0000 0000 0000 0011</span></span><br><span class="line"><span class="comment">//7按位或运算后：0000 0000 0000 0000 0000 0000 0000 0111</span></span><br></pre></td></tr></table></figure><ol><li><strong>~按位非</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">                System.out.println(~-<span class="number">2</span>);<span class="comment">//结果为1</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 先得到 -2的原码  10000000 00000000 00000000 00000010</span></span><br><span class="line"><span class="comment">// -2的 反码             11111111 11111111 11111111 11111101</span></span><br><span class="line"><span class="comment">// -2的 补码       11111111 11111111 11111111 11111110</span></span><br><span class="line"><span class="comment">//~-2操作          00000000 00000000 00000000 00000001  </span></span><br><span class="line"><span class="comment">//运算后的原码 就是 00000000 00000000 00000000 00000001 =&gt; 1</span></span><br></pre></td></tr></table></figure><ol><li>^<strong>按位异或</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">                System.out.println(<span class="number">5</span> ^ <span class="number">3</span>);<span class="comment">//结果为6</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5转换为二进制：0000 0000 0000 0000 0000 0000 0000 0101</span></span><br><span class="line"><span class="comment">//3转换为二进制：0000 0000 0000 0000 0000 0000 0000 0011</span></span><br><span class="line"><span class="comment">//7按位或运算后：0000 0000 0000 0000 0000 0000 0000 0111</span></span><br></pre></td></tr></table></figure><ol><li><strong>&lt;&lt;左位移运算符</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">                System.out.println(<span class="number">5</span>&lt;&lt;<span class="number">2</span>);<span class="comment">//运行结果是20</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//0000 0000 0000 0000 0000 0000 0000 0101 左移2位，低位补0：</span></span><br><span class="line"><span class="comment">//0000 0000 0000 0000 0000 0000 0001 0100 换算成10进制为20 </span></span><br><span class="line"><span class="comment">//本质 5 * 2 * 2 = 20</span></span><br></pre></td></tr></table></figure><ol><li><strong>&gt;&gt;右位移运算符</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">                System.out.println(<span class="number">5</span>&gt;&gt;<span class="number">2</span>);<span class="comment">//运行结果是1</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//0000 0000 0000 0000 0000 0000 0000 0101 右移2位，高位补0</span></span><br><span class="line"><span class="comment">//0000 0000 0000 0000 0000 0000 0000 0001</span></span><br><span class="line"><span class="comment">//本质 5 /2 / 2 = 1</span></span><br></pre></td></tr></table></figure><ol><li><strong>&gt;&gt;&gt;无符号运算符</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">                System.out.println(<span class="number">5</span>&gt;&gt;&gt;<span class="number">3</span>);<span class="comment">//结果是0</span></span><br><span class="line">                System.out.println(-<span class="number">5</span>&gt;&gt;&gt;<span class="number">3</span>);<span class="comment">//结果是536870911</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5换算成二进制： 0000 0000 0000 0000 0000 0000 0000 0101</span></span><br><span class="line"><span class="comment">//-5换算成二进制： 1111 1111 1111 1111 1111 1111 1111 1011</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5无符号右移3位后结果为0，0的二进制为： 0000 0000 0000 0000 0000 0000 0000 0000 // (用0进行补位)</span></span><br><span class="line"><span class="comment">//-5无符号右移3位后的结果 536870911 换算成二进制： 0001 1111 1111 1111 1111 1111 1111 1111 // (用0进行补位)</span></span><br></pre></td></tr></table></figure><h1 id="5-程序控制流程"><a href="#5-程序控制流程" class="headerlink" title="5.程序控制流程"></a>5.程序控制流程</h1><h2 id="5-1-顺序语句"><a href="#5-1-顺序语句" class="headerlink" title="5.1 顺序语句"></a>5.1 顺序语句</h2><p>顺序结构就是程序从上到下逐行执行，表达式语句都是顺序执行的。并且上一行对某个变量的修改对下一行会产生影响</p><p>暂时无法在飞书文档外展示此内容</p><p>Java 中定义变量时采用合法的<code>前向引用</code>。如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> num1 + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误形式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> num1 + <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2-选择结构语句"><a href="#5-2-选择结构语句" class="headerlink" title="5.2 选择结构语句"></a>5.2 选择结构语句</h2><p>if 条件判断结构</p><p><strong>语法格式：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式或<span class="type">boolean</span>类型的值)｛</span><br><span class="line">          语句块;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p><strong>执行流程：</strong></p><ol><li>首先判断条件表达式的值</li><li>如果是 true，则执行语句块</li><li>如果为 false，则不执行语句块</li></ol><p>暂时无法在飞书文档外展示此内容</p><p><strong>案例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">if01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//编写一个程序,可以输入人的年龄,如果该同志的年龄大于 18 岁</span></span><br><span class="line">        <span class="comment">// 则输出 &quot;你年龄大于 18,要对自己的行为负责,送入监狱&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">garde</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="keyword">if</span> (garde &gt; <span class="number">18</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你年龄大于18，要对自己的行为负责，送入监狱&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="If…else-语句"><a href="#If…else-语句" class="headerlink" title="If…else 语句"></a>If…else 语句</h3><p><strong>语法格式：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式) &#123; </span><br><span class="line">          语句块<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          语句块<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行流程：</strong></p><ol><li>首先判断条件表达式看其结果是 true 还是 false</li><li>如果是 true 就执行语句块 1</li><li>如果是 false 就执行语句块 2</li></ol><p>暂时无法在飞书文档外展示此内容</p><p><strong>案例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">if02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//编写一个程序,可以输入人的年龄,如果该同志的年龄大于 18 岁,</span></span><br><span class="line">        <span class="comment">// 则输出 &quot;你年龄大于 18,要对自己的行为负责, 送入监狱&quot;</span></span><br><span class="line">        <span class="comment">// 否则 ,输出&quot;你的年龄不大这次放过你了.&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">grade</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (grade &gt; <span class="number">18</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你的年龄大于18，要对自己的行为负责，送入监狱&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你的年龄不大这次放过你了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="If…-else-If…-else-语句"><a href="#If…-else-If…-else-语句" class="headerlink" title="If….else If….else 语句"></a>If….else If….else 语句</h3><p><strong>语法格式：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>说明：一旦条件表达式为true，则进入执行相应的语句块。执行完对应的语句块之后，就跳出当前结构</p><p><strong>执行流程：</strong></p><ol><li>首先判断关系表达式1看其结果是true还是false</li><li>如果是true就执行语句块1，然后结束当前多分支</li><li>如果是false就继续判断关系表达式2看其结果是true还是false</li><li>如果是true就执行语句块2，然后结束当前多分支</li><li>如果是false就继续判断关系表达式…看其结果是true还是false</li></ol><p>暂时无法在飞书文档外展示此内容</p><p><strong>案例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">if03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">cent</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cent &gt;= <span class="number">1</span> &amp;&amp; cent &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cent == <span class="number">100</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;信用极好&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cent &gt; <span class="number">80</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;信用优秀&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cent &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;信用一般&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;信用不及格&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="If…-else嵌套"><a href="#If…-else嵌套" class="headerlink" title="If….else嵌套"></a>If….else嵌套</h3><p>在一个分支结构中又完整的嵌套了另一个完整的分支结构，里面的分支的结构称为内层分支外面的分支结构称为外层分支，不要超过三层</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>()&#123;</span><br><span class="line">    <span class="keyword">if</span>()&#123;</span><br><span class="line">        <span class="keyword">if</span>-<span class="keyword">else</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>-<span class="keyword">else</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例：</strong></p><p>参加歌手比赛，如果初赛成绩大于 8.0 进入决赛，否则提示淘汰。并且根据性别提示进入男子组或女子组，输入成绩和性别，进行判断和输出信息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Nestedif</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">double</span> <span class="variable">score</span> <span class="operator">=</span> sc.nextDouble();</span><br><span class="line">        <span class="type">char</span> <span class="variable">gender</span> <span class="operator">=</span> sc.next().charAt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (score &gt; <span class="number">8.0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (gender == <span class="string">&#x27;男&#x27;</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;进入决赛&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (gender == <span class="string">&#x27;女&#x27;</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;进入决赛&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;性别有误&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;淘汰&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-3-switch条件语句"><a href="#5-3-switch条件语句" class="headerlink" title="5.3 switch条件语句"></a>5.3 switch条件语句</h2><p><strong>语法格式：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                语句体<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                语句体<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">                语句体n+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行流程：</strong></p><ol><li>首先计算出表达式的值</li><li>和case依次比较，表达式的值与case匹配就执行相应语句体</li><li>break是退出switch语句</li><li>最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分</li></ol><p><strong>案例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Switch01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> sc.next().charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;星期一&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;星期二&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;星期三&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;星期四&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;星期五&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;星期六&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;星期七&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;请输入正确的字符&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>switch语句和if语句选择:</strong></p><ol><li>如果判断的具体数值不多，而且符合byte，short，interesting，char，enum，String这六种类型，建议使用switch语句</li><li>其他情况：对区间判断，对结果为Boolean类型判断，使用if，if的使用范围更广</li></ol><h2 id="5-4-循环结构语句"><a href="#5-4-循环结构语句" class="headerlink" title="5.4 循环结构语句"></a>5.4 循环结构语句</h2><h3 id="5-5-For循环"><a href="#5-5-For循环" class="headerlink" title="5.5 For循环"></a>5.5 For循环</h3><p><strong>语法格式：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="number">1</span>循环变量初始化:<span class="number">2</span>循环条件:<span class="number">4</span>循环变量迭代)&#123;</span><br><span class="line">        <span class="number">3</span>循环体部分；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行过程：①-②-③-④-②-③-④-②-③-④-…-②</strong></p><p>暂时无法在飞书文档外展示此内容</p><p><strong>案例:</strong></p><p>打印 1~100 之间所有是 9 的倍数的整数，统计个数 及 总和</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForExercise01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">9</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;个数为：&quot;</span> + count);</span><br><span class="line">        System.out.println(<span class="string">&quot;总和：&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-6-While循环"><a href="#5-6-While循环" class="headerlink" title="5.6 While循环"></a>5.6 While循环</h3><h3 id="5-7-Do…while循环"><a href="#5-7-Do…while循环" class="headerlink" title="5.7 Do…while循环"></a>5.7 Do…while循环</h3><h3 id="5-8-多重循环"><a href="#5-8-多重循环" class="headerlink" title="5.8 多重循环"></a>5.8 多重循环</h3><ol><li>将一个循环放在另一个循环体内，就形成了嵌套循环，其中for,while,do…while循环均可以作为外层循环和内层循环</li><li>实质上，嵌套循环就是把内层循环当成外层循环的循环体，当只有内层循环的循环条件为false时才会跳出内层循环，才可结束外层循环的当次循环，开始下一次的循环</li><li>设外层循环次数为m次，内层为n次，则内层循环体实际上需要执行m*n次</li></ol><p><strong>案例：</strong></p><ol><li>九九乘法表</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MulForExercise02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//九九乘法表</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                System.out.print(j + <span class="string">&quot; * &quot;</span> + i + <span class="string">&quot; = &quot;</span> + i * j + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span>×<span class="number">1</span>=<span class="number">1</span>   </span><br><span class="line"><span class="number">1</span>×<span class="number">2</span>=<span class="number">2</span>   <span class="number">2</span>×<span class="number">2</span>=<span class="number">4</span>   </span><br><span class="line"><span class="number">1</span>×<span class="number">3</span>=<span class="number">3</span>   <span class="number">2</span>×<span class="number">3</span>=<span class="number">6</span>   <span class="number">3</span>×<span class="number">3</span>=<span class="number">9</span>   </span><br><span class="line"><span class="number">1</span>×<span class="number">4</span>=<span class="number">4</span>   <span class="number">2</span>×<span class="number">4</span>=<span class="number">8</span>   <span class="number">3</span>×<span class="number">4</span>=<span class="number">12</span>  <span class="number">4</span>×<span class="number">4</span>=<span class="number">16</span>  </span><br><span class="line"><span class="number">1</span>×<span class="number">5</span>=<span class="number">5</span>   <span class="number">2</span>×<span class="number">5</span>=<span class="number">10</span>  <span class="number">3</span>×<span class="number">5</span>=<span class="number">15</span>  <span class="number">4</span>×<span class="number">5</span>=<span class="number">20</span>  <span class="number">5</span>×<span class="number">5</span>=<span class="number">25</span>  </span><br><span class="line"><span class="number">1</span>×<span class="number">6</span>=<span class="number">6</span>   <span class="number">2</span>×<span class="number">6</span>=<span class="number">12</span>  <span class="number">3</span>×<span class="number">6</span>=<span class="number">18</span>  <span class="number">4</span>×<span class="number">6</span>=<span class="number">24</span>  <span class="number">5</span>×<span class="number">6</span>=<span class="number">30</span>  <span class="number">6</span>×<span class="number">6</span>=<span class="number">36</span>  </span><br><span class="line"><span class="number">1</span>×<span class="number">7</span>=<span class="number">7</span>   <span class="number">2</span>×<span class="number">7</span>=<span class="number">14</span>  <span class="number">3</span>×<span class="number">7</span>=<span class="number">21</span>  <span class="number">4</span>×<span class="number">7</span>=<span class="number">28</span>  <span class="number">5</span>×<span class="number">7</span>=<span class="number">35</span>  <span class="number">6</span>×<span class="number">7</span>=<span class="number">42</span>  <span class="number">7</span>×<span class="number">7</span>=<span class="number">49</span>  </span><br><span class="line"><span class="number">1</span>×<span class="number">8</span>=<span class="number">8</span>   <span class="number">2</span>×<span class="number">8</span>=<span class="number">16</span>  <span class="number">3</span>×<span class="number">8</span>=<span class="number">24</span>  <span class="number">4</span>×<span class="number">8</span>=<span class="number">32</span>  <span class="number">5</span>×<span class="number">8</span>=<span class="number">40</span>  <span class="number">6</span>×<span class="number">8</span>=<span class="number">48</span>  <span class="number">7</span>×<span class="number">8</span>=<span class="number">56</span>  <span class="number">8</span>×<span class="number">8</span>=<span class="number">64</span>  </span><br><span class="line"><span class="number">1</span>×<span class="number">9</span>=<span class="number">9</span>   <span class="number">2</span>×<span class="number">9</span>=<span class="number">18</span>  <span class="number">3</span>×<span class="number">9</span>=<span class="number">27</span>  <span class="number">4</span>×<span class="number">9</span>=<span class="number">36</span>  <span class="number">5</span>×<span class="number">9</span>=<span class="number">45</span>  <span class="number">6</span>×<span class="number">9</span>=<span class="number">54</span>  <span class="number">7</span>×<span class="number">9</span>=<span class="number">63</span>  <span class="number">8</span>×<span class="number">9</span>=<span class="number">72</span>  <span class="number">9</span>×<span class="number">9</span>=<span class="number">81</span></span><br></pre></td></tr></table></figure><ol><li>空心金字塔</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MulForExercise03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">            <span class="comment">//空格</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= num - i; k++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出 * 号</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= (<span class="number">2</span> * i) - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="comment">//当前行的第一个位置是*,最后一个位置也是*, 最后一层全部 *</span></span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">1</span> || j == (<span class="number">2</span> * i) - <span class="number">1</span> || i == num) &#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//其他情况输出空格</span></span><br><span class="line">                    System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//每打印完一层的*后，就换行</span></span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">5</span></span><br><span class="line">    *</span><br><span class="line">   * *</span><br><span class="line">  *   *</span><br><span class="line"> *     *</span><br><span class="line">*********</span><br></pre></td></tr></table></figure><h2 id="5-9-跳转控制语句"><a href="#5-9-跳转控制语句" class="headerlink" title="5.9 跳转控制语句"></a>5.9 跳转控制语句</h2><h3 id="5-9-1-Break"><a href="#5-9-1-Break" class="headerlink" title="5.9.1 Break"></a>5.9.1 Break</h3><ul><li>break语句用于终止某个语句块的执行，一般使用在switch语句或者循环[for,while,do-while]中</li><li>break 跳出最里层的循环，并且继续执行该循环下面的语句</li></ul><p><strong>案例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">int</span> [] numbers = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> x : numbers ) &#123;</span><br><span class="line">         <span class="comment">// x 等于 30 时跳出循环</span></span><br><span class="line">         <span class="keyword">if</span>( x == <span class="number">30</span> ) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.print( x );</span><br><span class="line">         System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><h3 id="5-9-2-Continue"><a href="#5-9-2-Continue" class="headerlink" title="5.9.2 Continue"></a>5.9.2 Continue</h3><ul><li>continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代</li><li>在 for 循环中，continue 语句使程序立即跳转到更新语句</li><li>在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句</li></ul><p>案例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">int</span> [] numbers = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> x : numbers ) &#123;</span><br><span class="line">         <span class="keyword">if</span>( x == <span class="number">30</span> ) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.print( x );</span><br><span class="line">         System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">40</span></span><br><span class="line"><span class="number">50</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
