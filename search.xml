<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>”Java面向对象基础二“</title>
      <link href="/2025/06/09/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E4%BA%8C/"/>
      <url>/2025/06/09/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="类变量和类方法"><a href="#类变量和类方法" class="headerlink" title="类变量和类方法"></a>类变量和类方法</h1><h2 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol><li>类变量也叫静态变量&#x2F;静态属性，是该类的所有对象共享的变量，任何一个该类的对象去访问它时，取到的都是相同的值</li><li>同样任何一个该类的对象去修改它时，修改的也是同一个变量</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChildGame</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个变量 count, 统计有多少小孩加入了游戏</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Child</span> <span class="variable">child1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;白骨精&quot;</span>);</span><br><span class="line">        child1.join();</span><br><span class="line">        <span class="comment">//count++;</span></span><br><span class="line">        child1.count++;</span><br><span class="line"></span><br><span class="line">        <span class="type">Child</span> <span class="variable">child2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;狐狸精&quot;</span>);</span><br><span class="line">        child2.join();</span><br><span class="line">        <span class="comment">//count++;</span></span><br><span class="line">        child2.count++;</span><br><span class="line"></span><br><span class="line">        <span class="type">Child</span> <span class="variable">child3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;老鼠精&quot;</span>);</span><br><span class="line">        child3.join();</span><br><span class="line">        <span class="comment">//count++;</span></span><br><span class="line">        child3.count++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//===========</span></span><br><span class="line">        <span class="comment">//类变量，可以通过类名来访问</span></span><br><span class="line">        System.out.println(<span class="string">&quot;共有&quot;</span> + Child.count  + <span class="string">&quot; 小孩加入了游戏...&quot;</span>);</span><br><span class="line">        <span class="comment">//下面的代码输出什么?</span></span><br><span class="line">        System.out.println(<span class="string">&quot;child1.count=&quot;</span> + child1.count);<span class="comment">//3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;child2.count=&quot;</span> + child2.count);<span class="comment">//3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;child3.count=&quot;</span> + child3.count);<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> &#123; <span class="comment">//类</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//定义一个变量 count ,是一个类变量(静态变量) static 静态</span></span><br><span class="line">    <span class="comment">//该变量最大的特点就是会被Child 类的所有的对象实例共享</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Child</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; 加入了游戏..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义类变量"><a href="#定义类变量" class="headerlink" title="定义类变量"></a>定义类变量</h3><p><strong>定义：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">访问修饰符 <span class="keyword">static</span> 数据类型 变量名；</span><br></pre></td></tr></table></figure><p><strong>访问：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类名.类变量名</span><br><span class="line">或</span><br><span class="line">对象名.类变量名</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>静态变量的访问修饰符的访问权限和范围和普通属性是一样的</li><li>类变量是随着类的加载而创建，所以即使没有创建对象实例也可以访问</li><li>从 JDK8.0 开始，static 修饰的成员变量的元数据位于元空间（方法区的一种实现方式）中，但真正的值位于堆内存中（JDK7.0 开始）</li></ol><p><strong>说明 :</strong> 当类加载器将含有 static 修饰的成员变量的类加载到方法区时，会根据反射机制生成一个字节码文件对象，即 Class 对象。Class 对象在堆空间中，保存了对应类的静态变量的值。如下图所示 : （<strong>即所有对象访问的某个类变量，其实就是那一份</strong>）</p><p><img src="H:\MyBlog\myblogs\source_posts\assets\1749402951085-1.png" alt="img"></p><h3 id="类变量使用细节"><a href="#类变量使用细节" class="headerlink" title="类变量使用细节"></a>类变量使用细节</h3><ol><li>什么时候需要用类变量<ol><li>当需要让某给类的使用对象都共享一个变量时，就可以考虑使用类变量，比如：定义学生类，统计所有学生共交多少钱</li></ol></li><li>类变量与实例变量（普通属性）的区别<ol><li>类变量是该类使用对象共享的，而实例变量是每个对象独享的</li></ol></li><li>加上 static 称为类变量或静态变量，否则称为实例变量&#x2F;普通变量&#x2F;非静态变量</li><li>类变量既可以通过“类名。”的形式来调用，也可以通过“对象。”的形式来调用，优先使用“类名。”的形式来访问类变量（在访问类变量时，也要遵循访问权限修饰符的规则）</li><li>非静态变量不能通过“类名。”的形式来访问，只能通过“对象。”的形式来访问</li><li>类变量在类加载时就要初始化，也就是说，即使没有创建对象，只要类加载了，就可以使用类变量了</li><li>类变量的生命周期是随类的加载开始，随着类消亡而销毁</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticDetail</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        <span class="comment">//System.out.println(B.n1);</span></span><br><span class="line">        System.out.println(B.n2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//静态变量是类加载的时候，就创建了,所以我们没有创建对象实例</span></span><br><span class="line">        <span class="comment">//也可以通过类名.类变量名来访问</span></span><br><span class="line">        System.out.println(C.address);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> <span class="string">&quot;北京&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VisitStatic</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//类名.类变量名</span></span><br><span class="line">        <span class="comment">//说明：类变量是随着类的加载而创建，所以即使没有创建对象实例也可以访问</span></span><br><span class="line">        System.out.println(A.name);</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="comment">//通过对象名.类变量名</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a.name=&quot;</span> + a.name);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">//类变量</span></span><br><span class="line">    <span class="comment">//类变量的访问，必须遵守 相关的访问权限.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;韩顺平教育&quot;</span>;</span><br><span class="line">    <span class="comment">//普通属性/普通成员变量/非静态属性/非静态成员变量/实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>类方法也叫静态方法</p><p><strong>定义形式：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">访问修饰符 <span class="keyword">static</span> 数据返回类型 方法名 () &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>调用：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类名.方法名</span><br><span class="line">对象名.方法名</span><br></pre></td></tr></table></figure><p><strong>案例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建2个学生对象，叫学费</span></span><br><span class="line">        <span class="type">Stu</span> <span class="variable">tom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        <span class="comment">//tom.payFee(100);</span></span><br><span class="line">        Stu.payFee(<span class="number">100</span>);<span class="comment">//对不对?对</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Stu</span> <span class="variable">mary</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>(<span class="string">&quot;mary&quot;</span>);</span><br><span class="line">        <span class="comment">//mary.payFee(200);</span></span><br><span class="line">        Stu.payFee(<span class="number">200</span>);<span class="comment">//对</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出当前收到的总学费</span></span><br><span class="line">        Stu.showFee();<span class="comment">//300</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果我们希望不创建实例，也可以调用某个方法(即当做工具来使用)</span></span><br><span class="line">        <span class="comment">//这时，把方法做成静态方法时非常合适</span></span><br><span class="line">        System.out.println(<span class="string">&quot;9开平方的结果是=&quot;</span> + Math.sqrt(<span class="number">9</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(MyTools.calSum(<span class="number">10</span>, <span class="number">30</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//开发自己的工具类时，可以将方法做成静态的，方便调用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTools</span>  &#123;</span><br><span class="line">    <span class="comment">//求出两个数的和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">calSum</span><span class="params">(<span class="type">double</span> n1, <span class="type">double</span> n2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>  n1 + n2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可以写出很多这样的工具方法...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//普通成员</span></span><br><span class="line">    <span class="comment">//定义一个静态变量，来累积学生的学费</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="variable">fee</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Stu</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说明</span></span><br><span class="line">    <span class="comment">//1. 当方法使用了static修饰后，该方法就是静态方法</span></span><br><span class="line">    <span class="comment">//2. 静态方法就可以访问静态属性/变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">payFee</span><span class="params">(<span class="type">double</span> fee)</span> &#123;</span><br><span class="line">        Stu.fee += fee;<span class="comment">//累积到</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showFee</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;总学费有:&quot;</span> + Stu.fee);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类方法使用细节"><a href="#类方法使用细节" class="headerlink" title="类方法使用细节"></a>类方法使用细节</h3><ol><li>类方法的使用场景<ol><li>只需要访问静态成员，且不涉及到任何和对象相关的成员，所需参数均可由形参列表显式提供，这时候我们就可以定义静态方法</li></ol></li><li>类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区<ol><li>类方法中无 this 的参数</li><li>普通方法中隐含着 this 的参数</li></ol></li><li>类方法可以通过类名调用，也可以通过对象名调用</li><li>普通方法和对象有关，需要对象名调用，不能通过类名调用</li><li>类方法中不允许使用和对象有关的关键字，比如 this 和 super</li><li>类方法（静态方法）中，只能访问静态变量或静态方法</li><li>普通成员方法，既可以访问非静态成员，也可以访问静态成员</li></ol><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticMethodDetail</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line"></span><br><span class="line">        D.<span class="title function_">hi</span>();<span class="comment">//ok</span></span><br><span class="line">        <span class="comment">//非静态方法，不能通过类名调用</span></span><br><span class="line">        <span class="comment">//D.say();, 错误，需要先创建对象，再调用</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title function_">D</span>().<span class="title function_">say</span>();<span class="comment">//可以</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> int n1 = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  int n2 = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">say</span>(<span class="params"></span>) &#123;<span class="comment">//非静态方法,普通方法</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="built_in">void</span> <span class="title function_">hi</span>(<span class="params"></span>) &#123;<span class="comment">//静态方法,类方法</span></span><br><span class="line">        <span class="comment">//类方法中不允许使用和对象有关的关键字，</span></span><br><span class="line">        <span class="comment">//比如this和super。普通方法(成员方法)可以。</span></span><br><span class="line">        <span class="comment">//System.out.println(this.n1);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类方法(静态方法)中 只能访问 静态变量 或静态方法</span></span><br><span class="line">    <span class="comment">//口诀:静态方法只能访问静态成员.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">hello</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(n2);</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(D.<span class="property">n2</span>);</span><br><span class="line">        <span class="comment">//System.out.println(this.n2);不能使用</span></span><br><span class="line">        <span class="title function_">hi</span>();<span class="comment">//OK</span></span><br><span class="line">        <span class="comment">//say();//错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//普通成员方法，既可以访问  非静态成员，也可以访问静态成员</span></span><br><span class="line">    <span class="comment">//小结: 非静态方法可以访问 静态成员和非静态成员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">ok</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//非静态成员</span></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(n1);</span><br><span class="line">        <span class="title function_">say</span>();</span><br><span class="line">        <span class="comment">//静态成员</span></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(n2);</span><br><span class="line">        <span class="title function_">hello</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="理解-main-方法"><a href="#理解-main-方法" class="headerlink" title="理解 main 方法"></a>理解 main 方法</h1><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line">            <span class="comment">//方法体（代码）</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li><strong>main</strong> <strong>函数是所有程序的唯一入口，由</strong> <strong>jvm</strong> <strong>来调用</strong></li><li>Java 虚拟机需要调用类的 main（）方法，所以该方法的访问权限必须是 public</li><li>Java 虚拟机在执行 main（）方法时不必创建对象，所以该方法必须是 static</li><li>该方法接收 String 类型的数组参数，该数组中保存执行 Java 命令是传递给所有运行的类的参数</li><li>Java 执行的程序 参数 1 参数 2 参数 3</li><li>在 main（）方法中，我们可以直接调用 main 方法所在类的静态方法或静态属性</li><li>但是不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员</li></ol><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的变量/属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="title class_">String</span> name = <span class="string">&quot;韩顺平教育&quot;</span>;</span><br><span class="line">    <span class="comment">//非静态的变量/属性</span></span><br><span class="line">    <span class="keyword">private</span> int n1 = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="built_in">void</span> <span class="title function_">hi</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;Main01的 hi方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">cry</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;Main01的 cry方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//可以直接使用 name</span></span><br><span class="line">        <span class="comment">//1. 静态方法main 可以访问本类的静态成员</span></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;name=&quot;</span> + name);</span><br><span class="line">        <span class="title function_">hi</span>();</span><br><span class="line">        <span class="comment">//2. 静态方法main 不可以访问本类的非静态成员</span></span><br><span class="line">        <span class="comment">//System.out.println(&quot;n1=&quot; + n1);//错误</span></span><br><span class="line">        <span class="comment">//cry();</span></span><br><span class="line">        <span class="comment">//3. 静态方法main 要访问本类的非静态成员，需要先创建对象 , 再调用即可</span></span><br><span class="line">        <span class="title class_">Main01</span> main01 = <span class="keyword">new</span> <span class="title class_">Main01</span>();</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(main01.<span class="property">n1</span>);<span class="comment">//ok</span></span><br><span class="line">        main01.<span class="title function_">cry</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> ( int i = <span class="number">0</span>; i &lt; args.<span class="property">length</span>; i++ ) &#123;</span><br><span class="line">            <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;args[&quot;</span> + i + <span class="string">&quot;] = &quot;</span> + args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>代码块，也称为初始化块，属于类中的成员（即和属性，方法一样，是类的一部分），类似于方法，将逻辑语句封装在方法体中，通过{}包围起来</p><p>但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显式调用，而是加载类时或创建对象时隐式调用</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法体语句。（代码）</span></span><br><span class="line"></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ol><li>修饰符可选，修饰符只能写 static</li><li>代码块分为两类，使用 static 修饰的叫静态代码块，没有 static 修饰的叫普通代码块&#x2F;非静态代码块</li><li>逻辑语句可以为任何逻辑语句（输入，输出，方法调用，循环，判断等）</li><li>; 可写可不写</li></ol><h2 id="代码块的使用细节"><a href="#代码块的使用细节" class="headerlink" title="代码块的使用细节"></a>代码块的使用细节</h2><ol><li>static 代码块也叫静态代码块，作用就是对类进行初始化，<strong>而且它随着类的加载而执行，并且只会执行一次</strong></li><li>类什么时候被加载<ol><li>创建对象实例时（new）</li><li>创建子类对象实例，父类也会被加载</li><li>使用类的静态成员时（静态属性，静态方法）</li></ol></li><li>普通的代码块，在创建对象实例时，会被隐式的调用<ol><li><strong>被创建一次，就会调用一次</strong></li><li>如果只是使用类的静态成员时，普通代码块并不会执行</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeBlockDetail01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//类被加载的情况举例</span></span><br><span class="line">        <span class="comment">//1. 创建对象实例时(new)</span></span><br><span class="line">        <span class="comment">// AA aa = new AA();</span></span><br><span class="line">        <span class="comment">//2. 创建子类对象实例，父类也会被加载, 而且，父类先被加载，子类后被加载</span></span><br><span class="line">        <span class="comment">// AA aa2 = new AA();</span></span><br><span class="line">        <span class="comment">//3. 使用类的静态成员时(静态属性，静态方法)</span></span><br><span class="line">        <span class="comment">// System.out.println(Cat.n1);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//static代码块，是在类加载时，执行的，而且只会执行一次.</span></span><br><span class="line"><span class="comment">//        DD dd = new DD();</span></span><br><span class="line"><span class="comment">//        DD dd1 = new DD();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//普通的代码块，在创建对象实例时，会被隐式的调用。</span></span><br><span class="line">        <span class="comment">// 被创建一次，就会调用一次。</span></span><br><span class="line">        <span class="comment">// 如果只是使用类的静态成员时，普通代码块并不会执行</span></span><br><span class="line"></span><br><span class="line">        System.out.println(DD.n1);<span class="comment">//8888, 静态模块块一定会执行</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DD</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">8888</span>;<span class="comment">//静态属性</span></span><br><span class="line">    <span class="comment">//静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DD 的静态代码1被执行...&quot;</span>);<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//普通代码块, 在new 对象时，被调用，而且是每创建一个对象，就调用一次</span></span><br><span class="line">    <span class="comment">//可以这样简单的，理解 普通代码块是构造器的补充</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DD 的普通代码块...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">//静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal 的静态代码1被执行...&quot;</span>);<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">999</span>;<span class="comment">//静态属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat 的静态代码1被执行...&quot;</span>);<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span> &#123;</span><br><span class="line">    <span class="comment">//静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BB 的静态代码1被执行...&quot;</span>);<span class="comment">//1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span> <span class="keyword">extends</span> <span class="title class_">BB</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AA 的静态代码1被执行...&quot;</span>);<span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>创建一个对象时，在一个类调用顺序<ol><li>调用静态代码块和静态属性初始化（静态代码块和静态属性初始化调用的优先级一样，按照定义的顺序调用）</li><li>调用普通代码块和普通属性的初始化（普通代码块和普通属性初始话调用的优先级一样，按定义顺序调用）</li><li>调用构造方法</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeBlockDetail02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();<span class="comment">// (1) A 静态代码块01 (2) getN1被调用...(3)A 普通代码块01(4)getN2被调用...(5)A() 构造器被调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    &#123; <span class="comment">//普通代码块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;A 普通代码块01&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> getN2();<span class="comment">//普通属性的初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123; <span class="comment">//静态代码块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;A 静态代码块01&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态属性的初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> getN1();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getN1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;getN1被调用...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getN2</span><span class="params">()</span> &#123; <span class="comment">//普通方法/非静态方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;getN2被调用...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//无参构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A() 构造器被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>构造器的前面隐含了 super（）和调用普通代码块，静态相关的代码块，属性初始化，在类加载时，就执行完毕，因此优先于构造器和普通代码块</li></ol><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeBlockDetail03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title function_">BBB</span>();<span class="comment">//(1)AAA的普通代码块(2)AAA() 构造器被调用(3)BBB的普通代码块(4)BBB() 构造器被调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AAA</span> &#123; <span class="comment">//父类Object</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;AAA的普通代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AAA</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//(1)super()</span></span><br><span class="line">        <span class="comment">//(2)调用本类的普通代码块</span></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;AAA() 构造器被调用....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BBB</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AAA</span>  &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;BBB的普通代码块...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BBB</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//(1)super()</span></span><br><span class="line">        <span class="comment">//(2)调用本类的普通代码块</span></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;BBB() 构造器被调用....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>创建一个子类对象时（继承关系），它的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序<ol><li>父类的静态代码块和静态属性（优先级一样，按定义顺序执行）</li><li>子类的静态代码块和静态属性（优先级一样，按定义顺序执行）</li><li>父类的晋通代码块和普通属性初始化（优先级一样，按定义顺序执行）</li><li>父类的构造方法</li><li>子类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）</li><li>子类的构造方法 &#x2F;&#x2F;面试题</li></ol></li><li>静态代码块只能直接调用静态成员，普通代码块可以调用任意成员</li></ol><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeBlockDetail04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="comment">//(1) 进行类的加载</span></span><br><span class="line">        <span class="comment">//1.1 先加载 父类 A02 1.2 再加载 B02</span></span><br><span class="line">        <span class="comment">//(2) 创建对象</span></span><br><span class="line">        <span class="comment">//2.1 从子类的构造器开始</span></span><br><span class="line">        <span class="comment">//new B02();//对象</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title function_">C02</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A02</span> &#123; <span class="comment">//父类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> int n1 = <span class="title function_">getVal01</span>();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;A02的一个静态代码块..&quot;</span>);<span class="comment">//(2)</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;A02的第一个普通代码块..&quot;</span>);<span class="comment">//(5)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> int n3 = <span class="title function_">getVal02</span>();<span class="comment">//普通属性的初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> int <span class="title function_">getVal01</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;getVal01&quot;</span>);<span class="comment">//(1)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> int <span class="title function_">getVal02</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;getVal02&quot;</span>);<span class="comment">//(6)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A02</span>(<span class="params"></span>) &#123;<span class="comment">//构造器</span></span><br><span class="line">        <span class="comment">//隐藏</span></span><br><span class="line">        <span class="comment">//super()</span></span><br><span class="line">        <span class="comment">//普通代码和普通属性的初始化......</span></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;A02的构造器&quot;</span>);<span class="comment">//(7)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C02</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> int n1 = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  int n2 = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">void</span> <span class="title function_">m1</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">m2</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//静态代码块，只能调用静态成员</span></span><br><span class="line">        <span class="comment">//System.out.println(n1);错误</span></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(n2);<span class="comment">//ok</span></span><br><span class="line">        <span class="comment">//m1();//错误</span></span><br><span class="line">        <span class="title function_">m2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//普通代码块，可以使用任意成员</span></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(n1);</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(n2);<span class="comment">//ok</span></span><br><span class="line">        <span class="title function_">m1</span>();</span><br><span class="line">        <span class="title function_">m2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B02</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A02</span> &#123; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> int n3 = <span class="title function_">getVal03</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;B02的一个静态代码块..&quot;</span>);<span class="comment">//(4)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> int n5 = <span class="title function_">getVal04</span>();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;B02的第一个普通代码块..&quot;</span>);<span class="comment">//(9)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> int <span class="title function_">getVal03</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;getVal03&quot;</span>);<span class="comment">//(3)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> int <span class="title function_">getVal04</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;getVal04&quot;</span>);<span class="comment">//(8)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一定要慢慢的去品..</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B02</span>(<span class="params"></span>) &#123;<span class="comment">//构造器</span></span><br><span class="line">        <span class="comment">//隐藏了</span></span><br><span class="line">        <span class="comment">//super()</span></span><br><span class="line">        <span class="comment">//普通代码块和普通属性的初始化...</span></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;B02的构造器&quot;</span>);<span class="comment">//(10)</span></span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><ol><li>所谓类的单例设计模式，就是采取一定的方法保证在整个软件系统中，对某给类只能存在一个对象实例，并且该类只能提供一个取得其对象实例的方法</li><li>单例模式有两种方式（饿汉式，懒汉式）</li></ol><h2 id="单例模式应用实例"><a href="#单例模式应用实例" class="headerlink" title="单例模式应用实例"></a>单例模式应用实例</h2><p>饿汉式和懒汉式单例模式的实现</p><ol><li>构造器私有化&#x3D;》防止直接 new</li><li>类的内部创建对象</li><li>向外暴露一个静态的公共方法。 getlnstance</li></ol><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleTon01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line"><span class="comment">//        GirlFriend xh = new GirlFriend(&quot;小红&quot;);</span></span><br><span class="line"><span class="comment">//        GirlFriend xb = new GirlFriend(&quot;小白&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过方法可以获取对象</span></span><br><span class="line">        <span class="title class_">GirlFriend</span> instance = <span class="title class_">GirlFriend</span>.<span class="title function_">getInstance</span>();</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(instance);</span><br><span class="line"></span><br><span class="line">        <span class="title class_">GirlFriend</span> instance2 = <span class="title class_">GirlFriend</span>.<span class="title function_">getInstance</span>();</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(instance2);</span><br><span class="line"></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(instance == instance2);<span class="comment">//T</span></span><br><span class="line">        <span class="comment">//System.out.println(GirlFriend.n1);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有一个类， GirlFriend</span></span><br><span class="line"><span class="comment">//只能有一个女朋友</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GirlFriend</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">String</span> name;</span><br><span class="line">    <span class="comment">//public static  int n1 = 100;</span></span><br><span class="line">    <span class="comment">//为了能够在静态方法中，返回 gf对象，需要将其修饰为static</span></span><br><span class="line">    <span class="comment">//對象，通常是重量級的對象, 餓漢式可能造成創建了對象，但是沒有使用.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="title class_">GirlFriend</span> gf = <span class="keyword">new</span> <span class="title class_">GirlFriend</span>(<span class="string">&quot;小红红&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如何保障我们只能创建一个 GirlFriend 对象</span></span><br><span class="line">    <span class="comment">//步骤[单例模式-饿汉式]</span></span><br><span class="line">    <span class="comment">//1. 将构造器私有化</span></span><br><span class="line">    <span class="comment">//2. 在类的内部直接创建对象(该对象是static)</span></span><br><span class="line">    <span class="comment">//3. 提供一个公共的static方法，返回 gf对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">GirlFriend</span>(<span class="title class_">String</span> name) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;構造器被調用.&quot;</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="title class_">GirlFriend</span> <span class="title function_">getInstance</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> gf;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;GirlFriend&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示懶漢式的單例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleTon02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="comment">//new Cat(&quot;大黃&quot;);</span></span><br><span class="line">        <span class="comment">//System.out.println(Cat.n1);</span></span><br><span class="line">        <span class="title class_">Cat</span> instance = <span class="title class_">Cat</span>.<span class="title function_">getInstance</span>();</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(instance);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再次調用getInstance</span></span><br><span class="line">        <span class="title class_">Cat</span> instance2 = <span class="title class_">Cat</span>.<span class="title function_">getInstance</span>();</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(instance2);</span><br><span class="line"></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(instance == instance2);<span class="comment">//T</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//希望在程序運行過程中，只能創建一個Cat對象</span></span><br><span class="line"><span class="comment">//使用單例模式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">String</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  int n1 = <span class="number">999</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="title class_">Cat</span> cat ; <span class="comment">//默認是null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//步驟</span></span><br><span class="line">    <span class="comment">//1.仍然構造器私有化</span></span><br><span class="line">    <span class="comment">//2.定義一個static靜態屬性對象</span></span><br><span class="line">    <span class="comment">//3.提供一個public的static方法，可以返回一個Cat對象</span></span><br><span class="line">    <span class="comment">//4.懶漢式，只有當用戶使用getInstance時，才返回cat對象, 後面再次調用時，會返回上次創建的cat對象</span></span><br><span class="line">    <span class="comment">//  從而保證了單例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">Cat</span>(<span class="title class_">String</span> name) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;構造器調用...&quot;</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="title class_">Cat</span> <span class="title function_">getInstance</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cat == <span class="literal">null</span>) &#123;<span class="comment">//如果還沒有創建cat對象</span></span><br><span class="line">            cat = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;小可愛&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Cat&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="饿汉式-VS-懒汉式"><a href="#饿汉式-VS-懒汉式" class="headerlink" title="饿汉式 VS 懒汉式"></a>饿汉式 VS 懒汉式</h2><ol><li>二者最主要的区别在于创建对象的时机不同：饿汉式是在类加载就创建了对象实例，而懒汉式是在使用时才创建</li><li>饿汊式不存在线程安全问题，懒汉式存在线程安全问题</li><li>饿汉式存在浪费资源的可能。因为如果程序员一个对象实例都没有使用，那么饿汉式创建的对象就浪费了，懒汉式是使用时才创建，就不存在这个问题</li><li>在我们 javaSE 标准类中， java.Iang.Runtime 就是经典的单例模式</li></ol><h1 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h1><h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h2><p>Final 可以修饰类，属性，方法和局部变量</p><ol><li>当不希望类被继承时可以使用 final 修饰</li><li>当不希望父类的某个方法被子类重写时，可以使用 final 修饰</li><li>当不希望类的某个属性的值被修改，可以使用 final 修饰</li><li>当不希望某个局部变量被修改，可以使用 final 修饰</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Final01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">E</span>();</span><br><span class="line">        <span class="comment">//e.TAX_RATE = 0.09;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果我们要求A类不能被其他类继承</span></span><br><span class="line"><span class="comment">//可以使用final修饰 A类</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class B extends A &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="comment">//如果我们要求hi不能被子类重写</span></span><br><span class="line">    <span class="comment">//可以使用final修饰 hi方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public void hi() &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;重写了C类的hi方法..&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当不希望类的的某个属性的值被修改,可以用final修饰</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">TAX_RATE</span> <span class="operator">=</span> <span class="number">0.08</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当不希望某个局部变量被修改，可以使用final修饰</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">F</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//这时，NUM 也称为 局部常量</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">double</span> <span class="variable">NUM</span> <span class="operator">=</span> <span class="number">0.01</span>;</span><br><span class="line">        <span class="comment">//NUM = 0.9;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;NUM=&quot;</span> + NUM);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="final-使用细节"><a href="#final-使用细节" class="headerlink" title="final 使用细节"></a>final 使用细节</h2><ol><li>final 修饰的属性有叫常量，一般用 XXX_XX 命名</li><li>final 修饰的属性在定义时，必须赋初始值，并于以后不能进行修改，赋值可以在以下位置之一<ol><li>定义时 比如：public final double TAX_RATE &#x3D; 0.08；</li><li>在构造器中</li><li>在代码块中</li></ol></li><li><strong>如果 final 修饰的属性是静态的，则初始化的位置只能是定义时，或在静态代码块 不能在构造器中赋值</strong></li><li>final 类不能被继承，但是可以实例化对象</li><li>如果类本身 final 类，但是含有 final 方法，则该方法虽然不能重写，但是可以被继承（一般如果一个类已经是 final 类了，就没有必要在将方法修饰成 final 方法）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalDetail01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CC</span> <span class="variable">cc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CC</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">EE</span>().cal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 定义时：如 public final double TAX_RATE=0.08;</span></span><br><span class="line"><span class="comment">    2. 在构造器中</span></span><br><span class="line"><span class="comment">    3. 在代码块中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">TAX_RATE</span> <span class="operator">=</span> <span class="number">0.08</span>;<span class="comment">//1.定义时赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">double</span> TAX_RATE2 ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">double</span> TAX_RATE3 ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AA</span><span class="params">()</span> &#123;<span class="comment">//构造器中赋值</span></span><br><span class="line">        TAX_RATE2 = <span class="number">1.1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;<span class="comment">//在代码块赋值</span></span><br><span class="line">        TAX_RATE3 = <span class="number">8.8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果final修饰的属性是静态的，则初始化的位置只能是</span></span><br><span class="line"><span class="comment">    1 定义时  2 在静态代码块 不能在构造器中赋值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">TAX_RATE</span> <span class="operator">=</span> <span class="number">99.9</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> TAX_RATE2 ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        TAX_RATE2 = <span class="number">3.3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//final类不能继承，但是可以实例化对象</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CC</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承</span></span><br><span class="line"><span class="comment">//即，仍然遵守继承的机制.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DD</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">cal</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cal()方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EE</span> <span class="keyword">extends</span> <span class="title class_">DD</span> &#123; &#125;</span><br></pre></td></tr></table></figure><ol><li>final 不能修饰构造方法</li><li>final 和 static 往往搭配使用，效率更高，不会导致类加载，底层编译器做了优化处理</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalDetail02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(BBB.num);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//包装类,String 是final类，不能被继承</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//final 和 static 往往搭配使用，效率更高，不会导致类加载.底层编译器做了优化处理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BBB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span>  <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BBB 静态代码块被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">AAA</span>&#123;</span><br><span class="line">    <span class="comment">//一般来说，如果一个类已经是final类了，就没有必要再将方法修饰成final方法</span></span><br><span class="line">    <span class="comment">//public final void cry() &#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><h2 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h2><p>父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了（因为子类对象会调用自己重写的方法）。换句话说，父类可能知道子类应该有哪个功能，但是功能具体怎么实现父类是不清楚的（由子类自己决定），父类只需要提供一个没有方法体的定义即可，具体实现交给子类自己去实现。<strong>我们把没有方法体的方法称为抽象方法。Java 语法规定，包含抽象方法的类就是抽象类</strong></p><ul><li><strong>抽象方法</strong> ： 没有方法体的方法</li><li><strong>抽象类</strong>：包含抽象方法的类</li></ul><h2 id="抽象类介绍"><a href="#抽象类介绍" class="headerlink" title="抽象类介绍"></a>抽象类介绍</h2><ol><li>用 abstract 关键字来修饰一个类时，这个类就叫抽象类</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">访问权限修饰符  <span class="keyword">abstract</span>  class  类名&#123; <span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><ol><li>用 abstract 关键字修饰一个方法时，这个方法就是抽象方法</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">访问权限修饰符  <span class="keyword">abstract</span>  返回值类型  方法名(形参列表);</span><br></pre></td></tr></table></figure><ol><li>抽象类的价值更多作用是在于设计，是设计着设计好后，让子类继承并实现抽象类（）</li></ol><h2 id="抽象类的使用细节"><a href="#抽象类的使用细节" class="headerlink" title="抽象类的使用细节"></a>抽象类的使用细节</h2><ol><li>抽象类不能被实例化</li><li>抽象类不一定要包含 abstract 方法，也就是说抽象类可以没有 abstract 方法</li><li>一旦类包含了 abstract 方法，则这个类必须声明为 abstract</li><li>abstract 只能修饰类和方法，不能修饰属性和其他的</li></ol><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractDetail01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="comment">//抽象类，不能被实例化</span></span><br><span class="line">        <span class="comment">//new A();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象类不一定要包含abstract方法。也就是说,抽象类可以没有abstract方法</span></span><br><span class="line"><span class="comment">//，还可以有实现的方法。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">hi</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一旦类包含了abstract方法,则这个类必须声明为abstract</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">void</span> <span class="title function_">hi</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//abstract 只能修饰类和方法，不能修饰属性和其它的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">   <span class="comment">// public abstract int n1 = 1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>抽象类可以有任意成员（抽象类本质还是类）</li><li>抽象方法不能有方法体{}</li><li>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为 abstract 类</li><li>抽象方法不能使用 private，final 和 static 来修饰，因为这些关键字都是和重写相违背的</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractDetail02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象方法不能使用private、final 和 static来修饰，因为这些关键字都是和重写相违背的</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">H</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>   <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">F</span> <span class="keyword">extends</span> <span class="title class_">E</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">G</span> <span class="keyword">extends</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123; <span class="comment">//这里相等于G子类实现了父类E的抽象方法，所谓实现方法，就是有方法体</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象类的本质还是类，所以可以有类的各种成员</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">D</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;韩顺平教育&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">ok</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>编写一 个 Employee 类，声明为抽象类，包含如下三个属性： name， id， salaryo 提供必要的构造器和抽象方法： work（） 。对于 Manager 类来说，他既是员工，还具有奖金（ bonus ）的属性。请使用继承的思想，设计 CommonEmpIoyee 类和 Manager 类，要求类中提供必要的方法进行属性访问，实现 work（） ，提示”经嘢普通员工名字工作中····’’ 00P 的继承+抽象类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name, <span class="type">int</span> id, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将work做成一个抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonEmployee</span> <span class="keyword">extends</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CommonEmployee</span><span class="params">(String name, <span class="type">int</span> id, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, id, salary);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通员工 &quot;</span> + getName() + <span class="string">&quot; 工作中...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> bonus;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">(String name, <span class="type">int</span> id, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, id, salary);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBonus</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bonus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBonus</span><span class="params">(<span class="type">double</span> bonus)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bonus = bonus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;经理 &quot;</span> + getName() + <span class="string">&quot; 工作中...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractExercise01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        <span class="type">Manager</span> <span class="variable">jack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>(<span class="string">&quot;jack&quot;</span>, <span class="number">999</span>, <span class="number">50000</span>);</span><br><span class="line">        jack.setBonus(<span class="number">8000</span>);</span><br><span class="line">        jack.work();</span><br><span class="line"></span><br><span class="line">        <span class="type">CommonEmployee</span> <span class="variable">tom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommonEmployee</span>(<span class="string">&quot;tom&quot;</span>, <span class="number">888</span>, <span class="number">20000</span>);</span><br><span class="line">        tom.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h2><p>接口（Interface） 是一种抽象类型，用于定义对象的行为规范。接口包含一组抽象方法（从Java 8开始可以包含默认方法和静态方法），但不提供具体实现。类通过实现接口来遵守这些行为规范</p><h2 id="接口的基本语法"><a href="#接口的基本语法" class="headerlink" title="接口的基本语法"></a>接口的基本语法</h2><ol><li><strong>使用</strong>**<code>interface</code>**<strong>关键字定义接口：</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>; <span class="comment">// 抽象方法，默认是 public 和 abstract</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>类通过</strong>**<code>implements</code>**<strong>关键字实现接口，并提供接口中所有抽象方法的具体实现</strong></li></ol><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">fly</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;Bird is flying.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="title class_">Flyable</span> bird = <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">        bird.<span class="title function_">fly</span>(); <span class="comment">// 输出: Bird is flying.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口的特点"><a href="#接口的特点" class="headerlink" title="接口的特点"></a>接口的特点</h2><ol><li><strong>只包含抽象方法（Java 8之前）：</strong><ol><li>接口中定义的方法默认是<code>public</code>和<code>abstract</code>，不需要显式声明</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>; <span class="comment">// 等价于 public abstract void fly();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>不能包含实例变量：</strong><ol><li>接口中只能包含常量（<code>public static final</code>修饰的变量）</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">MAX_HEIGHT</span> <span class="operator">=</span> <span class="number">1000</span>; <span class="comment">// 等价于 public static final int MAX_HEIGHT = 1000;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>支持多继承：</strong><ol><li>类可以实现多个接口，从而实现多重继承的效果</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Swimmable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Duck</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span>, Swimmable &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Duck is flying.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Duck is swimming.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><strong>从Java 8开始支持默认方法和静态方法：</strong></p><ol><li><p>默认方法：提供了方法的默认实现，子类可以选择重写</p></li><li><pre><code class="Java">public interface Flyable &#123;    default void land() &#123;        System.out.println(&quot;Landing...&quot;);    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. 静态方法：可以直接通过接口名调用</span><br><span class="line"></span><br><span class="line">4. ```Java</span><br><span class="line">   public interface Flyable &#123;</span><br><span class="line">       static void takeOff() &#123;</span><br><span class="line">           System.out.println(&quot;Taking off...&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ol></li><li><p><strong>从Java 9开始支持私有方法：</strong></p><ol><li><p>私有方法用于封装默认方法或静态方法中的公共逻辑。</p></li><li><p>java</p></li><li><p>深色版本</p></li><li><pre><code class="Java">public interface Flyable &#123;    default void land() &#123;        commonLogic();        System.out.println(&quot;Landing...&quot;);    &#125;    private void commonLogic() &#123;        System.out.println(&quot;Common logic for landing.&quot;);    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 接口与抽象类的区别</span><br><span class="line"></span><br><span class="line">| 特性     | 接口                                  | 抽象类                       |</span><br><span class="line">| :------- | :------------------------------------ | :--------------------------- |</span><br><span class="line">| 关键字   | `interface`                           | `abstract class`             |</span><br><span class="line">| 方法实现 | 只能包含抽象方法、默认方法和静态方法  | 可以包含抽象方法和非抽象方法 |</span><br><span class="line">| 成员变量 | 只能包含常量（`public static final`） | 可以包含普通成员变量         |</span><br><span class="line">| 继承方式 | 支持多实现                            | 只支持单继承                 |</span><br><span class="line">| 构造方法 | 不能有构造方法                        | 可以有构造方法               |</span><br><span class="line">| 使用场景 | 定义行为规范                          | 提供通用功能和部分实现       |</span><br><span class="line"></span><br><span class="line">## 接口的使用场景</span><br><span class="line"></span><br><span class="line">1. **定义行为规范：**</span><br><span class="line">   1. 当需要定义一组行为规范时，接口是非常合适的选择</span><br><span class="line"></span><br><span class="line">```Java</span><br><span class="line">public interface Drawable &#123;</span><br><span class="line">    void draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ol></li><li><p>解耦代码：</p><ol><li>接口可以将实现细节与业务逻辑分离，提高代码的灵活性和可维护性</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PaymentGateway</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">processPayment</span><span class="params">(<span class="type">double</span> amount)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayPalGateway</span> <span class="keyword">implements</span> <span class="title class_">PaymentGateway</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processPayment</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Processing payment via PayPal: $&quot;</span> + amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>支持多态：</strong><ol><li>接口可以通过多态的方式调用不同实现类的方法</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">PaymentGateway</span> <span class="variable">gateway</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PayPalGateway</span>();</span><br><span class="line">gateway.processPayment(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><ol><li>框架设计：<ol><li>在Spring、Hibernate等框架中，接口被广泛用于定义服务层、DAO层等</li></ol></li></ol><h2 id="接口的实际应用"><a href="#接口的实际应用" class="headerlink" title="接口的实际应用"></a>接口的实际应用</h2><p>以下是一个完整的示例，展示如何使用接口实现多态和代码解耦：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Car started.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Car stopped.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bike</span> <span class="keyword">implements</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bike started.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bike stopped.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">bike</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bike</span>();</span><br><span class="line"></span><br><span class="line">        car.start(); <span class="comment">// 输出: Car started.</span></span><br><span class="line">        car.stop();  <span class="comment">// 输出: Car stopped.</span></span><br><span class="line"></span><br><span class="line">        bike.start(); <span class="comment">// 输出: Bike started.</span></span><br><span class="line">        bike.stop();  <span class="comment">// 输出: Bike stopped.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li><strong>接口中的方法默认是<code>public</code>：</strong><ol><li>如果在接口中定义方法时没有指定访问修饰符，默认就是<code>public</code></li></ol></li><li>接口不能直接实例化：<ol><li>接口本身不能通过<code>new</code>关键字创建对象，只能通过实现类实例化</li></ol></li><li><strong>接口冲突问题：</strong><ol><li>如果一个类实现了多个接口，而这些接口中有相同签名的默认方法，则必须重写该方法以解决冲突</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello from A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello from B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">implements</span> <span class="title class_">A</span>, B &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        A.<span class="built_in">super</span>.sayHello(); <span class="comment">// 调用A接口的默认方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h2 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h2><p>Java内部类（Inner Class） 是一种定义在一个外部类（Outer Class）内部的类，<strong>内部类最大的特点就是可以直接访问私有属性，并且可以体现出类与类之间的包含关系</strong></p><p>内部类是类的第五大成员，其他四个分别是属性，方法，构造器，代码块</p><p>暂时无法在飞书文档外展示此内容</p><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>成员内部类是最常见的内部类形式，它作为外部类的一个非静态成员存在</p><p><strong>特点：</strong></p><ul><li>可以访问外部类的所有成员（包括私有成员）</li><li>每个成员内部类的对象都隐式持有一个对外部类对象的引用</li><li>可以用<code>private</code>、<code>protected</code>、<code>public</code>等修饰符修饰</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">outerField</span> <span class="operator">=</span> <span class="string">&quot;Outer Field&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Accessing outer field: &quot;</span> + outerField);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建外部类对象</span></span><br><span class="line">        <span class="type">OuterClass</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">        <span class="comment">// 创建内部类对象</span></span><br><span class="line">        OuterClass.<span class="type">InnerClass</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">        inner.display(); <span class="comment">// 输出：Accessing outer field: Outer Field</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>静态内部类是一个用<code>static</code>修饰的内部类，它是外部类的一个静态成员</p><p><strong>特点：</strong></p><ul><li>静态内部类可以直接访问外部类的所有静态成员，包含私有成员。但不能访问非静态成员</li><li>静态内部类本身可以添加任意访问修饰符，因为它本身属于外部类的一个成员，地位同成员变量，成员方法等相当</li><li>作用域——在整个外部类中均可以使用</li><li></li><li>可以用<code>private</code>、<code>protected</code>、<code>public</code>等修饰符修饰</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">staticField</span> <span class="operator">=</span> <span class="string">&quot;Static Field&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态嵌套类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticNestedClass</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Accessing static field: &quot;</span> + staticField);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 直接创建静态嵌套类对象</span></span><br><span class="line">        OuterClass.<span class="type">StaticNestedClass</span> <span class="variable">nested</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>.StaticNestedClass();</span><br><span class="line">        nested.display(); <span class="comment">// 输出：Accessing static field: Static Field</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>局部内部类是在方法或代码块中定义的类，作用域仅限于该方法或代码块，局部内部类的本质仍然是一个类</p><p><strong>特点：</strong></p><ol><li>局部内部类可以直接访问外部类的所有成员，包含私有成员</li><li>不能使用访问修饰符（如<code>public、private</code>）</li><li>可以访问所在方法的<code>final</code>变量（从Java 8开始，也可以访问“实际上不可变”的局部变量）</li><li>外部其他类不能访问局部内部类</li><li>如果想在局部内部类中访问其外部类的重名成员，则可以使用**”外部类名.this.成员”** 的形式去访问</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;fruit&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">juice</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;美汁汁儿~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Grape</span> &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;grape&quot;</span>;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">relationship</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; belongs to &quot;</span> + Fruit.<span class="built_in">this</span>.name);</span><br><span class="line">                juice();    <span class="comment">//invoke directly</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Grape</span>().relationship();</span><br><span class="line">       <span class="comment">/* class SunshineRose extends Grape &#123;</span></span><br><span class="line"><span class="comment">            //Grape类被final关键字修饰，因此不能被继承。</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fruit</span>();</span><br><span class="line">        fruit.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名内部类-重要"><a href="#匿名内部类-重要" class="headerlink" title="匿名内部类(重要)"></a>匿名内部类(重要)</h2><p>匿名内部类是一种没有显式定义名称的内部类。它通常用于简化代码，尤其是在需要实现接口或继承类时。匿名内部类的主要特点是一次性使用，适合快速创建一个类的实例</p><p><strong>特点：</strong></p><ol><li>没有名字：匿名内部类没有显式的类名</li><li>只能使用一次：匿名内部类通常用于创建一个类的单个实例</li><li>必须继承父类或实现接口：匿名内部类要么继承一个父类，要么实现一个接口</li><li>不能有构造器：因为没有名字，所以无法定义构造器，但可以通过实例初始化块完成一些初始化操作</li><li>作用域有限：匿名内部类的作用域仅限于定义它的位置</li><li>匿名内部类可以直接访问外部类的所有成员，包含私有成员</li><li>外部其他类不能访问匿名内部类</li><li>如果想在匿名内部类中访问其外部类的重名成员，则可以使用”外部类名.this.成员” 的形式去访问</li><li>匿名内部类从里面看，它的本质也是一个类，我们可以在类体中定义它自己的成员；但是从外面看，匿名内部类的本质是一个对象，因为底层在创建匿名内部类后直接new出了一个对象，因此实际上你可以直接把它当作一个对象来使用</li></ol><h3 id="匿名内部类的语法"><a href="#匿名内部类的语法" class="headerlink" title="匿名内部类的语法"></a>匿名内部类的语法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类/接口() &#123;</span><br><span class="line">    <span class="comment">// 类体（可以覆盖方法、添加新方法等）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="匿名内部类的使用"><a href="#匿名内部类的使用" class="headerlink" title="匿名内部类的使用"></a>匿名内部类的使用</h3><h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>匿名内部类常用于实现接口。例如，假设有一个接口<code>Greeting</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> knowledge.oop.inner.anonymous;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Usb</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke_usb</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Usb</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Usb</span>() &#123;    This an anonymous class.</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Phone connected the USB interface successfully.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;  <span class="comment">//Don&#x27;s forget the last semicolon.</span></span><br><span class="line"> </span><br><span class="line">        phone.connect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        solution.invoke_usb();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，对于phone引用来讲，它的编译类型是Usb型，也就是Usb接口，而它的<strong>运行类型是****匿名内部类</strong>。该匿名内部类此时的默认类名是“外部类类名 + $1”</p><p><strong>.class文件：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution$1</span> <span class="keyword">implements</span> <span class="title class_">Usb</span> &#123;   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Phone connected the USB interface successfully.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承类"><a href="#继承类" class="headerlink" title="继承类"></a>继承类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Some generic sound&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用匿名内部类继承Animal类</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Bark!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        dog.makeSound(); <span class="comment">// 输出：Bark!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带参数的匿名内部类"><a href="#带参数的匿名内部类" class="headerlink" title="带参数的匿名内部类"></a>带参数的匿名内部类</h3><p>如果父类或接口的构造器需要参数，可以在创建匿名内部类时传递参数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">introduce</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;My name is &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用匿名内部类继承Person类并传递参数</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">introduce</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hi, I&#x27;m &quot;</span> + name + <span class="string">&quot; (from anonymous class)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        person.introduce(); <span class="comment">// 输出：Hi, I&#x27;m Alice (from anonymous class)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问外部变量"><a href="#访问外部变量" class="headerlink" title="访问外部变量"></a>访问外部变量</h3><p>匿名内部类可以访问外部方法中的局部变量，但这些变量必须是<code>final</code> 或者是实际上不可变的（从Java 8开始）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;The number is: &quot;</span> + number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        task.run(); <span class="comment">// 输出：The number is: 42</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><h2 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h2><p>枚举（Enum） 是一种特殊的类，用于定义一组固定的常量。枚举类型非常适合表示一组固定的值，例如星期几、颜色、状态等</p><h2 id="枚举使用"><a href="#枚举使用" class="headerlink" title="枚举使用"></a>枚举使用</h2><ol><li>将构造器私有化，使其不能被随随便便地new出对象</li><li>取消类中提供的setXxx方法，仅保留getXxx方法</li><li>在定义类时，使用enum关键字替换掉class关键字。enum关键字用于声明枚举类</li><li><strong>常量名（<strong><strong>形参</strong></strong>列表）</strong></li><li>如果有多个常量对象，使用逗号’,’间隔即可</li><li>如果使用enum来实现枚举，语法规定常量必须写在类的最前面，否则报错</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Week</span> &#123;</span><br><span class="line">    <span class="comment">//定义Week的枚举对象</span></span><br><span class="line">    MONDAY(<span class="string">&quot;星期一&quot;</span>), TUESDAY(<span class="string">&quot;星期二&quot;</span>), WEDNESDAY(<span class="string">&quot;星期三&quot;</span>), THURSDAY(<span class="string">&quot;星期四&quot;</span>),</span><br><span class="line">    FRIDAY(<span class="string">&quot;星期五&quot;</span>), SATURDAY(<span class="string">&quot;星期六&quot;</span>), SUNDAY(<span class="string">&quot;星期日&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Week</span><span class="params">(String name)</span> &#123;<span class="comment">//构造器</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumExercise02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取到所有的枚举对象， 即数组</span></span><br><span class="line">        Week[] weeks = Week.values();</span><br><span class="line">        <span class="comment">//遍历，使用增强for</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===所有星期的信息如下===&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Week week : weeks) &#123;</span><br><span class="line">            System.out.println(week);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">===所有星期的信息如下===</span><br><span class="line">星期一</span><br><span class="line">星期二</span><br><span class="line">星期三</span><br><span class="line">星期四</span><br><span class="line">星期五</span><br><span class="line">星期六</span><br><span class="line">星期日</span><br></pre></td></tr></table></figure><h2 id="枚举类常用方法"><a href="#枚举类常用方法" class="headerlink" title="枚举类常用方法"></a><strong>枚举类常用方法</strong></h2><p>使用了enum关键字来声明枚举类，则声明的枚举类默认继承了Enum类，并且底层默认是一个final类</p><table><thead><tr><th align="left">方法名</th><th align="left"></th></tr></thead><tbody><tr><td align="left"><code>values()</code></td><td align="left">返回枚举的所有实例数组</td></tr><tr><td align="left"><code>valueOf(String)</code></td><td align="left">根据名称返回对应的枚举实例</td></tr><tr><td align="left"><code>name()</code></td><td align="left">返回枚举常量的名称</td></tr><tr><td align="left"><code>ordinal()</code></td><td align="left">返回枚举常量的序号（从0开始）</td></tr><tr><td align="left"><code>toString()</code></td><td align="left">返回枚举常量的字符串表示，默认为名称</td></tr><tr><td align="left"><code>equals(Object)</code></td><td align="left">比较两个枚举是否相等</td></tr><tr><td align="left"><code>compareTo(E)</code></td><td align="left">比较两个枚举的顺序（基于<code>ordinal</code>）</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//使用Season2 枚举类，来演示各种方法</span></span><br><span class="line">        <span class="type">Season2</span> <span class="variable">autumn</span> <span class="operator">=</span> Season2.AUTUMN;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出枚举对象的名字</span></span><br><span class="line">        System.out.println(autumn.name());</span><br><span class="line">        <span class="comment">//ordinal() 输出的是该枚举对象的次序/编号，从0开始编号</span></span><br><span class="line">        <span class="comment">//AUTUMN 枚举对象是第三个，因此输出 2</span></span><br><span class="line">        System.out.println(autumn.ordinal());</span><br><span class="line">        <span class="comment">//从反编译可以看出 values方法，返回 Season2[]</span></span><br><span class="line">        <span class="comment">//含有定义的所有枚举对象</span></span><br><span class="line">        Season2[] values = Season2.values();</span><br><span class="line">        System.out.println(<span class="string">&quot;===遍历取出枚举对象(增强for)====&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Season2 season : values) &#123;<span class="comment">//增强for循环</span></span><br><span class="line">            System.out.println(season);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//valueOf：将字符串转换成枚举对象，要求字符串必须为已有的常量名，否则报异常</span></span><br><span class="line">        <span class="comment">//执行流程</span></span><br><span class="line">        <span class="comment">//1. 根据你输入的 &quot;AUTUMN&quot; 到 Season2的枚举对象去查找</span></span><br><span class="line">        <span class="comment">//2. 如果找到了，就返回，如果没有找到，就报错</span></span><br><span class="line">        <span class="type">Season2</span> <span class="variable">autumn1</span> <span class="operator">=</span> Season2.valueOf(<span class="string">&quot;AUTUMN&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;autumn1=&quot;</span> + autumn1);</span><br><span class="line">        System.out.println(autumn == autumn1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//compareTo：比较两个枚举常量，比较的就是编号</span></span><br><span class="line">        <span class="comment">//老韩解读</span></span><br><span class="line">        <span class="comment">//1. 就是把 Season2.AUTUMN 枚举对象的编号 和 Season2.SUMMER枚举对象的编号比较</span></span><br><span class="line">        <span class="comment">//2. 看看结果</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        public final int compareTo(E o) &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            return self.ordinal - other.ordinal;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        Season2.AUTUMN的编号[2] - Season2.SUMMER的编号[3]</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(Season2.AUTUMN.compareTo(Season2.SUMMER));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season2</span> &#123;<span class="comment">//类</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;温暖&quot;</span>), WINTER(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;寒冷&quot;</span>), AUTUMN(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;凉爽&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;炎热&quot;</span>)<span class="comment">/*, What()*/</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc;<span class="comment">//描述</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season2</span><span class="params">()</span> &#123;<span class="comment">//无参构造器</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season2</span><span class="params">(String name, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, desc=&#x27;&quot;</span> + desc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">AUTUMN</span><br><span class="line"><span class="number">2</span></span><br><span class="line">===遍历取出枚举对象(增强<span class="keyword">for</span>)====</span><br><span class="line">Season&#123;name=<span class="string">&#x27;春天&#x27;</span>, desc=<span class="string">&#x27;温暖&#x27;</span>&#125;</span><br><span class="line">Season&#123;name=<span class="string">&#x27;冬天&#x27;</span>, desc=<span class="string">&#x27;寒冷&#x27;</span>&#125;</span><br><span class="line">Season&#123;name=<span class="string">&#x27;秋天&#x27;</span>, desc=<span class="string">&#x27;凉爽&#x27;</span>&#125;</span><br><span class="line">Season&#123;name=<span class="string">&#x27;夏天&#x27;</span>, desc=<span class="string">&#x27;炎热&#x27;</span>&#125;</span><br><span class="line">autumn1=Season&#123;name=<span class="string">&#x27;秋天&#x27;</span>, desc=<span class="string">&#x27;凉爽&#x27;</span>&#125;</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="枚举实现接口"><a href="#枚举实现接口" class="headerlink" title="枚举实现接口"></a>枚举实现接口</h2><ol><li>使用enum关键字声明枚举类之后，该枚举类不可以再去继承其他类。这是因为，我们之前通过javap命令反编译枚举类后，可以看到枚举类在底层隐式继承了Enum类。而Java是单继承机制，不支持多继承。所以在枚举类后使用extends关键字，IDEA会报错</li><li>num关键字声明的枚举类虽然不能再去继承其他类了，但是可以实现接口</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Action</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">perform</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Command</span> <span class="keyword">implements</span> <span class="title class_">Action</span> &#123;</span><br><span class="line">    START &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">perform</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Starting...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    STOP &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">perform</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Stopping...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">perform</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Command.START.perform(); <span class="comment">// 输出: Starting...</span></span><br><span class="line">        Command.STOP.perform();  <span class="comment">// 输出: Stopping...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举与switch语句"><a href="#枚举与switch语句" class="headerlink" title="枚举与switch语句"></a>枚举与<code>switch</code>语句</h2><p>枚举可以直接用于<code>switch</code>语句中，简化代码逻辑</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    ADD, SUBTRACT, MULTIPLY, DIVIDE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Operation</span> <span class="variable">operation</span> <span class="operator">=</span> Operation.ADD;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (operation) &#123;</span><br><span class="line">            <span class="keyword">case</span> ADD:</span><br><span class="line">                System.out.println(<span class="string">&quot;Performing addition.&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SUBTRACT:</span><br><span class="line">                System.out.println(<span class="string">&quot;Performing subtraction.&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MULTIPLY:</span><br><span class="line">                System.out.println(<span class="string">&quot;Performing multiplication.&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DIVIDE:</span><br><span class="line">                System.out.println(<span class="string">&quot;Performing division.&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Unknown operation.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举的注意事项"><a href="#枚举的注意事项" class="headerlink" title="枚举的注意事项"></a>枚举的注意事项</h2><ol><li>枚举不能被继承：<ol><li>枚举类型隐式地继承了<code>java.lang.Enum</code>，因此不能再显式继承其他类。</li></ol></li><li>枚举不能被实例化：<ol><li>枚举的实例由Java编译器自动生成，无法通过<code>new</code>关键字创建。</li></ol></li><li>枚举值是常量：<ol><li>枚举值一旦定义后不可更改。</li></ol></li><li>枚举的性能开销较小：<ol><li>枚举的实例数量是固定的，因此内存占用较小</li></ol></li></ol><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h2><p>Java注解是一种元数据类型，它为代码提供额外的信息，但不会直接影响程序的逻辑，注解可以被编译器，开发工具或运行时环境使用，可用于修饰或者解释包、类、方法、属性、构造器，局部变量等数据信息</p><h2 id="常见的内置注解"><a href="#常见的内置注解" class="headerlink" title="常见的内置注解"></a>常见的内置注解</h2><p>使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成一个修饰符使用。用于修饰它支持的程序元素</p><ol><li><strong><code>@Override</code>：</strong><ol><li>表示一个方法重写了父类的方法。</li><li>如果方法签名不匹配，编译器会报错</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Overridden method&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong><code>@Deprecated</code>：</strong><ol><li>标记某个方法或类已过时，不推荐使用</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">oldMethod</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong><code>@SuppressWarnings</code>：</strong><ol><li>抑制编译器警告</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">oldMethod</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong><code>@FunctionalInterface</code>（从Java 8开始）</strong><ol><li>标记一个接口是函数式接口（只有一个抽象方法）</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyFunctionalInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>元注解用于描述其他注解的行为和范围</p><ol><li><strong><code>@Retention</code>：</strong><ol><li>指定注解的保留策略</li><li>常见的值：<ul><li><code>RetentionPolicy.SOURCE</code>：注解仅保留在源码中，编译后丢弃</li><li><code>RetentionPolicy.CLASS</code>：注解保留在<code>.class</code>文件中，但运行时不可用。</li><li><code>RetentionPolicy.RUNTIME</code>：注解保留在运行时，可通过反射访问</li></ul></li></ol></li><li><strong><code>@Target</code>：</strong><ol><li>指定注解可以使用的范围。</li><li>常见的值：<ul><li><code>ElementType.TYPE</code>：类、接口或枚举</li><li><code>ElementType.FIELD</code>：字段</li><li><code>ElementType.METHOD</code>：方法</li><li><code>ElementType.PARAMETER</code>：方法参数</li><li><code>ElementType.CONSTRUCTOR</code>：构造方法</li></ul></li></ol></li><li><strong><code>@Documented</code>：</strong><ol><li>表示注解应包含在Javadoc中</li></ol></li><li><strong><code>@Inherited</code>：</strong><ol><li>表示注解可以被子类继承</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础知识</title>
      <link href="/2025/04/24/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2025/04/24/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-变量"><a href="#1-变量" class="headerlink" title="1.变量"></a>1.变量</h1><h2 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h2><p>变量相当于内存中一个数据存储空间</p><h2 id="1-2-格式"><a href="#1-2-格式" class="headerlink" title="1.2 格式"></a>1.2 格式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型 变量名 = 数据值；</span><br></pre></td></tr></table></figure><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VariableDemo</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">                <span class="comment">//定义一个整数类型的变量</span></span><br><span class="line">                <span class="comment">//数据类型 变量名 = 数据值;</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">                System.out.println(a);<span class="comment">//16</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//定义一个小数类型的变量</span></span><br><span class="line">                <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10.1</span>;</span><br><span class="line">                System.out.println(b);<span class="comment">//10.1</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>变量必须先声名，后使用</li><li>变量在同一个作用域内不能重名</li></ol><h2 id="1-3-程序中-号的使用"><a href="#1-3-程序中-号的使用" class="headerlink" title="1.3 程序中+号的使用"></a>1.3 程序中+号的使用</h2><ol><li>当作用两边都是数值型时，做加法运算</li><li>当左右两边有一方为字符串，做拼接运算</li><li>运算顺序，是从左到右</li></ol><p><strong>案例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Plus</span> &#123; </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">                System.out.println(<span class="number">100</span> + <span class="number">98</span>); <span class="comment">//198</span></span><br><span class="line">                System.out.println(<span class="string">&quot;100&quot;</span> + <span class="number">98</span>);<span class="comment">//10098</span></span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="number">100</span> + <span class="number">3</span> + <span class="string">&quot;hello&quot;</span>);<span class="comment">//103hello</span></span><br><span class="line">                System.out.println(<span class="string">&quot;hello&quot;</span> + <span class="number">100</span> +<span class="number">3</span>); <span class="comment">//hello1003</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2.数据类型"></a>2.数据类型</h1><p>Java 是一种强类型的编程语言，它对变量的数据类型有严格的限定，在定义变量是必须声名变量的数据类型，在为变量赋值时必须赋予与变量同一种类型的值</p><p><img src="https://pic1.imgdb.cn/item/680953bc58cb8da5c8c6c814.png" alt="img"></p><h2 id="2-1-整数类型"><a href="#2-1-整数类型" class="headerlink" title="2.1 整数类型"></a>2.1 整数类型</h2><table><thead><tr><th>数据类型</th><th>内存空间（8 位等于 1 字节）</th><th>取值范围</th></tr></thead><tbody><tr><td>byte</td><td>8 位（1 字节）</td><td>-128~ 127</td></tr><tr><td>short</td><td>16 位（2 字节）</td><td>-32768~ 32767</td></tr><tr><td>int</td><td>32 位（4 字节）</td><td>-2147483648~ 2147483647</td></tr><tr><td>long</td><td>64 位（8 字节）</td><td>-9223372036854775808~ 9223372036854775807</td></tr></tbody></table><p><strong>注意：</strong></p><ul><li>Java 的整数类型默认为 int 类型，声名 long 类型须加上 ‘l’ 或 ‘L’</li></ul><p><strong>案例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntDetail</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//1.定义byte类型的变量</span></span><br><span class="line">        <span class="comment">//数据类型 变量名 = 数据值;</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.定义short类型的变量</span></span><br><span class="line">        <span class="type">short</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        System.out.println(b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.定义int类型的变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">        System.out.println(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.定义long类型的变量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">123456789123456789L</span>;</span><br><span class="line">        System.out.println(d);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-浮点类型"><a href="#2-2-浮点类型" class="headerlink" title="2.2 浮点类型"></a>2.2 浮点类型</h2><p>浮点类型用来存储含有小数部分的数值</p><table><thead><tr><th>数据类型</th><th>内存空间（8 位等于 1 字节）</th><th>取值范围</th></tr></thead><tbody><tr><td>float</td><td>32 位（4 字节）</td><td>1.4E-45~ 3.4028235E38</td></tr><tr><td>double</td><td>64 位（8 字节）</td><td>4.9E-324~ 1.7976931348623157E308</td></tr></tbody></table><p><strong>注意：</strong></p><ol><li>浮点数在机器中存放的形式是：浮点数&#x3D;符号位+指数位+尾数位</li><li>尾数部分可能丢失，造成精度损失（小数都是近似值）</li><li>浮点数的默认类型是 double 型声名 float 型时须加上 ‘f’或‘F’</li><li>double 类型表示的浮点数比 float 类型更精确</li></ol><p><strong>案例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">doubleDetail</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.定义float类型的变量</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">e</span> <span class="operator">=</span> <span class="number">10.1F</span>;</span><br><span class="line">        System.out.println(e);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.定义double类型的变量</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">20.3</span>;</span><br><span class="line">        System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-字符类型"><a href="#2-3-字符类型" class="headerlink" title="2.3 字符类型"></a>2.3 字符类型</h2><p>字符类型（char）用于存储单个字符，占用 16 位（两个字节）的内存空间</p><p><strong>注意：</strong></p><ol><li>字符类型要用单引号（‘ ’）括起来</li><li>Java 中，char 类型本质上是一个整数，在输出时，是 Unicode 码对应的字符</li><li>可以直接给 char 赋一个整数，然后输出是，会按照对应的 Unicode 字符输出</li><li>char 类型可以进行运算</li></ol><p><strong>案例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharDetail</span> &#123; </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">                <span class="comment">//在java中，char的本质是一个整数，在默认输出时，是unicode码对应的字符</span></span><br><span class="line">                <span class="comment">//要输出对应的数字，可以(int)字符</span></span><br><span class="line">                <span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="number">97</span>;</span><br><span class="line">                System.out.println(c1); <span class="comment">// a</span></span><br><span class="line"></span><br><span class="line">                <span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>; <span class="comment">//输出&#x27;a&#x27; 对应的 数字</span></span><br><span class="line">                System.out.println((<span class="type">int</span>)c2);</span><br><span class="line">                <span class="type">char</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="string">&#x27;韩&#x27;</span>;</span><br><span class="line">                System.out.println((<span class="type">int</span>)c3);<span class="comment">//38889</span></span><br><span class="line">                <span class="type">char</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="number">38889</span>;</span><br><span class="line">                System.out.println(c4);<span class="comment">//韩</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//char类型是可以进行运算的，相当于一个整数，因为它都对应有Unicode码.</span></span><br><span class="line">                </span><br><span class="line">                System.out.println(<span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>);<span class="comment">//107</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-转义字符"><a href="#2-4-转义字符" class="headerlink" title="2.4 转义字符"></a>2.4 转义字符</h2><table><thead><tr><th>转义字符（ASCII 码值【十进制】）</th><th>意义</th></tr></thead><tbody><tr><td>\b( 008)</td><td>退格（BS），将当前位置移到前一列</td></tr><tr><td>\f( 012)</td><td>换页（FF），将当前位置一道下页开头</td></tr><tr><td>–</td><td>–</td></tr><tr><td>\n( 010)</td><td>换行（LF），将当前位置移到下一行开头</td></tr><tr><td>\r( 013)</td><td>回车（CR），将当前位置移到本行开头</td></tr><tr><td>–</td><td>–</td></tr><tr><td>\t( 009)</td><td>水平制表（HT）（跳到次啊一个 TAB 位置）</td></tr><tr><td>( 092)</td><td>代表一个反斜字符\</td></tr><tr><td>–</td><td>–</td></tr><tr><td>‘( 039)</td><td>代表一个单引号（撤号字符）</td></tr><tr><td>“( 034)</td><td>代表一个双引号字符</td></tr><tr><td>–</td><td>–</td></tr><tr><td>?( 063)</td><td>代表一个问号</td></tr><tr><td>\0( 000)</td><td>空字符（NULL）</td></tr><tr><td>–</td><td>–</td></tr><tr><td>\ddd（三位八进制）</td><td>1 到 3 位八进制数所代表的任意字符</td></tr><tr><td>\xhh（十六进制）</td><td>十六进制所代表的任意字符</td></tr></tbody></table><h2 id="2-5-布尔类型"><a href="#2-5-布尔类型" class="headerlink" title="2.5 布尔类型"></a>2.5 布尔类型</h2><ol><li>布尔类型（boolean）数据只允许取值 true 或 false</li><li>Boolean 类型占 1 字节</li><li>Boolean 类型适用于逻辑运算，一般用于程序流程控制</li></ol><p><strong>案例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Boolean01</span> &#123; </span><br><span class="line">        <span class="comment">//编写一个main方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">                <span class="comment">//演示判断成绩是否通过的案例</span></span><br><span class="line">                <span class="comment">//定义一个布尔变量</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">isPass</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//</span></span><br><span class="line">                <span class="keyword">if</span>(isPass == <span class="literal">true</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;考试通过，恭喜&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;考试没有通过，下次努力&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-6-基本数据类型转换"><a href="#2-6-基本数据类型转换" class="headerlink" title="2.6 基本数据类型转换"></a>2.6 基本数据类型转换</h2><h3 id="2-6-1-自动类型转换"><a href="#2-6-1-自动类型转换" class="headerlink" title="2.6.1 自动类型转换"></a>2.6.1 自动类型转换</h3><p>Java 程序在进行赋值或运算时，精度下的类型自动转换为精度达的数据类型</p><p><strong>数据类型按精度大小排序为：</strong></p><p><img src="https://pic1.imgdb.cn/item/680953bc58cb8da5c8c6c816.png" alt="img"></p><p><strong>注意：</strong></p><ol><li>有多种类型的数据混合运算时，系统首先自动将所有数据转换成精度最大的那种数据类型，然后再进行计算</li><li>（byte，short）和 char 之间不会相互自动转换</li><li>byte，short，char 可以进行计算，在计算时会转换为 int 类型</li><li>Boolean 类型不参与计算</li></ol><p><strong>案例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自动类型转换细节</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoConvertDetail</span> &#123; </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">                <span class="comment">// 有多种类型的数据混合运算时，</span></span><br><span class="line">                <span class="comment">//系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">//ok</span></span><br><span class="line">                <span class="comment">//float d1 = n1 + 1.1;//错误 n1 + 1.1 =&gt; 结果类型是 double</span></span><br><span class="line">                <span class="comment">//double d1 = n1 + 1.1;//对 n1 + 1.1 =&gt; 结果类型是 double</span></span><br><span class="line">                <span class="type">float</span> <span class="variable">d1</span> <span class="operator">=</span> n1 + <span class="number">1.1F</span>;<span class="comment">//对 n1 + 1.1 =&gt; 结果类型是 float</span></span><br><span class="line">        </span><br><span class="line">                <span class="comment">//(byte, short) 和 char之间不会相互自动转换</span></span><br><span class="line">                <span class="comment">//当把具体数赋给 byte 时，(1)先判断该数是否在byte范围内，如果是就可以</span></span><br><span class="line">                <span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">//对  , -128-127</span></span><br><span class="line">                <span class="comment">// int n2 = 1; //n2 是int </span></span><br><span class="line">                <span class="comment">// byte b2 = n2; //错误，原因： 如果是变量赋值，判断类型</span></span><br><span class="line">                <span class="comment">// char c1 = b1; //错误， 原因 byte 不能自动转成 char</span></span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                <span class="comment">// byte，short，char  他们三者可以计算，在计算时首先转换为int类型</span></span><br><span class="line">                <span class="type">byte</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">                <span class="type">byte</span> <span class="variable">b3</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">                <span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//short s2 = b2 + s1;//错, b2 + s1 =&gt; int</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">s2</span> <span class="operator">=</span> b2 + s1;<span class="comment">//对, b2 + s1 =&gt; int</span></span><br><span class="line">                <span class="comment">//byte b4 = b2 + b3; //错误: b2 + b3 =&gt; int</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//boolean 不参与转换</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">pass</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//int num100 = pass;// boolean 不参与类型的自动转换</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-2-强制类型转换"><a href="#2-6-2-强制类型转换" class="headerlink" title="2.6.2 强制类型转换"></a>2.6.2 强制类型转换</h3><p>强制类型转换的逆过程，<strong>将容量大的数据类型转换为容量小的数据类型</strong>，使用时要加上强制转换符 （ ），但可能造成精度降低或溢出</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForceConvert</span> &#123; </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">                <span class="comment">//演示强制类型转换</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1.9</span>;</span><br><span class="line">                System.out.println(<span class="string">&quot;n1=&quot;</span> + n1);<span class="comment">//1, 造成精度损失</span></span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">2000</span>;</span><br><span class="line">                <span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> (<span class="type">byte</span>)n2;</span><br><span class="line">                System.out.println(<span class="string">&quot;b1=&quot;</span> + b1);<span class="comment">//造成 数据溢出</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-7-基本数据类型和-String-类型的转换"><a href="#2-7-基本数据类型和-String-类型的转换" class="headerlink" title="2.7 基本数据类型和 String 类型的转换"></a>2.7 基本数据类型和 String 类型的转换</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringToBasic</span> &#123; </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">                <span class="comment">//基本数据类型-&gt;String</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">                <span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">1.1F</span>;</span><br><span class="line">                <span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="number">4.5</span>;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> n1 + <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> f1 + <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> d1 + <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> b1 + <span class="string">&quot;&quot;</span>;</span><br><span class="line">                System.out.println(s1 + <span class="string">&quot; &quot;</span> + s2 + <span class="string">&quot; &quot;</span> + s3 + <span class="string">&quot; &quot;</span> + s4);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//String-&gt;对应的基本数据类型</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">                <span class="comment">//会在OOP 讲对象和方法的时候回详细</span></span><br><span class="line">                <span class="comment">//解读 使用 基本数据类型对应的包装类，的相应方法，得到基本数据类型</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.parseInt(s5);</span><br><span class="line">                <span class="type">double</span> <span class="variable">num2</span> <span class="operator">=</span> Double.parseDouble(s5);</span><br><span class="line">                <span class="type">float</span> <span class="variable">num3</span> <span class="operator">=</span> Float.parseFloat(s5);</span><br><span class="line">                <span class="type">long</span> <span class="variable">num4</span> <span class="operator">=</span> Long.parseLong(s5);</span><br><span class="line">                <span class="type">byte</span> <span class="variable">num5</span> <span class="operator">=</span> Byte.parseByte(s5);</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> Boolean.parseBoolean(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">                <span class="type">short</span> <span class="variable">num6</span> <span class="operator">=</span> Short.parseShort(s5);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;===================&quot;</span>);</span><br><span class="line">                System.out.println(num1);<span class="comment">//123</span></span><br><span class="line">                System.out.println(num2);<span class="comment">//123.0</span></span><br><span class="line">                System.out.println(num3);<span class="comment">//123.0</span></span><br><span class="line">                System.out.println(num4);<span class="comment">//123</span></span><br><span class="line">                System.out.println(num5);<span class="comment">//123</span></span><br><span class="line">                System.out.println(num6);<span class="comment">//123</span></span><br><span class="line">                System.out.println(b);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//怎么把字符串转成字符char -&gt; 含义是指 把字符串的第一个字符得到</span></span><br><span class="line">                <span class="comment">//解读  s5.charAt(0) 得到 s5字符串的第一个字符 &#x27;1&#x27;</span></span><br><span class="line">                System.out.println(s5.charAt(<span class="number">0</span>));</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>在将 String 类型转成 基本数据类型时， ，比如 我们可以把 “123” ， 转成一个整数，但是不能把 “hello” 转成一个整数</p><ol><li>如果格式不正确，就会抛出异常，程序就会终止</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示字符串转基本数据类型的细节</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringToBasicDetail</span> &#123; </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">                <span class="comment">//转成int</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> Integer.parseInt(str);</span><br><span class="line">                System.out.println(n1);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-数组"><a href="#3-数组" class="headerlink" title="3.数组"></a>3.数组</h1><p>数组是用来存储同一种数据类型的多个元素的容器，数组也是一种数据类型，是引用类型</p><h2 id="3-1-创建数组"><a href="#3-1-创建数组" class="headerlink" title="3.1 创建数组"></a>3.1 创建数组</h2><ol><li><strong>动态初始化</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[] 数据名=<span class="keyword">new</span> 数据类型[大小];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] a1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>]; </span><br><span class="line">数据类型[] 数据名;</span><br><span class="line">数组名=<span class="keyword">new</span> 数据类型[大小];</span><br><span class="line"><span class="type">int</span>[] x;</span><br><span class="line">x=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];</span><br></pre></td></tr></table></figure><ol><li><strong>静态初始化</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[] 数组名 = &#123;元素<span class="number">1</span>，元素<span class="number">2</span>，元素<span class="number">3</span>，...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] a3 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ol><li>数组是多个相同类型数据的组合，实现对这些数据的统一管理</li><li>数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用</li><li>数组创建后，如果没有赋值，有默认值：int 0，short 0, byte 0, long 0, float 0.0,double 0.0，char \u0000，boolean false，String null</li><li>使用数组的步骤 1. 声明数组并开辟空间 2 给数组各个元素赋值 3 使用数组</li><li>数组的下标是从 0 开始的</li><li>数组下标必须在指定范围内使用，否则报：下标越界异常</li><li>数组属引用类型，数组型数据是对象(object)</li></ol><p><strong>案例：</strong></p><ol><li>创建一个 char 类型的 26 个元素的数组，分别 放置’A’-‘Z’。使用 for 循环访问所有元素并打印出来</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayExercise01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ch = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ch.length; i++) &#123;</span><br><span class="line">            ch[i] = (<span class="type">char</span>) (<span class="string">&#x27;A&#x27;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ch.length; i++) &#123;</span><br><span class="line">            System.out.print(ch[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>请求出一个数组 int[]的最大值 {4,-1,9, 10,23}，并得到对应的下标</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayExercise02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] num = &#123;<span class="number">4</span>, -<span class="number">1</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">23</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> num[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">sub</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[i] &gt; max) &#123;</span><br><span class="line">                max = num[i];</span><br><span class="line">                sub = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;最大值：&quot;</span> + max);</span><br><span class="line">        System.out.println(<span class="string">&quot;下标：&quot;</span> + sub);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-数组赋值机制"><a href="#3-2-数组赋值机制" class="headerlink" title="3.2 数组赋值机制"></a>3.2 数组赋值机制</h2><ol><li>基本数据类型赋值，这个值就是具体的数据，而且相互不影响</li><li>数组在默认情况下是引用类型，赋的值是地址</li></ol><p>暂时无法在飞书文档外展示此内容</p><h2 id="3-3-数组拷贝"><a href="#3-3-数组拷贝" class="headerlink" title="3.3 数组拷贝"></a>3.3 数组拷贝</h2><p>将 int[] arr1 &#x3D; {10,20,30}; 拷贝到 arr2 数组, 要求数据空间是独立的</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayCopy</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个main方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 int[] arr1 = &#123;10,20,30&#125;; 拷贝到 arr2数组, </span></span><br><span class="line">        <span class="comment">//要求数据空间是独立的.</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] arr1 = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一个新的数组arr2,开辟新的数据空间</span></span><br><span class="line">        <span class="comment">//大小 arr1.length;</span></span><br><span class="line">        <span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="type">int</span>[arr<span class="number">1.l</span>ength];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历 arr1 ，把每个元素拷贝到arr2对应的元素位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr<span class="number">1.l</span>ength; i++) &#123;</span><br><span class="line">            arr2[i] = arr1[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改 arr2， 不会对arr1有影响.</span></span><br><span class="line">        arr2[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出arr1 </span></span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;====arr1的元素====&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr<span class="number">1.l</span>ength; i++) &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(arr1[i]);<span class="comment">//10,20,30</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;====arr2的元素====&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr<span class="number">2.l</span>ength; i++) &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(arr2[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-数组反转"><a href="#3-4-数组反转" class="headerlink" title="3.4 数组反转"></a>3.4 数组反转</h2><p>要求：把数组的元素内容反转</p><p>arr {11,22,33,44,55,66} -&gt;{66, 55,44,33,22,11}</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayReverse</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个main方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">66</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length; <span class="comment">//计算数组的长度</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            temp = arr[len - <span class="number">1</span> - i];<span class="comment">//保存</span></span><br><span class="line">            arr[len - <span class="number">1</span> - i] = arr[i];</span><br><span class="line">            arr[i] = temp; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===翻转后数组===&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot;\t&quot;</span>);<span class="comment">//66,55,44,33,22,11</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-数组添加-扩容"><a href="#3-5-数组添加-扩容" class="headerlink" title="3.5 数组添加&#x2F;扩容"></a>3.5 数组添加&#x2F;扩容</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayAdd02</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个main方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        要求：实现动态的给数组添加元素效果，实现对数组扩容。ArrayAdd.java</span></span><br><span class="line"><span class="comment">        1.原始数组使用静态分配 int[] arr = &#123;1,2,3&#125;</span></span><br><span class="line"><span class="comment">        2.增加的元素4，直接放在数组的最后 arr = &#123;1,2,3,4&#125;</span></span><br><span class="line"><span class="comment">        3.用户可以通过如下方法来决定是否继续添加，添加成功，是否继续？y/n</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">myScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//初始化数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="type">int</span>[] arrNew = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length + <span class="number">1</span>];</span><br><span class="line">            <span class="comment">//遍历 arr 数组，依次将arr的元素拷贝到 arrNew数组</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                arrNew[i] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入你要添加的元素&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">addNum</span> <span class="operator">=</span> myScanner.nextInt();</span><br><span class="line">            <span class="comment">//把addNum赋给arrNew最后一个元素</span></span><br><span class="line">            arrNew[arrNew.length - <span class="number">1</span>] = addNum;</span><br><span class="line">            <span class="comment">//让 arr 指向 arrNew, </span></span><br><span class="line">            arr = arrNew;</span><br><span class="line">            <span class="comment">//输出arr 看看效果</span></span><br><span class="line">            System.out.println(<span class="string">&quot;====arr扩容后元素情况====&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                System.out.print(arr[i] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//问用户是否继续</span></span><br><span class="line">            System.out.println(<span class="string">&quot;是否继续添加 y/n&quot;</span>);</span><br><span class="line">            <span class="type">char</span> <span class="variable">key</span> <span class="operator">=</span> myScanner.next().charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>( key == <span class="string">&#x27;n&#x27;</span>) &#123; <span class="comment">//如果输入n ,就结束</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;你退出了添加...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-6-冒泡排序"><a href="#3-6-冒泡排序" class="headerlink" title="3.6 冒泡排序"></a>3.6 冒泡排序</h2><p>冒泡排序(double sort)通过连续的比较与交换相邻元素实现排序，这个过程就像气泡从底部升到顶部一样</p><p><strong>动画演示：</strong></p><p><img src="https://pic1.imgdb.cn/item/680953bb58cb8da5c8c6c813.gif" alt="img"></p><p><strong>算法流程：</strong></p><p>设数组的长度为 (n) </p><ol><li>首先，对 (n) 个元素执行“冒泡”，<strong>将数组的最大元素交换至正确位置</strong></li><li>接下来，对剩余 (n - 1) 个元素执行“冒泡”，<strong>将第二大元素交换至正确位置</strong></li><li>以此类推，经过 (n - 1) 轮“冒泡”后，<strong>前 (n - 1) 大的元素都被交换至正确位置</strong></li><li>仅剩的一个元素必定是最小元素，无须排序，因此数组排序完成</li></ol><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">24</span>, <span class="number">69</span>, <span class="number">80</span>, <span class="number">57</span>, <span class="number">13</span>&#125;;</span><br><span class="line">        <span class="comment">// 外循环：未排序区间为 [0, i]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="comment">//比较相邻的两个元素</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 交换 arr[j] 与 arr[j + 1]</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出排序后数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);<span class="comment">//13 24 57 69 80</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-7-顺序查找"><a href="#3-7-顺序查找" class="headerlink" title="3.7 顺序查找"></a>3.7 顺序查找</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeqSearch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] names = &#123;<span class="string">&quot;白眉鹰王&quot;</span>, <span class="string">&quot;金毛狮王&quot;</span>, <span class="string">&quot;紫衫龙王&quot;</span>, <span class="string">&quot;青翼蝠王&quot;</span>&#125;;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">myScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入名字&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">findName</span> <span class="operator">=</span> myScanner.next();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; names.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (findName.equals(names[i])) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;恭喜你找到 &quot;</span> + findName);</span><br><span class="line">                System.out.println(<span class="string">&quot;下标为= &quot;</span> + i);</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//退出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123; <span class="comment">//没有找到</span></span><br><span class="line">            System.out.println(<span class="string">&quot;sorry ,没有找到 &quot;</span> + findName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-8-二维数组"><a href="#3-8-二维数组" class="headerlink" title="3.8 二维数组"></a>3.8 二维数组</h2><h3 id="3-8-1-创建二维数组"><a href="#3-8-1-创建二维数组" class="headerlink" title="3.8.1 创建二维数组"></a>3.8.1 创建二维数组</h3><ol><li><strong>动态初始化</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[][] 数组名=<span class="keyword">new</span> 数据类型[大小];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">4</span>]; </span><br><span class="line">数据类型[] 数组名;</span><br><span class="line">数组名=<span class="keyword">new</span> 数据类型[大小];</span><br><span class="line"><span class="type">int</span>[][] x;</span><br><span class="line">x=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][];</span><br></pre></td></tr></table></figure><p>暂时无法在飞书文档外展示此内容</p><ol><li><strong>静态初始化</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[][] 数组名 = &#123;&#123;第<span class="number">0</span>行初始化&#125;，&#123;第<span class="number">1</span>行初始化&#125;，&#123;第<span class="number">2</span>行初始化&#125;，...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[][] arr = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>暂时无法在飞书文档外展示此内容</p><h3 id="3-8-2-二维数组赋值机制"><a href="#3-8-2-二维数组赋值机制" class="headerlink" title="3.8.2 二维数组赋值机制"></a>3.8.2 二维数组赋值机制</h3><p>暂时无法在飞书文档外展示此内容</p><h3 id="3-8-3-杨辉三角"><a href="#3-8-3-杨辉三角" class="headerlink" title="3.8.3 杨辉三角"></a>3.8.3 杨辉三角</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YangHui</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][];</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = <span class="keyword">new</span> <span class="title class_">int</span>[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">                <span class="comment">//每行第一个元素和最后一个元素为1</span></span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span> || j == arr[i].length - <span class="number">1</span>) &#123;</span><br><span class="line">                    arr[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//其他元素为上一行的两数相加</span></span><br><span class="line">                    arr[i][j] = arr[i - <span class="number">1</span>][j - <span class="number">1</span>] + arr[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历输出二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//输出空格</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> arr.length - <span class="number">1</span> - i; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">                System.out.print(arr[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">          <span class="number">1</span> </span><br><span class="line">         <span class="number">1</span> <span class="number">1</span> </span><br><span class="line">        <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> </span><br><span class="line">       <span class="number">1</span> <span class="number">3</span> <span class="number">3</span> <span class="number">1</span> </span><br><span class="line">      <span class="number">1</span> <span class="number">4</span> <span class="number">6</span> <span class="number">4</span> <span class="number">1</span> </span><br><span class="line">     <span class="number">1</span> <span class="number">5</span> <span class="number">10</span> <span class="number">10</span> <span class="number">5</span> <span class="number">1</span> </span><br><span class="line">    <span class="number">1</span> <span class="number">6</span> <span class="number">15</span> <span class="number">20</span> <span class="number">15</span> <span class="number">6</span> <span class="number">1</span> </span><br><span class="line">   <span class="number">1</span> <span class="number">7</span> <span class="number">21</span> <span class="number">35</span> <span class="number">35</span> <span class="number">21</span> <span class="number">7</span> <span class="number">1</span> </span><br><span class="line">  <span class="number">1</span> <span class="number">8</span> <span class="number">28</span> <span class="number">56</span> <span class="number">70</span> <span class="number">56</span> <span class="number">28</span> <span class="number">8</span> <span class="number">1</span> </span><br><span class="line"> <span class="number">1</span> <span class="number">9</span> <span class="number">36</span> <span class="number">84</span> <span class="number">126</span> <span class="number">126</span> <span class="number">84</span> <span class="number">36</span> <span class="number">9</span> <span class="number">1</span> </span><br></pre></td></tr></table></figure><h1 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4.运算符"></a>4.运算符</h1><h2 id="4-1-算术运算符"><a href="#4-1-算术运算符" class="headerlink" title="4.1 算术运算符"></a>4.1 算术运算符</h2><p>表格中的实例假设整数变量A的值为10，变量B的值为20</p><table><thead><tr><th>运算符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>+</td><td>加法 - 相加运算符两侧的值</td><td>A + B 等于 30</td></tr><tr><td>-</td><td>减法 - 左操作数减去右操作数</td><td>A – B 等于 -10</td></tr><tr><td>*</td><td>乘法 - 相乘操作符两侧的值</td><td>A * B等于200</td></tr><tr><td>&#x2F;</td><td>除法 - 左操作数除以右操作数</td><td>B &#x2F; A等于2</td></tr><tr><td>％</td><td>取余 - 左操作数除以右操作数的余数</td><td>B%A等于0</td></tr><tr><td>++</td><td>自增: 操作数的值增加1</td><td>B++ 或 ++B 等于 21</td></tr><tr><td>–</td><td>自减: 操作数的值减少1</td><td>B– 或 –B 等于 19</td></tr></tbody></table><p><strong>自增自减运算符</strong></p><ol><li>当++出现在变量前，会<code>先自加一</code>，在做赋值运算</li><li>当++出现在变量后，会<code>先做赋值运算</code>，再自加1</li><li>当–出现在变量前，会<code>先自减一</code>，在做赋值运算</li><li>当–出现在变量后，会<code>先做赋值运算</code>，再自减1</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArithmeticOperator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//++的使用</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        i++;<span class="comment">//自增 等价与i=i+1;</span></span><br><span class="line">        ++i;<span class="comment">//自增 等价与i=i+1;</span></span><br><span class="line">        System.out.println(i);<span class="comment">//12</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        作为表达式使用</span></span><br><span class="line"><span class="comment">        前++：++i先只增后赋值</span></span><br><span class="line"><span class="comment">        后++；i++先赋值后自增</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> ++a;</span><br><span class="line">        System.out.println(b);<span class="comment">//9</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j++;</span><br><span class="line">        System.out.println(k);<span class="comment">//8</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        i = i++;</span><br><span class="line">        <span class="comment">//规则使用临时变量:</span></span><br><span class="line">        <span class="comment">//temp=i;</span></span><br><span class="line">        <span class="comment">//i=i+1;</span></span><br><span class="line">        <span class="comment">//i=temp</span></span><br><span class="line">        System.out.println(i);<span class="comment">//1</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">                 i=++i; </span><br><span class="line">        <span class="comment">//规则使用临时变量: </span></span><br><span class="line">        <span class="comment">// i=i+1;</span></span><br><span class="line">        <span class="comment">//temp=i;</span></span><br><span class="line">        <span class="comment">//i=temp;</span></span><br><span class="line">                 System.out.println(i); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-关系运算符"><a href="#4-2-关系运算符" class="headerlink" title="4.2 关系运算符"></a>4.2 关系运算符</h2><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&#x3D;&#x3D;</td><td>等于</td></tr><tr><td>!&#x3D;</td><td>不等于</td></tr></tbody></table><p><em><strong>注意</strong></em>：所有的关系运算符的运算结果都是布尔类型，<code>不是true就是false</code>，不可能是其他值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">     <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">     System.out.println(<span class="string">&quot;a == b = &quot;</span> + (a == b) );<span class="comment">//F</span></span><br><span class="line">     System.out.println(<span class="string">&quot;a != b = &quot;</span> + (a != b) );<span class="comment">//T</span></span><br><span class="line">     System.out.println(<span class="string">&quot;a &gt; b = &quot;</span> + (a &gt; b) );<span class="comment">//F</span></span><br><span class="line">     System.out.println(<span class="string">&quot;a &lt; b = &quot;</span> + (a &lt; b) );<span class="comment">//T</span></span><br><span class="line">     System.out.println(<span class="string">&quot;b &gt;= a = &quot;</span> + (b &gt;= a) );<span class="comment">//T</span></span><br><span class="line">     System.out.println(<span class="string">&quot;b &lt;= a = &quot;</span> + (b &lt;= a) );<span class="comment">//F</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-逻辑运算符"><a href="#4-3-逻辑运算符" class="headerlink" title="4.3 逻辑运算符"></a>4.3 逻辑运算符</h2><table><thead><tr><th align="left">操作符</th><th align="left">描述</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">＆</td><td align="left">逻辑与（并且）</td><td align="left">当两边都为true，结果为true,否则为false</td></tr><tr><td align="left">|</td><td align="left">逻辑或（或者）</td><td align="left">有一边是true，结果为true，否则为false</td></tr><tr><td align="left">^</td><td align="left">逻辑异或</td><td align="left">当两边的不同时，结果为true，否则为false</td></tr><tr><td align="left">&amp;&amp;</td><td align="left">短路与（并且）</td><td align="left">当两边都为true，结果为true,否则为false</td></tr><tr><td align="left">||</td><td align="left">短路或（或者）</td><td align="left">有一边是true，结果为true，否则为false</td></tr><tr><td align="left">!</td><td align="left">逻辑非（取反）</td><td align="left">false取反就是true，true取反就是false&#x3D;</td></tr></tbody></table><p><strong>注意</strong></p><ol><li>使用短路与 &amp;&amp; 的时候，当左边的表达式为<code>false</code>的时候，右边的表达式不执行</li><li>使用短路或 || 的时候当左边的表达式结果是<code>true</code>的时候，右边的表达式不执行</li><li>逻辑运算符两边要求都是布尔类型，并且最终的运算结果也是布尔类型</li></ol><h2 id="4-4-赋值运算符"><a href="#4-4-赋值运算符" class="headerlink" title="4.4 赋值运算符"></a>4.4 赋值运算符</h2><table><thead><tr><th align="left">运算符</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">&#x3D;</td><td align="left">赋值</td></tr><tr><td align="left">+&#x3D;</td><td align="left">加等（原先的基础上加上这个数）</td></tr><tr><td align="left">-&#x3D;</td><td align="left">减等（原先的基础上减上这个数）</td></tr><tr><td align="left">*&#x3D;</td><td align="left">乘等（原先的基础上乘上这个数）</td></tr><tr><td align="left">&#x2F;&#x3D;</td><td align="left">除等（原先的基础上除上这个数）</td></tr><tr><td align="left">%&#x3D;</td><td align="left">模等（原先的基础上模上这个数）</td></tr></tbody></table><p>使用<code>扩展赋值运算符</code>的时候，永远都<code>不会改变</code>运算结果类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">n1 += <span class="number">4</span>;<span class="comment">// n1 = n1 + 4;</span></span><br><span class="line">System.out.println(n1); <span class="comment">// 14</span></span><br><span class="line">n1 /= <span class="number">3</span>;<span class="comment">// n1 = n1 / 3;//4</span></span><br><span class="line">System.out.println(n1); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//复合赋值运算符会进行类型转换</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">b += <span class="number">2</span>; <span class="comment">// 等价 b = (byte)(b + 2);</span></span><br><span class="line">b++; <span class="comment">// b = (byte)(b+1);</span></span><br></pre></td></tr></table></figure><h2 id="4-5-三元运算符"><a href="#4-5-三元运算符" class="headerlink" title="4.5 三元运算符"></a>4.5 三元运算符</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">条件表达式 ？表达式<span class="number">1</span> ：表达式<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>运算规则：</p><ol><li>如果条件表达式为true，运算后的结果是表达式1</li><li>如果条件表达式为false，运算后的结果是表达式2</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorDemo12</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//需求：求两个数的较大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//格式：关系表达式 ？ 表达式1 ： 表达式2 ；</span></span><br><span class="line">        <span class="comment">//注意点：</span></span><br><span class="line">        <span class="comment">//三元运算符的最终结果一定要被使用。</span></span><br><span class="line">        <span class="comment">//要么赋值给一个变量，要么直接输出。</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span>  a &gt; b ? a : b ;</span><br><span class="line">        System.out.println(max);<span class="comment">//20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(a &gt; b ? a : b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-6-运算符的优先级"><a href="#4-6-运算符的优先级" class="headerlink" title="4.6 运算符的优先级"></a>4.6 运算符的优先级</h2><p>括号级别最高，逗号级别最低，单目 &gt; 算术 &gt; 位移 &gt; 关系 &gt; 逻辑 &gt; 三目 &gt; 赋值</p><table><thead><tr><th align="left">优先级</th><th align="left">运算符</th><th align="left">结合性</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">( )　[ ] 　.</td><td align="left">从左到右</td></tr><tr><td align="left">2</td><td align="left">! 　~　 ++　 –</td><td align="left">从右到左</td></tr><tr><td align="left">3</td><td align="left">*　 &#x2F;　 %</td><td align="left">从左到右</td></tr><tr><td align="left">4</td><td align="left">+　 -</td><td align="left">从左到右</td></tr><tr><td align="left">5</td><td align="left">&lt;&lt; 　&gt;&gt;　 &gt;&gt;&gt;</td><td align="left">从左到右</td></tr><tr><td align="left">6</td><td align="left">&lt; 　&lt;&#x3D;　 &gt; 　&gt;&#x3D;　 instanceof</td><td align="left">从左到右</td></tr><tr><td align="left">7</td><td align="left">&#x3D;&#x3D; 　!&#x3D;</td><td align="left">从左到右</td></tr><tr><td align="left">8</td><td align="left">&amp;</td><td align="left">从左到右</td></tr><tr><td align="left">9</td><td align="left">^</td><td align="left">从左到右</td></tr><tr><td align="left">10</td><td align="left">&#96;</td><td align="left">&#96;</td></tr><tr><td align="left">11</td><td align="left">&amp;&amp;</td><td align="left">从左到右</td></tr><tr><td align="left">12</td><td align="left">&#96;</td><td align="left"></td></tr><tr><td align="left">13</td><td align="left">? :</td><td align="left">从左到右</td></tr><tr><td align="left">14</td><td align="left">&#x3D; 　+&#x3D; 　-&#x3D; 　*&#x3D;　 &#x2F;&#x3D;　 %&#x3D;　 &amp;&#x3D;　 &#96;</td><td align="left">&#x3D;&#96;　 ^&#x3D;　 ~&#x3D; 　&lt;&lt;&#x3D; 　&gt;&gt;&#x3D;　 &gt;&gt;&gt;&#x3D;</td></tr><tr><td align="left">15</td><td align="left">，</td><td align="left">从右到左</td></tr></tbody></table><h2 id="4-7-标识符"><a href="#4-7-标识符" class="headerlink" title="4.7 标识符"></a>4.7 标识符</h2><ol><li>Java对各种变量，方法和类等命名时使用的字符序列称为标识符</li><li>凡是自己可以起名字的地方都叫标识符</li></ol><p><strong>标识符的命名规则：</strong></p><ol><li>由26个英文字母大小写0-9，下划线_ 或$组成</li><li>数字不可以开头</li><li>不可以使用关键字和保留字，但能包含关键字和保留字</li><li>Java中严格区分大小写，长度无限制</li><li>标识符不能包含空格</li></ol><p><strong>标识符的命名规范:</strong></p><ol><li>包名：多单词组成时所有字母都小写</li><li>类名，接口名：多单词组成时，所有单词都首字母大写</li><li>变量名，方法名：多单词组成时，第一个单词首字母小写，第二单词开始每个单词首字母大写</li><li>常量名：所有字母都大写，多单词时每个单词用下划线连接</li></ol><h2 id="4-8-关键字和保留字"><a href="#4-8-关键字和保留字" class="headerlink" title="4.8 关键字和保留字"></a>4.8 关键字和保留字</h2><p><strong>关键字：</strong></p><p>Java 语言目前定义了 51 个关键字，这些关键字不能作为变量名、类名和方法名来使用</p><table><thead><tr><th align="left">关键字</th><th></th></tr></thead><tbody><tr><td align="left">数据类型</td><td>boolean、int、long、short、byte、float、double、char、class、interface、enum、void</td></tr><tr><td align="left">流程控制</td><td>if、else、do、while、for、switch、case、default、break、continue、return</td></tr><tr><td align="left">异常处理</td><td>try、catch、finally、throw、throws</td></tr><tr><td align="left">修饰符</td><td>public、protected、private、final、void、static、strict、abstract、transient、synchronized、volatile、native</td></tr><tr><td align="left">类与类之间关系</td><td>extends、implements</td></tr><tr><td align="left">建立实例及引用实例</td><td>this、supper、instanceof、new</td></tr><tr><td align="left">导包</td><td>package、impor</td></tr></tbody></table><p><strong>保留字：</strong></p><p>保留字：Java版本尚未使用，但以后版本可能会作为关键字使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">goto</span>、const、byValue、cast、future、 generic、 inner、 operator、 outer、 rest、 <span class="keyword">var</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>Java中true、false、friendly和null不属于关键字，也不是保留字，它们只是显式常量值，但是你在程序中不能使用它们作为标识符</li><li>Jxxxava关键字和保留字都是小写。即null是关键字，NULL不是关键字；TRUE、FALSE也不是关键字</li></ul><h2 id="4-9-进制"><a href="#4-9-进制" class="headerlink" title="4.9 进制"></a>4.9 进制</h2><p><strong>介绍</strong></p><ol><li>二进制：0,1，满2进1，以0b或0B开头</li><li>十进制：0-9，满10进1</li><li>八进制：0-7，满8进1，以数字0开头</li><li>十六进制：0-9以及A(10)~F(15),满16进1，以0x开头</li></ol><p><strong>N进制转十进制</strong></p><ol><li>二进制转十进制</li></ol><p><img src="https://pic1.imgdb.cn/item/680953bc58cb8da5c8c6c815.png" alt="img"></p><ol><li>八进制换十进制</li></ol><p><img src="https://pic1.imgdb.cn/item/680953bd58cb8da5c8c6c817.png" alt="img"></p><ol><li>十六进制转十进制</li></ol><p><img src="https://pic1.imgdb.cn/item/680953bd58cb8da5c8c6c818.png" alt="img"></p><p><strong>十进制转n进制</strong></p><ol><li>十进制转二进制</li><li>规则：将该数不断除以 2，直到商为 0 为止，然后将每步得到的余数倒过来，就是对应的二进制</li><li>十进制转八进制</li><li>规则：将该数不断除以 8，直到商为 0 为止，然后将每步得到的余数倒过来，就是对应的八进制</li><li>十进制转十六进制 规则：将该数不断除以 16，直到商为 0 为止，然后将每步得到的余数倒过来，就是对应的十六进制</li></ol><p><strong>n进制转n进制</strong></p><ol><li>二进制转八进制</li><li>规则：从低位开始,将二进制数每三位一组，转成对应的八进制数即可。 案例：请将 ob11010101 转成八进制 ob11(3)010(2)101(5) &#x3D;&gt; 0325</li><li>二进制转十六进制</li><li>规则：从低位开始，将二进制数每四位一组，转成对应的十六进制数即可。 案例：请将 ob11010101 转成十六进制 ob1101(D)0101(5) &#x3D; 0xD5</li><li>八进制转二进制</li><li>规则：将八进制数每 1 位，转成对应的一个 3 位的二进制数即可。 案例：请将 0237 转成二进制 02(010)3(011)7(111) &#x3D; 0b10011111</li><li>十六进制转二进制</li><li>规则：将十六进制数每 1 位，转成对应的 4 位的一个二进制数即可。 案例：请将 0x23B 转成二进制 0x2(0010)3(0011)B(1011) &#x3D; 0b001000111011</li></ol><h2 id="4-10-原码，反码，补码"><a href="#4-10-原码，反码，补码" class="headerlink" title="4.10 原码，反码，补码"></a>4.10 原码，反码，补码</h2><ol><li>二进制的最高位是符号位：0表示负数</li><li>正数的原码，反码，补码都一样(三码合一)</li><li>负数的反码&#x3D;它的原码符号位不变，其它位取反（ 0 -&gt; 1 ， 1 -&gt; 0 )</li><li>负数的补码&#x3D;它的反码+ 1 ，负数的反码&#x3D;负数的补码- 1</li><li>0 的反码，补码都是 0</li><li>j ava 没有无符号数，换言之， java 中的数都是有符号的</li><li>在计算机运算的时候，都是以补码的方式来运算的</li><li>当我们看运算结果的时候，要看他的原码（重点）</li></ol><h2 id="4-11位运算"><a href="#4-11位运算" class="headerlink" title="4.11位运算"></a>4.11位运算</h2><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">＆</td><td align="left">如果相对应位都是1，则结果为1，否则为0</td></tr><tr><td align="left">|</td><td align="left">如果相对应位都是 0，则结果为 0，否则为 1</td></tr><tr><td align="left">^</td><td align="left">如果相对应位值相同，则结果为0，否则为1</td></tr><tr><td align="left">〜</td><td align="left">按位取反运算符翻转操作数的每一位，即0变成1，1变成0</td></tr><tr><td align="left">&lt;&lt;</td><td align="left">按位左移运算符。左操作数按位左移右操作数指定的位数</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">按位右移运算符。左操作数按位右移右操作数指定的位数</td></tr><tr><td align="left">&gt;&gt;&gt;</td><td align="left">按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充</td></tr></tbody></table><ol><li><strong>&amp;按位与</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">                System.out.println(<span class="number">2</span> &amp; <span class="number">3</span>);<span class="comment">//结果为2</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2的补码   00000000 00000000 00000000 00000010</span></span><br><span class="line"><span class="comment">//3的补码   00000000 00000000 00000000 00000011 </span></span><br><span class="line"><span class="comment">//&amp;运算后   00000000 00000000 00000000 00000010 </span></span><br><span class="line"><span class="comment">//结果就是  2</span></span><br></pre></td></tr></table></figure><ol><li><strong>|按位或</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">                System.out.println(<span class="number">5</span> | <span class="number">3</span>);<span class="comment">//结果为7</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5转换为二进制：0000 0000 0000 0000 0000 0000 0000 0101</span></span><br><span class="line"><span class="comment">//3转换为二进制：0000 0000 0000 0000 0000 0000 0000 0011</span></span><br><span class="line"><span class="comment">//7按位或运算后：0000 0000 0000 0000 0000 0000 0000 0111</span></span><br></pre></td></tr></table></figure><ol><li><strong>~按位非</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">                System.out.println(~-<span class="number">2</span>);<span class="comment">//结果为1</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 先得到 -2的原码  10000000 00000000 00000000 00000010</span></span><br><span class="line"><span class="comment">// -2的 反码             11111111 11111111 11111111 11111101</span></span><br><span class="line"><span class="comment">// -2的 补码       11111111 11111111 11111111 11111110</span></span><br><span class="line"><span class="comment">//~-2操作          00000000 00000000 00000000 00000001  </span></span><br><span class="line"><span class="comment">//运算后的原码 就是 00000000 00000000 00000000 00000001 =&gt; 1</span></span><br></pre></td></tr></table></figure><ol><li>^<strong>按位异或</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">                System.out.println(<span class="number">5</span> ^ <span class="number">3</span>);<span class="comment">//结果为6</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5转换为二进制：0000 0000 0000 0000 0000 0000 0000 0101</span></span><br><span class="line"><span class="comment">//3转换为二进制：0000 0000 0000 0000 0000 0000 0000 0011</span></span><br><span class="line"><span class="comment">//7按位或运算后：0000 0000 0000 0000 0000 0000 0000 0111</span></span><br></pre></td></tr></table></figure><ol><li><strong>&lt;&lt;左位移运算符</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">                System.out.println(<span class="number">5</span>&lt;&lt;<span class="number">2</span>);<span class="comment">//运行结果是20</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//0000 0000 0000 0000 0000 0000 0000 0101 左移2位，低位补0：</span></span><br><span class="line"><span class="comment">//0000 0000 0000 0000 0000 0000 0001 0100 换算成10进制为20 </span></span><br><span class="line"><span class="comment">//本质 5 * 2 * 2 = 20</span></span><br></pre></td></tr></table></figure><ol><li><strong>&gt;&gt;右位移运算符</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">                System.out.println(<span class="number">5</span>&gt;&gt;<span class="number">2</span>);<span class="comment">//运行结果是1</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//0000 0000 0000 0000 0000 0000 0000 0101 右移2位，高位补0</span></span><br><span class="line"><span class="comment">//0000 0000 0000 0000 0000 0000 0000 0001</span></span><br><span class="line"><span class="comment">//本质 5 /2 / 2 = 1</span></span><br></pre></td></tr></table></figure><ol><li><strong>&gt;&gt;&gt;无符号运算符</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">                System.out.println(<span class="number">5</span>&gt;&gt;&gt;<span class="number">3</span>);<span class="comment">//结果是0</span></span><br><span class="line">                System.out.println(-<span class="number">5</span>&gt;&gt;&gt;<span class="number">3</span>);<span class="comment">//结果是536870911</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5换算成二进制： 0000 0000 0000 0000 0000 0000 0000 0101</span></span><br><span class="line"><span class="comment">//-5换算成二进制： 1111 1111 1111 1111 1111 1111 1111 1011</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5无符号右移3位后结果为0，0的二进制为： 0000 0000 0000 0000 0000 0000 0000 0000 // (用0进行补位)</span></span><br><span class="line"><span class="comment">//-5无符号右移3位后的结果 536870911 换算成二进制： 0001 1111 1111 1111 1111 1111 1111 1111 // (用0进行补位)</span></span><br></pre></td></tr></table></figure><h1 id="5-程序控制流程"><a href="#5-程序控制流程" class="headerlink" title="5.程序控制流程"></a>5.程序控制流程</h1><h2 id="5-1-顺序语句"><a href="#5-1-顺序语句" class="headerlink" title="5.1 顺序语句"></a>5.1 顺序语句</h2><p>顺序结构就是程序从上到下逐行执行，表达式语句都是顺序执行的。并且上一行对某个变量的修改对下一行会产生影响</p><p>暂时无法在飞书文档外展示此内容</p><p>Java 中定义变量时采用合法的<code>前向引用</code>。如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> num1 + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误形式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> num1 + <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2-选择结构语句"><a href="#5-2-选择结构语句" class="headerlink" title="5.2 选择结构语句"></a>5.2 选择结构语句</h2><p>if 条件判断结构</p><p><strong>语法格式：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式或<span class="type">boolean</span>类型的值)｛</span><br><span class="line">          语句块;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p><strong>执行流程：</strong></p><ol><li>首先判断条件表达式的值</li><li>如果是 true，则执行语句块</li><li>如果为 false，则不执行语句块</li></ol><p>暂时无法在飞书文档外展示此内容</p><p><strong>案例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">if01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//编写一个程序,可以输入人的年龄,如果该同志的年龄大于 18 岁</span></span><br><span class="line">        <span class="comment">// 则输出 &quot;你年龄大于 18,要对自己的行为负责,送入监狱&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">garde</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="keyword">if</span> (garde &gt; <span class="number">18</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你年龄大于18，要对自己的行为负责，送入监狱&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="If…else-语句"><a href="#If…else-语句" class="headerlink" title="If…else 语句"></a>If…else 语句</h3><p><strong>语法格式：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式) &#123; </span><br><span class="line">          语句块<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          语句块<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行流程：</strong></p><ol><li>首先判断条件表达式看其结果是 true 还是 false</li><li>如果是 true 就执行语句块 1</li><li>如果是 false 就执行语句块 2</li></ol><p>暂时无法在飞书文档外展示此内容</p><p><strong>案例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">if02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//编写一个程序,可以输入人的年龄,如果该同志的年龄大于 18 岁,</span></span><br><span class="line">        <span class="comment">// 则输出 &quot;你年龄大于 18,要对自己的行为负责, 送入监狱&quot;</span></span><br><span class="line">        <span class="comment">// 否则 ,输出&quot;你的年龄不大这次放过你了.&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">grade</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (grade &gt; <span class="number">18</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你的年龄大于18，要对自己的行为负责，送入监狱&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你的年龄不大这次放过你了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="If…-else-If…-else-语句"><a href="#If…-else-If…-else-语句" class="headerlink" title="If….else If….else 语句"></a>If….else If….else 语句</h3><p><strong>语法格式：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>说明：一旦条件表达式为true，则进入执行相应的语句块。执行完对应的语句块之后，就跳出当前结构</p><p><strong>执行流程：</strong></p><ol><li>首先判断关系表达式1看其结果是true还是false</li><li>如果是true就执行语句块1，然后结束当前多分支</li><li>如果是false就继续判断关系表达式2看其结果是true还是false</li><li>如果是true就执行语句块2，然后结束当前多分支</li><li>如果是false就继续判断关系表达式…看其结果是true还是false</li></ol><p>暂时无法在飞书文档外展示此内容</p><p><strong>案例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">if03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">cent</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cent &gt;= <span class="number">1</span> &amp;&amp; cent &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cent == <span class="number">100</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;信用极好&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cent &gt; <span class="number">80</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;信用优秀&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cent &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;信用一般&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;信用不及格&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="If…-else嵌套"><a href="#If…-else嵌套" class="headerlink" title="If….else嵌套"></a>If….else嵌套</h3><p>在一个分支结构中又完整的嵌套了另一个完整的分支结构，里面的分支的结构称为内层分支外面的分支结构称为外层分支，不要超过三层</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>()&#123;</span><br><span class="line">    <span class="keyword">if</span>()&#123;</span><br><span class="line">        <span class="keyword">if</span>-<span class="keyword">else</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>-<span class="keyword">else</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例：</strong></p><p>参加歌手比赛，如果初赛成绩大于 8.0 进入决赛，否则提示淘汰。并且根据性别提示进入男子组或女子组，输入成绩和性别，进行判断和输出信息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Nestedif</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">double</span> <span class="variable">score</span> <span class="operator">=</span> sc.nextDouble();</span><br><span class="line">        <span class="type">char</span> <span class="variable">gender</span> <span class="operator">=</span> sc.next().charAt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (score &gt; <span class="number">8.0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (gender == <span class="string">&#x27;男&#x27;</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;进入决赛&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (gender == <span class="string">&#x27;女&#x27;</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;进入决赛&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;性别有误&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;淘汰&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-3-switch条件语句"><a href="#5-3-switch条件语句" class="headerlink" title="5.3 switch条件语句"></a>5.3 switch条件语句</h2><p><strong>语法格式：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                语句体<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                语句体<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">                语句体n+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行流程：</strong></p><ol><li>首先计算出表达式的值</li><li>和case依次比较，表达式的值与case匹配就执行相应语句体</li><li>break是退出switch语句</li><li>最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分</li></ol><p><strong>案例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Switch01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> sc.next().charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;星期一&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;星期二&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;星期三&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;星期四&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;星期五&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;星期六&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;星期七&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;请输入正确的字符&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>switch语句和if语句选择:</strong></p><ol><li>如果判断的具体数值不多，而且符合byte，short，interesting，char，enum，String这六种类型，建议使用switch语句</li><li>其他情况：对区间判断，对结果为Boolean类型判断，使用if，if的使用范围更广</li></ol><h2 id="5-4-循环结构语句"><a href="#5-4-循环结构语句" class="headerlink" title="5.4 循环结构语句"></a>5.4 循环结构语句</h2><h3 id="5-5-For循环"><a href="#5-5-For循环" class="headerlink" title="5.5 For循环"></a>5.5 For循环</h3><p><strong>语法格式：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="number">1</span>循环变量初始化:<span class="number">2</span>循环条件:<span class="number">4</span>循环变量迭代)&#123;</span><br><span class="line">        <span class="number">3</span>循环体部分；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行过程：①-②-③-④-②-③-④-②-③-④-…-②</strong></p><p>暂时无法在飞书文档外展示此内容</p><p><strong>案例:</strong></p><p>打印 1~100 之间所有是 9 的倍数的整数，统计个数 及 总和</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForExercise01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">9</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;个数为：&quot;</span> + count);</span><br><span class="line">        System.out.println(<span class="string">&quot;总和：&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-6-While循环"><a href="#5-6-While循环" class="headerlink" title="5.6 While循环"></a>5.6 While循环</h3><h3 id="5-7-Do…while循环"><a href="#5-7-Do…while循环" class="headerlink" title="5.7 Do…while循环"></a>5.7 Do…while循环</h3><h3 id="5-8-多重循环"><a href="#5-8-多重循环" class="headerlink" title="5.8 多重循环"></a>5.8 多重循环</h3><ol><li>将一个循环放在另一个循环体内，就形成了嵌套循环，其中for,while,do…while循环均可以作为外层循环和内层循环</li><li>实质上，嵌套循环就是把内层循环当成外层循环的循环体，当只有内层循环的循环条件为false时才会跳出内层循环，才可结束外层循环的当次循环，开始下一次的循环</li><li>设外层循环次数为m次，内层为n次，则内层循环体实际上需要执行m*n次</li></ol><p><strong>案例：</strong></p><ol><li>九九乘法表</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MulForExercise02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//九九乘法表</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                System.out.print(j + <span class="string">&quot; * &quot;</span> + i + <span class="string">&quot; = &quot;</span> + i * j + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span>×<span class="number">1</span>=<span class="number">1</span>   </span><br><span class="line"><span class="number">1</span>×<span class="number">2</span>=<span class="number">2</span>   <span class="number">2</span>×<span class="number">2</span>=<span class="number">4</span>   </span><br><span class="line"><span class="number">1</span>×<span class="number">3</span>=<span class="number">3</span>   <span class="number">2</span>×<span class="number">3</span>=<span class="number">6</span>   <span class="number">3</span>×<span class="number">3</span>=<span class="number">9</span>   </span><br><span class="line"><span class="number">1</span>×<span class="number">4</span>=<span class="number">4</span>   <span class="number">2</span>×<span class="number">4</span>=<span class="number">8</span>   <span class="number">3</span>×<span class="number">4</span>=<span class="number">12</span>  <span class="number">4</span>×<span class="number">4</span>=<span class="number">16</span>  </span><br><span class="line"><span class="number">1</span>×<span class="number">5</span>=<span class="number">5</span>   <span class="number">2</span>×<span class="number">5</span>=<span class="number">10</span>  <span class="number">3</span>×<span class="number">5</span>=<span class="number">15</span>  <span class="number">4</span>×<span class="number">5</span>=<span class="number">20</span>  <span class="number">5</span>×<span class="number">5</span>=<span class="number">25</span>  </span><br><span class="line"><span class="number">1</span>×<span class="number">6</span>=<span class="number">6</span>   <span class="number">2</span>×<span class="number">6</span>=<span class="number">12</span>  <span class="number">3</span>×<span class="number">6</span>=<span class="number">18</span>  <span class="number">4</span>×<span class="number">6</span>=<span class="number">24</span>  <span class="number">5</span>×<span class="number">6</span>=<span class="number">30</span>  <span class="number">6</span>×<span class="number">6</span>=<span class="number">36</span>  </span><br><span class="line"><span class="number">1</span>×<span class="number">7</span>=<span class="number">7</span>   <span class="number">2</span>×<span class="number">7</span>=<span class="number">14</span>  <span class="number">3</span>×<span class="number">7</span>=<span class="number">21</span>  <span class="number">4</span>×<span class="number">7</span>=<span class="number">28</span>  <span class="number">5</span>×<span class="number">7</span>=<span class="number">35</span>  <span class="number">6</span>×<span class="number">7</span>=<span class="number">42</span>  <span class="number">7</span>×<span class="number">7</span>=<span class="number">49</span>  </span><br><span class="line"><span class="number">1</span>×<span class="number">8</span>=<span class="number">8</span>   <span class="number">2</span>×<span class="number">8</span>=<span class="number">16</span>  <span class="number">3</span>×<span class="number">8</span>=<span class="number">24</span>  <span class="number">4</span>×<span class="number">8</span>=<span class="number">32</span>  <span class="number">5</span>×<span class="number">8</span>=<span class="number">40</span>  <span class="number">6</span>×<span class="number">8</span>=<span class="number">48</span>  <span class="number">7</span>×<span class="number">8</span>=<span class="number">56</span>  <span class="number">8</span>×<span class="number">8</span>=<span class="number">64</span>  </span><br><span class="line"><span class="number">1</span>×<span class="number">9</span>=<span class="number">9</span>   <span class="number">2</span>×<span class="number">9</span>=<span class="number">18</span>  <span class="number">3</span>×<span class="number">9</span>=<span class="number">27</span>  <span class="number">4</span>×<span class="number">9</span>=<span class="number">36</span>  <span class="number">5</span>×<span class="number">9</span>=<span class="number">45</span>  <span class="number">6</span>×<span class="number">9</span>=<span class="number">54</span>  <span class="number">7</span>×<span class="number">9</span>=<span class="number">63</span>  <span class="number">8</span>×<span class="number">9</span>=<span class="number">72</span>  <span class="number">9</span>×<span class="number">9</span>=<span class="number">81</span></span><br></pre></td></tr></table></figure><ol><li>空心金字塔</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MulForExercise03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">            <span class="comment">//空格</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= num - i; k++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出 * 号</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= (<span class="number">2</span> * i) - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="comment">//当前行的第一个位置是*,最后一个位置也是*, 最后一层全部 *</span></span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">1</span> || j == (<span class="number">2</span> * i) - <span class="number">1</span> || i == num) &#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//其他情况输出空格</span></span><br><span class="line">                    System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//每打印完一层的*后，就换行</span></span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">5</span></span><br><span class="line">    *</span><br><span class="line">   * *</span><br><span class="line">  *   *</span><br><span class="line"> *     *</span><br><span class="line">*********</span><br></pre></td></tr></table></figure><h2 id="5-9-跳转控制语句"><a href="#5-9-跳转控制语句" class="headerlink" title="5.9 跳转控制语句"></a>5.9 跳转控制语句</h2><h3 id="5-9-1-Break"><a href="#5-9-1-Break" class="headerlink" title="5.9.1 Break"></a>5.9.1 Break</h3><ul><li>break语句用于终止某个语句块的执行，一般使用在switch语句或者循环[for,while,do-while]中</li><li>break 跳出最里层的循环，并且继续执行该循环下面的语句</li></ul><p><strong>案例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">int</span> [] numbers = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> x : numbers ) &#123;</span><br><span class="line">         <span class="comment">// x 等于 30 时跳出循环</span></span><br><span class="line">         <span class="keyword">if</span>( x == <span class="number">30</span> ) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.print( x );</span><br><span class="line">         System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><h3 id="5-9-2-Continue"><a href="#5-9-2-Continue" class="headerlink" title="5.9.2 Continue"></a>5.9.2 Continue</h3><ul><li>continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代</li><li>在 for 循环中，continue 语句使程序立即跳转到更新语句</li><li>在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句</li></ul><p>案例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">int</span> [] numbers = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> x : numbers ) &#123;</span><br><span class="line">         <span class="keyword">if</span>( x == <span class="number">30</span> ) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.print( x );</span><br><span class="line">         System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">40</span></span><br><span class="line"><span class="number">50</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
